Index: package/lispconf/src/cmdline.h
===================================================================
--- package/lispconf/src/cmdline.h	(revision 0)
+++ package/lispconf/src/cmdline.h	(revision 0)
@@ -0,0 +1,220 @@
+/** @file cmdline.h
+ *  @brief The header file for the command line option parser
+ *  generated by GNU Gengetopt version 2.22.4
+ *  http://www.gnu.org/software/gengetopt.
+ *  DO NOT modify this file, since it can be overwritten
+ *  @author GNU Gengetopt by Lorenzo Bettini */
+
+#ifndef CMDLINE_H
+#define CMDLINE_H
+
+/* If we use autoconf.  */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h> /* for FILE */
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#ifndef CMDLINE_PARSER_PACKAGE
+/** @brief the program name (used for printing errors) */
+#define CMDLINE_PARSER_PACKAGE "lispconf"
+#endif
+
+#ifndef CMDLINE_PARSER_PACKAGE_NAME
+/** @brief the complete program name (used for help and version) */
+#define CMDLINE_PARSER_PACKAGE_NAME "lispconf"
+#endif
+
+#ifndef CMDLINE_PARSER_VERSION
+/** @brief the program version */
+#define CMDLINE_PARSER_VERSION "0.1"
+#endif
+
+/** @brief Where the command line options are stored */
+struct gengetopt_args_info
+{
+  const char *help_help; /**< @brief Print help and exit help description.  */
+  const char *version_help; /**< @brief Print version and exit help description.  */
+  char * add_entry_arg;	/**< @brief Add a map cache or db entry (default='db').  */
+  char * add_entry_orig;	/**< @brief Add a map cache or db entry original value given at command line.  */
+  const char *add_entry_help; /**< @brief Add a map cache or db entry help description.  */
+  char * eid_arg;	/**< @brief EID in CIDR prefix notation <addr>/<len>.  */
+  char * eid_orig;	/**< @brief EID in CIDR prefix notation <addr>/<len> original value given at command line.  */
+  const char *eid_help; /**< @brief EID in CIDR prefix notation <addr>/<len> help description.  */
+  char * rloc_arg;	/**< @brief RLOC as IP Address.  */
+  char * rloc_orig;	/**< @brief RLOC as IP Address original value given at command line.  */
+  const char *rloc_help; /**< @brief RLOC as IP Address help description.  */
+  int priority_arg;	/**< @brief priority.  */
+  char * priority_orig;	/**< @brief priority original value given at command line.  */
+  const char *priority_help; /**< @brief priority help description.  */
+  int weight_arg;	/**< @brief weight.  */
+  char * weight_orig;	/**< @brief weight original value given at command line.  */
+  const char *weight_help; /**< @brief weight help description.  */
+  int ttl_arg;	/**< @brief Time-to-live in seconds.  */
+  char * ttl_orig;	/**< @brief Time-to-live in seconds original value given at command line.  */
+  const char *ttl_help; /**< @brief Time-to-live in seconds help description.  */
+  char * print_arg;	/**< @brief Print EID table (default='cache').  */
+  char * print_orig;	/**< @brief Print EID table original value given at command line.  */
+  const char *print_help; /**< @brief Print EID table help description.  */
+  char * filter_prefix_arg;	/**< @brief EID prefix filter.  */
+  char * filter_prefix_orig;	/**< @brief EID prefix filter original value given at command line.  */
+  const char *filter_prefix_help; /**< @brief EID prefix filter help description.  */
+  char * list_arg;	/**< @brief List EIDs or RLOCS (default='eids').  */
+  char * list_orig;	/**< @brief List EIDs or RLOCS original value given at command line.  */
+  const char *list_help; /**< @brief List EIDs or RLOCS help description.  */
+  char * interface_arg;	/**< @brief Specify a local interface as RLOC of LISP encapsulated packets.  */
+  char * interface_orig;	/**< @brief Specify a local interface as RLOC of LISP encapsulated packets original value given at command line.  */
+  const char *interface_help; /**< @brief Specify a local interface as RLOC of LISP encapsulated packets help description.  */
+  
+  unsigned int help_given ;	/**< @brief Whether help was given.  */
+  unsigned int version_given ;	/**< @brief Whether version was given.  */
+  unsigned int add_entry_given ;	/**< @brief Whether add-entry was given.  */
+  unsigned int eid_given ;	/**< @brief Whether eid was given.  */
+  unsigned int rloc_given ;	/**< @brief Whether rloc was given.  */
+  unsigned int priority_given ;	/**< @brief Whether priority was given.  */
+  unsigned int weight_given ;	/**< @brief Whether weight was given.  */
+  unsigned int ttl_given ;	/**< @brief Whether ttl was given.  */
+  unsigned int print_given ;	/**< @brief Whether print was given.  */
+  unsigned int filter_prefix_given ;	/**< @brief Whether filter-prefix was given.  */
+  unsigned int list_given ;	/**< @brief Whether list was given.  */
+  unsigned int interface_given ;	/**< @brief Whether interface was given.  */
+
+  int addmode_mode_counter; /**< @brief Counter for mode addmode */
+  int delmode_mode_counter; /**< @brief Counter for mode delmode */
+  int listmode_mode_counter; /**< @brief Counter for mode listmode */
+  int printmode_mode_counter; /**< @brief Counter for mode printmode */
+  int rlocmode_mode_counter; /**< @brief Counter for mode rlocmode */
+} ;
+
+/** @brief The additional parameters to pass to parser functions */
+struct cmdline_parser_params
+{
+  int override; /**< @brief whether to override possibly already present options (default 0) */
+  int initialize; /**< @brief whether to initialize the option structure gengetopt_args_info (default 1) */
+  int check_required; /**< @brief whether to check that all required options were provided (default 1) */
+  int check_ambiguity; /**< @brief whether to check for options already specified in the option structure gengetopt_args_info (default 0) */
+  int print_errors; /**< @brief whether getopt_long should print an error message for a bad option (default 1) */
+} ;
+
+/** @brief the purpose string of the program */
+extern const char *gengetopt_args_info_purpose;
+/** @brief the usage string of the program */
+extern const char *gengetopt_args_info_usage;
+/** @brief all the lines making the help output */
+extern const char *gengetopt_args_info_help[];
+
+/**
+ * The command line parser
+ * @param argc the number of command line options
+ * @param argv the command line options
+ * @param args_info the structure where option information will be stored
+ * @return 0 if everything went fine, NON 0 if an error took place
+ */
+int cmdline_parser (int argc, char **argv,
+  struct gengetopt_args_info *args_info);
+
+/**
+ * The command line parser (version with additional parameters - deprecated)
+ * @param argc the number of command line options
+ * @param argv the command line options
+ * @param args_info the structure where option information will be stored
+ * @param override whether to override possibly already present options
+ * @param initialize whether to initialize the option structure my_args_info
+ * @param check_required whether to check that all required options were provided
+ * @return 0 if everything went fine, NON 0 if an error took place
+ * @deprecated use cmdline_parser_ext() instead
+ */
+int cmdline_parser2 (int argc, char **argv,
+  struct gengetopt_args_info *args_info,
+  int override, int initialize, int check_required);
+
+/**
+ * The command line parser (version with additional parameters)
+ * @param argc the number of command line options
+ * @param argv the command line options
+ * @param args_info the structure where option information will be stored
+ * @param params additional parameters for the parser
+ * @return 0 if everything went fine, NON 0 if an error took place
+ */
+int cmdline_parser_ext (int argc, char **argv,
+  struct gengetopt_args_info *args_info,
+  struct cmdline_parser_params *params);
+
+/**
+ * Save the contents of the option struct into an already open FILE stream.
+ * @param outfile the stream where to dump options
+ * @param args_info the option struct to dump
+ * @return 0 if everything went fine, NON 0 if an error took place
+ */
+int cmdline_parser_dump(FILE *outfile,
+  struct gengetopt_args_info *args_info);
+
+/**
+ * Save the contents of the option struct into a (text) file.
+ * This file can be read by the config file parser (if generated by gengetopt)
+ * @param filename the file where to save
+ * @param args_info the option struct to save
+ * @return 0 if everything went fine, NON 0 if an error took place
+ */
+int cmdline_parser_file_save(const char *filename,
+  struct gengetopt_args_info *args_info);
+
+/**
+ * Print the help
+ */
+void cmdline_parser_print_help(void);
+/**
+ * Print the version
+ */
+void cmdline_parser_print_version(void);
+
+/**
+ * Initializes all the fields a cmdline_parser_params structure 
+ * to their default values
+ * @param params the structure to initialize
+ */
+void cmdline_parser_params_init(struct cmdline_parser_params *params);
+
+/**
+ * Allocates dynamically a cmdline_parser_params structure and initializes
+ * all its fields to their default values
+ * @return the created and initialized cmdline_parser_params structure
+ */
+struct cmdline_parser_params *cmdline_parser_params_create(void);
+
+/**
+ * Initializes the passed gengetopt_args_info structure's fields
+ * (also set default values for options that have a default)
+ * @param args_info the structure to initialize
+ */
+void cmdline_parser_init (struct gengetopt_args_info *args_info);
+/**
+ * Deallocates the string fields of the gengetopt_args_info structure
+ * (but does not deallocate the structure itself)
+ * @param args_info the structure to deallocate
+ */
+void cmdline_parser_free (struct gengetopt_args_info *args_info);
+
+/**
+ * Checks that all the required options were specified
+ * @param args_info the structure to check
+ * @param prog_name the name of the program that will be used to print
+ *   possible errors
+ * @return
+ */
+int cmdline_parser_required (struct gengetopt_args_info *args_info,
+  const char *prog_name);
+
+extern const char *cmdline_parser_add_entry_values[];  /**< @brief Possible values for add-entry. */
+extern const char *cmdline_parser_print_values[];  /**< @brief Possible values for print. */
+extern const char *cmdline_parser_list_values[];  /**< @brief Possible values for list. */
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* CMDLINE_H */
Index: package/lispconf/src/LICENSE
===================================================================
--- package/lispconf/src/LICENSE	(revision 0)
+++ package/lispconf/src/LICENSE	(revision 0)
@@ -0,0 +1,341 @@
+  GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+               51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) 19yy  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) 19yy name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
Index: package/lispconf/src/lispconf.ggo
===================================================================
--- package/lispconf/src/lispconf.ggo	(revision 0)
+++ package/lispconf/src/lispconf.ggo	(revision 0)
@@ -0,0 +1,34 @@
+package "lispconf"
+version "0.1"
+
+# Add cache entry mode
+defmode "addmode" 
+modeoption "add-entry" a "Add a map cache or db entry" values="db","cache" default="db" mode="addmode" required
+modeoption "eid" e "EID in CIDR prefix notation <addr>/<len>" 
+	   string typestr="IP Address/Prefix Length" mode="addmode" required
+modeoption "rloc" r "RLOC as IP Address" 
+	   string typestr="IP Address" mode="addmode" required
+modeoption "priority" p "priority"
+	   int typestr="priority" mode="addmode" required
+modeoption "weight" w "weight"
+	   int typestr="weight" mode="addmode" required
+modeoption "ttl" t "Time-to-live in seconds"
+	   int typestr="Time" mode="addmode" optional
+
+# delete database entry mode
+defmode "delmode"
+
+
+# print entries mode
+defmode "printmode"
+modeoption "print" x "Print EID table" values="db","cache" default="cache" mode="printmode" optional
+modeoption "filter-prefix" f "EID prefix filter" 
+	   string typestr="IP Address Prefix" mode="printmode" optional
+
+defmode "listmode"
+modeoption "list" l "List EIDs or RLOCS" values="eids","rlocs" default="eids" mode="listmode" optional
+
+# Set transport source interface mode
+defmode "rlocmode"
+modeoption "interface" i "Specify a local interface as RLOC of LISP encapsulated packets" string typestr="Linux network interface device name" mode="rlocmode" optional
+
Index: package/lispconf/src/lisp_ipc.h
===================================================================
--- package/lispconf/src/lisp_ipc.h	(revision 0)
+++ package/lispconf/src/lisp_ipc.h	(revision 0)
@@ -0,0 +1,267 @@
+/*
+ * lisp_ipc.h
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Defines the message structure for lisp ipc messages.
+ * These messages can be used to communicate between
+ * lisp user-level processes and the kernel, for example.
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    Chris White       <chris@logicalelegance.com>
+ *    David Meyer		<dmm@cisco.com>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+#pragma once
+
+#ifdef KERNEL
+#include <linux/in.h>
+#include <linux/inet.h>
+#include <linux/in6.h>
+#endif /* KERNEL */
+
+/*
+ * Constants
+ */
+#define MAX_MSG_LENGTH 1024  /* Max total message size. */
+
+/*
+ * XXX Temporary, needs to be in 
+ * /usr/include/linux/netlink.h
+ * formally.
+ */
+#define NETLINK_LISP 20 
+
+/*
+ * Lisp message types
+ */
+typedef enum {
+  LispOk = 0,
+  LispFailed = 1,
+  LispMapCacheLookup = 2,
+  LispMapCacheEIDList = 3,  // For ???
+  LispMapCacheRLOCList = 4, // For SMR's
+  LispDatabaseLookup = 5,
+  LispCacheSample = 6,      /* Kernel to process-level */
+  LispSetRLOC = 7,
+  LispMapCacheAdd = 8,
+  LispMapCacheDelete = 9,
+  LispMapCacheClear = 10,
+  LispDatabaseAdd = 11,
+  LispDatabaseDelete = 12,
+  LispDaemonRegister = 13,
+  LispTrafficMonStart = 14,
+  LispSetUDPPorts = 15,
+  LispMaxType = LispSetUDPPorts
+} lisp_msgtype_e;
+
+/* 
+ * Lisp address structure
+ */
+typedef struct {
+  union {
+    struct in_addr ip;
+    struct in6_addr ipv6;
+  } address;
+  int afi;
+} lisp_addr_t;
+
+/*
+ * Top level LISP message type, 
+ * all other messages are placed inside.
+ */
+typedef struct _lisp_cmd {
+  uint16_t type;
+  uint16_t length; // No message can exceed MAX_MSG_LENGTH - nlmsghdr length
+  char val[0];
+} lisp_cmd_t;
+
+/*
+ * Convey the UDP ports to use for encapsulation
+ * and controlto the kernel module. Sent by lispd.
+ */
+typedef struct {
+    uint16_t data_port;
+    uint16_t control_port;
+} lisp_set_ports_msg_t;
+
+typedef struct _lisp_lookup_msg {
+  lisp_addr_t prefix;
+  uint32_t    prefix_length;
+  int         exact_match;
+  int         all_entries;
+} lisp_lookup_msg_t;
+
+typedef struct _lisp_set_rloc_msg {
+  lisp_addr_t addr;
+} lisp_set_rloc_msg_t;
+
+#define ACTION_DROP         0
+#define ACTION_FORWARD      1
+#define ACTION_SEND_MAP_REQ 2
+
+/*
+ * Locator portion of eid map msg
+ */
+typedef struct {
+  lisp_addr_t locator;
+  uint8_t priority;
+  uint8_t weight;
+  uint8_t mpriority;
+  uint8_t mweight;
+} lisp_eid_map_msg_loc_t;
+
+/*
+ * Message structure for adding a cache entry,
+ * sent from user-space processes to the kernel.
+ */
+typedef struct {
+  lisp_addr_t   eid_prefix;
+  uint16_t      eid_prefix_length;
+  uint8_t       count;
+  uint8_t       actions; /* Defined above */
+  uint16_t      how_learned; /* 0: static or 1: map-reply */
+  uint32_t      ttl;
+  uint32_t      sampling_interval; /* In seconds, 0 never sample */
+  uint8_t       locators[0];
+} lisp_eid_map_msg_t;
+
+/*
+ * Compact response types for parties only
+ * interested in a list of RLOC's or EID's
+ * currently in use (for SMR, rloc probe purposes).
+ */
+typedef struct {
+    int cookie;               // opaque value passed back to lispd
+    int count;
+    lisp_addr_t addr_list[0];
+} lisp_cache_address_list_t;
+
+/*
+ * Response type for a cache entry lookup,
+ * sent from the kernel to user-space.
+ */
+typedef struct {
+  lisp_addr_t   locator;
+  uint8_t       priority;
+  uint8_t       weight;
+  uint8_t       mpriority;
+  uint8_t       mweight;
+  uint8_t       reachability_alg:2; /* rloc_prob | echo_none */
+  uint8_t       state:1;
+  uint8_t       reserved:5;
+  uint32_t      data_packets_in;
+  uint32_t      data_packets_out;
+} lisp_cache_response_loc_t;
+
+typedef struct {
+  lisp_addr_t eid_prefix;
+  uint8_t     eid_prefix_length;
+  uint8_t     how_learned:1;
+  uint8_t     complete:1;
+  uint8_t     actions:2;
+  uint8_t     locators_present:1;
+  uint8_t     reserved:3;
+  uint32_t    nonce0;
+  uint32_t    nonce1;
+  uint16_t    lsb;
+  uint16_t    ttl;
+  uint32_t    timestamp;
+  uint32_t    control_packets_in;
+  uint32_t    control_packets_out;
+  uint8_t     num_locators;
+  lisp_cache_response_loc_t locators[0];
+} lisp_cache_response_msg_t;
+
+/*
+ * Message structure for adding a database entry,
+ * sent from user-space to the kernel.
+ */
+typedef struct {
+    lisp_addr_t locator;
+    uint8_t     priority;
+    uint8_t     weight;
+    uint8_t     mpriority;
+    uint8_t     mweight;
+} lisp_db_add_msg_loc_t;
+
+typedef struct {
+  lisp_addr_t           eid_prefix;
+  uint16_t              eid_prefix_length;
+  uint16_t              count;
+  lisp_db_add_msg_loc_t locators[0];
+} lisp_db_add_msg_t;
+
+/* 
+ * Response type for a database entry lookup,
+ * sent from the kernel to user-space.
+ */
+typedef struct {
+  lisp_addr_t    locator;
+  uint8_t        priority;
+  uint8_t	 weight;
+  uint8_t        mpriority;
+  uint8_t	 mweight;
+  uint8_t	 reserved:4;		
+} lisp_db_response_loc_t;
+
+typedef struct {
+  lisp_addr_t    eid_prefix;
+  uint8_t        eid_prefix_length;
+  uint8_t        num_locators;
+  uint16_t         lsb;
+  lisp_db_response_loc_t locators[0];
+} lisp_db_response_msg_t;
+
+/* 
+ * Database deletion message type. Sent
+ * from user-space to the kernel.
+ */
+typedef struct {
+  lisp_addr_t eid_prefix;
+  uint8_t     eid_prefix_length;
+  lisp_addr_t     locator;
+} lisp_db_delete_msg_t;
+  
+/*
+ * Cache miss or sampling notification, sent from kernel
+ * to lispd. When sent with no locators, indicates cache
+ * miss. Also sent *back* from lispd to the kernel
+ * when an RLOC probe sequence is completed for an EID.
+ * In this case, the status bits indicate the reachability
+ * of the locators in the list.
+ */
+typedef enum {
+    ProbeSample,
+    SMRSample,
+    CacheMiss
+} sample_reason_e;
+
+typedef struct {
+  int         reason;
+  lisp_addr_t eid;
+  int         eid_prefix_length; /* Unused when cache miss */
+  int         num_locators;      /* zero when cache miss */
+  int         status_bits;       /* Bitfield filled by lispd when sending back to kernel */
+  lisp_addr_t locators[0];
+} lisp_cache_sample_msg_t;
Index: package/lispconf/src/Makefile-orig
===================================================================
--- package/lispconf/src/Makefile-orig	(revision 0)
+++ package/lispconf/src/Makefile-orig	(revision 0)
@@ -0,0 +1,19 @@
+CC=gcc
+GENGETOPT=gengetopt
+CFLAGS=-I../include -g
+DEPS = ../include/lisp_ipc.h
+LIBS = -lm
+LDFLAGS = $(LIBS)
+OBJS = cmdline.o lispconf.o 
+
+lispconf: $(OBJS)
+	gcc -o $@ $^ $(CFLAGS) $(LDFLAGS)
+
+cmdline.c: lispconf.ggo
+	$(GENGETOPT) -i $<
+
+%.o: %.c $(DEPS)
+	$(CC) -c -o $@ $< $(CFLAGS)
+
+clean:
+	rm -f *.o cmdline.[ch] lispconf
Index: package/lispconf/src/cmdline.c
===================================================================
--- package/lispconf/src/cmdline.c	(revision 0)
+++ package/lispconf/src/cmdline.c	(revision 0)
@@ -0,0 +1,903 @@
+/*
+  File autogenerated by gengetopt version 2.22.4
+  generated with the following command:
+  gengetopt -i lispconf.ggo 
+
+  The developers of gengetopt consider the fixed text that goes in all
+  gengetopt output files to be in the public domain:
+  we make no copyright claims on it.
+*/
+
+/* If we use autoconf.  */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#ifndef FIX_UNUSED
+#define FIX_UNUSED(X) (void) (X) /* avoid warnings for unused params */
+#endif
+
+#include <getopt.h>
+
+#include "cmdline.h"
+
+const char *gengetopt_args_info_purpose = "";
+
+const char *gengetopt_args_info_usage = "Usage: lispconf [OPTIONS]...";
+
+const char *gengetopt_args_info_description = "";
+
+const char *gengetopt_args_info_help[] = {
+  "  -h, --help                    Print help and exit",
+  "  -V, --version                 Print version and exit",
+  "\n Mode: addmode",
+  "  -a, --add-entry=STRING        Add a map cache or db entry  (possible \n                                  values=\"db\", \"cache\" default=`db')",
+  "  -e, --eid=IP Address/Prefix Length\n                                EID in CIDR prefix notation <addr>/<len>",
+  "  -r, --rloc=IP Address         RLOC as IP Address",
+  "  -p, --priority=priority       priority",
+  "  -w, --weight=weight           weight",
+  "  -t, --ttl=Time                Time-to-live in seconds",
+  "\n Mode: printmode",
+  "  -x, --print=STRING            Print EID table  (possible values=\"db\", \n                                  \"cache\" default=`cache')",
+  "  -f, --filter-prefix=IP Address Prefix\n                                EID prefix filter",
+  "\n Mode: listmode",
+  "  -l, --list=STRING             List EIDs or RLOCS  (possible values=\"eids\", \n                                  \"rlocs\" default=`eids')",
+  "\n Mode: rlocmode",
+  "  -i, --interface=Linux network interface device name\n                                Specify a local interface as RLOC of LISP \n                                  encapsulated packets",
+    0
+};
+
+typedef enum {ARG_NO
+  , ARG_STRING
+  , ARG_INT
+} cmdline_parser_arg_type;
+
+static
+void clear_given (struct gengetopt_args_info *args_info);
+static
+void clear_args (struct gengetopt_args_info *args_info);
+
+static int
+cmdline_parser_internal (int argc, char **argv, struct gengetopt_args_info *args_info,
+                        struct cmdline_parser_params *params, const char *additional_error);
+
+static int
+cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error);
+
+const char *cmdline_parser_add_entry_values[] = {"db", "cache", 0}; /*< Possible values for add-entry. */
+const char *cmdline_parser_print_values[] = {"db", "cache", 0}; /*< Possible values for print. */
+const char *cmdline_parser_list_values[] = {"eids", "rlocs", 0}; /*< Possible values for list. */
+
+static char *
+gengetopt_strdup (const char *s);
+
+static
+void clear_given (struct gengetopt_args_info *args_info)
+{
+  args_info->help_given = 0 ;
+  args_info->version_given = 0 ;
+  args_info->add_entry_given = 0 ;
+  args_info->eid_given = 0 ;
+  args_info->rloc_given = 0 ;
+  args_info->priority_given = 0 ;
+  args_info->weight_given = 0 ;
+  args_info->ttl_given = 0 ;
+  args_info->print_given = 0 ;
+  args_info->filter_prefix_given = 0 ;
+  args_info->list_given = 0 ;
+  args_info->interface_given = 0 ;
+  args_info->addmode_mode_counter = 0 ;
+  args_info->delmode_mode_counter = 0 ;
+  args_info->listmode_mode_counter = 0 ;
+  args_info->printmode_mode_counter = 0 ;
+  args_info->rlocmode_mode_counter = 0 ;
+}
+
+static
+void clear_args (struct gengetopt_args_info *args_info)
+{
+  FIX_UNUSED (args_info);
+  args_info->add_entry_arg = gengetopt_strdup ("db");
+  args_info->add_entry_orig = NULL;
+  args_info->eid_arg = NULL;
+  args_info->eid_orig = NULL;
+  args_info->rloc_arg = NULL;
+  args_info->rloc_orig = NULL;
+  args_info->priority_orig = NULL;
+  args_info->weight_orig = NULL;
+  args_info->ttl_orig = NULL;
+  args_info->print_arg = gengetopt_strdup ("cache");
+  args_info->print_orig = NULL;
+  args_info->filter_prefix_arg = NULL;
+  args_info->filter_prefix_orig = NULL;
+  args_info->list_arg = gengetopt_strdup ("eids");
+  args_info->list_orig = NULL;
+  args_info->interface_arg = NULL;
+  args_info->interface_orig = NULL;
+  
+}
+
+static
+void init_args_info(struct gengetopt_args_info *args_info)
+{
+
+
+  args_info->help_help = gengetopt_args_info_help[0] ;
+  args_info->version_help = gengetopt_args_info_help[1] ;
+  args_info->add_entry_help = gengetopt_args_info_help[3] ;
+  args_info->eid_help = gengetopt_args_info_help[4] ;
+  args_info->rloc_help = gengetopt_args_info_help[5] ;
+  args_info->priority_help = gengetopt_args_info_help[6] ;
+  args_info->weight_help = gengetopt_args_info_help[7] ;
+  args_info->ttl_help = gengetopt_args_info_help[8] ;
+  args_info->print_help = gengetopt_args_info_help[10] ;
+  args_info->filter_prefix_help = gengetopt_args_info_help[11] ;
+  args_info->list_help = gengetopt_args_info_help[13] ;
+  args_info->interface_help = gengetopt_args_info_help[15] ;
+  
+}
+
+void
+cmdline_parser_print_version (void)
+{
+  printf ("%s %s\n",
+     (strlen(CMDLINE_PARSER_PACKAGE_NAME) ? CMDLINE_PARSER_PACKAGE_NAME : CMDLINE_PARSER_PACKAGE),
+     CMDLINE_PARSER_VERSION);
+}
+
+static void print_help_common(void) {
+  cmdline_parser_print_version ();
+
+  if (strlen(gengetopt_args_info_purpose) > 0)
+    printf("\n%s\n", gengetopt_args_info_purpose);
+
+  if (strlen(gengetopt_args_info_usage) > 0)
+    printf("\n%s\n", gengetopt_args_info_usage);
+
+  printf("\n");
+
+  if (strlen(gengetopt_args_info_description) > 0)
+    printf("%s\n\n", gengetopt_args_info_description);
+}
+
+void
+cmdline_parser_print_help (void)
+{
+  int i = 0;
+  print_help_common();
+  while (gengetopt_args_info_help[i])
+    printf("%s\n", gengetopt_args_info_help[i++]);
+}
+
+void
+cmdline_parser_init (struct gengetopt_args_info *args_info)
+{
+  clear_given (args_info);
+  clear_args (args_info);
+  init_args_info (args_info);
+}
+
+void
+cmdline_parser_params_init(struct cmdline_parser_params *params)
+{
+  if (params)
+    { 
+      params->override = 0;
+      params->initialize = 1;
+      params->check_required = 1;
+      params->check_ambiguity = 0;
+      params->print_errors = 1;
+    }
+}
+
+struct cmdline_parser_params *
+cmdline_parser_params_create(void)
+{
+  struct cmdline_parser_params *params = 
+    (struct cmdline_parser_params *)malloc(sizeof(struct cmdline_parser_params));
+  cmdline_parser_params_init(params);  
+  return params;
+}
+
+static void
+free_string_field (char **s)
+{
+  if (*s)
+    {
+      free (*s);
+      *s = 0;
+    }
+}
+
+
+static void
+cmdline_parser_release (struct gengetopt_args_info *args_info)
+{
+
+  free_string_field (&(args_info->add_entry_arg));
+  free_string_field (&(args_info->add_entry_orig));
+  free_string_field (&(args_info->eid_arg));
+  free_string_field (&(args_info->eid_orig));
+  free_string_field (&(args_info->rloc_arg));
+  free_string_field (&(args_info->rloc_orig));
+  free_string_field (&(args_info->priority_orig));
+  free_string_field (&(args_info->weight_orig));
+  free_string_field (&(args_info->ttl_orig));
+  free_string_field (&(args_info->print_arg));
+  free_string_field (&(args_info->print_orig));
+  free_string_field (&(args_info->filter_prefix_arg));
+  free_string_field (&(args_info->filter_prefix_orig));
+  free_string_field (&(args_info->list_arg));
+  free_string_field (&(args_info->list_orig));
+  free_string_field (&(args_info->interface_arg));
+  free_string_field (&(args_info->interface_orig));
+  
+  
+
+  clear_given (args_info);
+}
+
+/**
+ * @param val the value to check
+ * @param values the possible values
+ * @return the index of the matched value:
+ * -1 if no value matched,
+ * -2 if more than one value has matched
+ */
+static int
+check_possible_values(const char *val, const char *values[])
+{
+  int i, found, last;
+  size_t len;
+
+  if (!val)   /* otherwise strlen() crashes below */
+    return -1; /* -1 means no argument for the option */
+
+  found = last = 0;
+
+  for (i = 0, len = strlen(val); values[i]; ++i)
+    {
+      if (strncmp(val, values[i], len) == 0)
+        {
+          ++found;
+          last = i;
+          if (strlen(values[i]) == len)
+            return i; /* exact macth no need to check more */
+        }
+    }
+
+  if (found == 1) /* one match: OK */
+    return last;
+
+  return (found ? -2 : -1); /* return many values or none matched */
+}
+
+
+static void
+write_into_file(FILE *outfile, const char *opt, const char *arg, const char *values[])
+{
+  int found = -1;
+  if (arg) {
+    if (values) {
+      found = check_possible_values(arg, values);      
+    }
+    if (found >= 0)
+      fprintf(outfile, "%s=\"%s\" # %s\n", opt, arg, values[found]);
+    else
+      fprintf(outfile, "%s=\"%s\"\n", opt, arg);
+  } else {
+    fprintf(outfile, "%s\n", opt);
+  }
+}
+
+
+int
+cmdline_parser_dump(FILE *outfile, struct gengetopt_args_info *args_info)
+{
+  int i = 0;
+
+  if (!outfile)
+    {
+      fprintf (stderr, "%s: cannot dump options to stream\n", CMDLINE_PARSER_PACKAGE);
+      return EXIT_FAILURE;
+    }
+
+  if (args_info->help_given)
+    write_into_file(outfile, "help", 0, 0 );
+  if (args_info->version_given)
+    write_into_file(outfile, "version", 0, 0 );
+  if (args_info->add_entry_given)
+    write_into_file(outfile, "add-entry", args_info->add_entry_orig, cmdline_parser_add_entry_values);
+  if (args_info->eid_given)
+    write_into_file(outfile, "eid", args_info->eid_orig, 0);
+  if (args_info->rloc_given)
+    write_into_file(outfile, "rloc", args_info->rloc_orig, 0);
+  if (args_info->priority_given)
+    write_into_file(outfile, "priority", args_info->priority_orig, 0);
+  if (args_info->weight_given)
+    write_into_file(outfile, "weight", args_info->weight_orig, 0);
+  if (args_info->ttl_given)
+    write_into_file(outfile, "ttl", args_info->ttl_orig, 0);
+  if (args_info->print_given)
+    write_into_file(outfile, "print", args_info->print_orig, cmdline_parser_print_values);
+  if (args_info->filter_prefix_given)
+    write_into_file(outfile, "filter-prefix", args_info->filter_prefix_orig, 0);
+  if (args_info->list_given)
+    write_into_file(outfile, "list", args_info->list_orig, cmdline_parser_list_values);
+  if (args_info->interface_given)
+    write_into_file(outfile, "interface", args_info->interface_orig, 0);
+  
+
+  i = EXIT_SUCCESS;
+  return i;
+}
+
+int
+cmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)
+{
+  FILE *outfile;
+  int i = 0;
+
+  outfile = fopen(filename, "w");
+
+  if (!outfile)
+    {
+      fprintf (stderr, "%s: cannot open file for writing: %s\n", CMDLINE_PARSER_PACKAGE, filename);
+      return EXIT_FAILURE;
+    }
+
+  i = cmdline_parser_dump(outfile, args_info);
+  fclose (outfile);
+
+  return i;
+}
+
+void
+cmdline_parser_free (struct gengetopt_args_info *args_info)
+{
+  cmdline_parser_release (args_info);
+}
+
+/** @brief replacement of strdup, which is not standard */
+char *
+gengetopt_strdup (const char *s)
+{
+  char *result = 0;
+  if (!s)
+    return result;
+
+  result = (char*)malloc(strlen(s) + 1);
+  if (result == (char*)0)
+    return (char*)0;
+  strcpy(result, s);
+  return result;
+}
+
+int
+cmdline_parser (int argc, char **argv, struct gengetopt_args_info *args_info)
+{
+  return cmdline_parser2 (argc, argv, args_info, 0, 1, 1);
+}
+
+int
+cmdline_parser_ext (int argc, char **argv, struct gengetopt_args_info *args_info,
+                   struct cmdline_parser_params *params)
+{
+  int result;
+  result = cmdline_parser_internal (argc, argv, args_info, params, 0);
+
+  if (result == EXIT_FAILURE)
+    {
+      cmdline_parser_free (args_info);
+      exit (EXIT_FAILURE);
+    }
+  
+  return result;
+}
+
+int
+cmdline_parser2 (int argc, char **argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)
+{
+  int result;
+  struct cmdline_parser_params params;
+  
+  params.override = override;
+  params.initialize = initialize;
+  params.check_required = check_required;
+  params.check_ambiguity = 0;
+  params.print_errors = 1;
+
+  result = cmdline_parser_internal (argc, argv, args_info, &params, 0);
+
+  if (result == EXIT_FAILURE)
+    {
+      cmdline_parser_free (args_info);
+      exit (EXIT_FAILURE);
+    }
+  
+  return result;
+}
+
+int
+cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
+{
+  int result = EXIT_SUCCESS;
+
+  if (cmdline_parser_required2(args_info, prog_name, 0) > 0)
+    result = EXIT_FAILURE;
+
+  if (result == EXIT_FAILURE)
+    {
+      cmdline_parser_free (args_info);
+      exit (EXIT_FAILURE);
+    }
+  
+  return result;
+}
+
+int
+cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error)
+{
+  int error = 0;
+  FIX_UNUSED (additional_error);
+
+  /* checks for required options */
+  if (args_info->addmode_mode_counter && ! args_info->add_entry_given)
+    {
+      fprintf (stderr, "%s: '--add-entry' ('-a') option required%s\n", prog_name, (additional_error ? additional_error : ""));
+      error = 1;
+    }
+  
+  if (args_info->addmode_mode_counter && ! args_info->eid_given)
+    {
+      fprintf (stderr, "%s: '--eid' ('-e') option required%s\n", prog_name, (additional_error ? additional_error : ""));
+      error = 1;
+    }
+  
+  if (args_info->addmode_mode_counter && ! args_info->rloc_given)
+    {
+      fprintf (stderr, "%s: '--rloc' ('-r') option required%s\n", prog_name, (additional_error ? additional_error : ""));
+      error = 1;
+    }
+  
+  if (args_info->addmode_mode_counter && ! args_info->priority_given)
+    {
+      fprintf (stderr, "%s: '--priority' ('-p') option required%s\n", prog_name, (additional_error ? additional_error : ""));
+      error = 1;
+    }
+  
+  if (args_info->addmode_mode_counter && ! args_info->weight_given)
+    {
+      fprintf (stderr, "%s: '--weight' ('-w') option required%s\n", prog_name, (additional_error ? additional_error : ""));
+      error = 1;
+    }
+  
+  
+  /* checks for dependences among options */
+
+  return error;
+}
+
+
+static char *package_name = 0;
+
+/**
+ * @brief updates an option
+ * @param field the generic pointer to the field to update
+ * @param orig_field the pointer to the orig field
+ * @param field_given the pointer to the number of occurrence of this option
+ * @param prev_given the pointer to the number of occurrence already seen
+ * @param value the argument for this option (if null no arg was specified)
+ * @param possible_values the possible values for this option (if specified)
+ * @param default_value the default value (in case the option only accepts fixed values)
+ * @param arg_type the type of this option
+ * @param check_ambiguity @see cmdline_parser_params.check_ambiguity
+ * @param override @see cmdline_parser_params.override
+ * @param no_free whether to free a possible previous value
+ * @param multiple_option whether this is a multiple option
+ * @param long_opt the corresponding long option
+ * @param short_opt the corresponding short option (or '-' if none)
+ * @param additional_error possible further error specification
+ */
+static
+int update_arg(void *field, char **orig_field,
+               unsigned int *field_given, unsigned int *prev_given, 
+               char *value, const char *possible_values[],
+               const char *default_value,
+               cmdline_parser_arg_type arg_type,
+               int check_ambiguity, int override,
+               int no_free, int multiple_option,
+               const char *long_opt, char short_opt,
+               const char *additional_error)
+{
+  char *stop_char = 0;
+  const char *val = value;
+  int found;
+  char **string_field;
+  FIX_UNUSED (field);
+
+  stop_char = 0;
+  found = 0;
+
+  if (!multiple_option && prev_given && (*prev_given || (check_ambiguity && *field_given)))
+    {
+      if (short_opt != '-')
+        fprintf (stderr, "%s: `--%s' (`-%c') option given more than once%s\n", 
+               package_name, long_opt, short_opt,
+               (additional_error ? additional_error : ""));
+      else
+        fprintf (stderr, "%s: `--%s' option given more than once%s\n", 
+               package_name, long_opt,
+               (additional_error ? additional_error : ""));
+      return 1; /* failure */
+    }
+
+  if (possible_values && (found = check_possible_values((value ? value : default_value), possible_values)) < 0)
+    {
+      if (short_opt != '-')
+        fprintf (stderr, "%s: %s argument, \"%s\", for option `--%s' (`-%c')%s\n", 
+          package_name, (found == -2) ? "ambiguous" : "invalid", value, long_opt, short_opt,
+          (additional_error ? additional_error : ""));
+      else
+        fprintf (stderr, "%s: %s argument, \"%s\", for option `--%s'%s\n", 
+          package_name, (found == -2) ? "ambiguous" : "invalid", value, long_opt,
+          (additional_error ? additional_error : ""));
+      return 1; /* failure */
+    }
+    
+  if (field_given && *field_given && ! override)
+    return 0;
+  if (prev_given)
+    (*prev_given)++;
+  if (field_given)
+    (*field_given)++;
+  if (possible_values)
+    val = possible_values[found];
+
+  switch(arg_type) {
+  case ARG_INT:
+    if (val) *((int *)field) = strtol (val, &stop_char, 0);
+    break;
+  case ARG_STRING:
+    if (val) {
+      string_field = (char **)field;
+      if (!no_free && *string_field)
+        free (*string_field); /* free previous string */
+      *string_field = gengetopt_strdup (val);
+    }
+    break;
+  default:
+    break;
+  };
+
+  /* check numeric conversion */
+  switch(arg_type) {
+  case ARG_INT:
+    if (val && !(stop_char && *stop_char == '\0')) {
+      fprintf(stderr, "%s: invalid numeric value: %s\n", package_name, val);
+      return 1; /* failure */
+    }
+    break;
+  default:
+    ;
+  };
+
+  /* store the original value */
+  switch(arg_type) {
+  case ARG_NO:
+    break;
+  default:
+    if (value && orig_field) {
+      if (no_free) {
+        *orig_field = value;
+      } else {
+        if (*orig_field)
+          free (*orig_field); /* free previous string */
+        *orig_field = gengetopt_strdup (value);
+      }
+    }
+  };
+
+  return 0; /* OK */
+}
+
+
+static int check_modes(
+  int given1[], const char *options1[],
+                       int given2[], const char *options2[])
+{
+  int i = 0, j = 0, errors = 0;
+  
+  while (given1[i] >= 0) {
+    if (given1[i]) {
+      while (given2[j] >= 0) {
+        if (given2[j]) {
+          ++errors;
+          fprintf(stderr, "%s: option %s conflicts with option %s\n",
+                  package_name, options1[i], options2[j]);
+        }
+        ++j;
+      }
+    }
+    ++i;
+  }
+  
+  return errors;
+}
+
+int
+cmdline_parser_internal (
+  int argc, char **argv, struct gengetopt_args_info *args_info,
+                        struct cmdline_parser_params *params, const char *additional_error)
+{
+  int c;	/* Character of the parsed option.  */
+
+  int error = 0;
+  struct gengetopt_args_info local_args_info;
+  
+  int override;
+  int initialize;
+  int check_required;
+  int check_ambiguity;
+  
+  package_name = argv[0];
+  
+  override = params->override;
+  initialize = params->initialize;
+  check_required = params->check_required;
+  check_ambiguity = params->check_ambiguity;
+
+  if (initialize)
+    cmdline_parser_init (args_info);
+
+  cmdline_parser_init (&local_args_info);
+
+  optarg = 0;
+  optind = 0;
+  opterr = params->print_errors;
+  optopt = '?';
+
+  while (1)
+    {
+      int option_index = 0;
+
+      static struct option long_options[] = {
+        { "help",	0, NULL, 'h' },
+        { "version",	0, NULL, 'V' },
+        { "add-entry",	1, NULL, 'a' },
+        { "eid",	1, NULL, 'e' },
+        { "rloc",	1, NULL, 'r' },
+        { "priority",	1, NULL, 'p' },
+        { "weight",	1, NULL, 'w' },
+        { "ttl",	1, NULL, 't' },
+        { "print",	1, NULL, 'x' },
+        { "filter-prefix",	1, NULL, 'f' },
+        { "list",	1, NULL, 'l' },
+        { "interface",	1, NULL, 'i' },
+        { 0,  0, 0, 0 }
+      };
+
+      c = getopt_long (argc, argv, "hVa:e:r:p:w:t:x:f:l:i:", long_options, &option_index);
+
+      if (c == -1) break;	/* Exit from `while (1)' loop.  */
+
+      switch (c)
+        {
+        case 'h':	/* Print help and exit.  */
+          cmdline_parser_print_help ();
+          cmdline_parser_free (&local_args_info);
+          exit (EXIT_SUCCESS);
+
+        case 'V':	/* Print version and exit.  */
+          cmdline_parser_print_version ();
+          cmdline_parser_free (&local_args_info);
+          exit (EXIT_SUCCESS);
+
+        case 'a':	/* Add a map cache or db entry.  */
+          args_info->addmode_mode_counter += 1;
+        
+        
+          if (update_arg( (void *)&(args_info->add_entry_arg), 
+               &(args_info->add_entry_orig), &(args_info->add_entry_given),
+              &(local_args_info.add_entry_given), optarg, cmdline_parser_add_entry_values, "db", ARG_STRING,
+              check_ambiguity, override, 0, 0,
+              "add-entry", 'a',
+              additional_error))
+            goto failure;
+        
+          break;
+        case 'e':	/* EID in CIDR prefix notation <addr>/<len>.  */
+          args_info->addmode_mode_counter += 1;
+        
+        
+          if (update_arg( (void *)&(args_info->eid_arg), 
+               &(args_info->eid_orig), &(args_info->eid_given),
+              &(local_args_info.eid_given), optarg, 0, 0, ARG_STRING,
+              check_ambiguity, override, 0, 0,
+              "eid", 'e',
+              additional_error))
+            goto failure;
+        
+          break;
+        case 'r':	/* RLOC as IP Address.  */
+          args_info->addmode_mode_counter += 1;
+        
+        
+          if (update_arg( (void *)&(args_info->rloc_arg), 
+               &(args_info->rloc_orig), &(args_info->rloc_given),
+              &(local_args_info.rloc_given), optarg, 0, 0, ARG_STRING,
+              check_ambiguity, override, 0, 0,
+              "rloc", 'r',
+              additional_error))
+            goto failure;
+        
+          break;
+        case 'p':	/* priority.  */
+          args_info->addmode_mode_counter += 1;
+        
+        
+          if (update_arg( (void *)&(args_info->priority_arg), 
+               &(args_info->priority_orig), &(args_info->priority_given),
+              &(local_args_info.priority_given), optarg, 0, 0, ARG_INT,
+              check_ambiguity, override, 0, 0,
+              "priority", 'p',
+              additional_error))
+            goto failure;
+        
+          break;
+        case 'w':	/* weight.  */
+          args_info->addmode_mode_counter += 1;
+        
+        
+          if (update_arg( (void *)&(args_info->weight_arg), 
+               &(args_info->weight_orig), &(args_info->weight_given),
+              &(local_args_info.weight_given), optarg, 0, 0, ARG_INT,
+              check_ambiguity, override, 0, 0,
+              "weight", 'w',
+              additional_error))
+            goto failure;
+        
+          break;
+        case 't':	/* Time-to-live in seconds.  */
+          args_info->addmode_mode_counter += 1;
+        
+        
+          if (update_arg( (void *)&(args_info->ttl_arg), 
+               &(args_info->ttl_orig), &(args_info->ttl_given),
+              &(local_args_info.ttl_given), optarg, 0, 0, ARG_INT,
+              check_ambiguity, override, 0, 0,
+              "ttl", 't',
+              additional_error))
+            goto failure;
+        
+          break;
+        case 'x':	/* Print EID table.  */
+          args_info->printmode_mode_counter += 1;
+        
+        
+          if (update_arg( (void *)&(args_info->print_arg), 
+               &(args_info->print_orig), &(args_info->print_given),
+              &(local_args_info.print_given), optarg, cmdline_parser_print_values, "cache", ARG_STRING,
+              check_ambiguity, override, 0, 0,
+              "print", 'x',
+              additional_error))
+            goto failure;
+        
+          break;
+        case 'f':	/* EID prefix filter.  */
+          args_info->printmode_mode_counter += 1;
+        
+        
+          if (update_arg( (void *)&(args_info->filter_prefix_arg), 
+               &(args_info->filter_prefix_orig), &(args_info->filter_prefix_given),
+              &(local_args_info.filter_prefix_given), optarg, 0, 0, ARG_STRING,
+              check_ambiguity, override, 0, 0,
+              "filter-prefix", 'f',
+              additional_error))
+            goto failure;
+        
+          break;
+        case 'l':	/* List EIDs or RLOCS.  */
+          args_info->listmode_mode_counter += 1;
+        
+        
+          if (update_arg( (void *)&(args_info->list_arg), 
+               &(args_info->list_orig), &(args_info->list_given),
+              &(local_args_info.list_given), optarg, cmdline_parser_list_values, "eids", ARG_STRING,
+              check_ambiguity, override, 0, 0,
+              "list", 'l',
+              additional_error))
+            goto failure;
+        
+          break;
+        case 'i':	/* Specify a local interface as RLOC of LISP encapsulated packets.  */
+          args_info->rlocmode_mode_counter += 1;
+        
+        
+          if (update_arg( (void *)&(args_info->interface_arg), 
+               &(args_info->interface_orig), &(args_info->interface_given),
+              &(local_args_info.interface_given), optarg, 0, 0, ARG_STRING,
+              check_ambiguity, override, 0, 0,
+              "interface", 'i',
+              additional_error))
+            goto failure;
+        
+          break;
+
+        case 0:	/* Long option with no short option */
+        case '?':	/* Invalid option.  */
+          /* `getopt_long' already printed an error message.  */
+          goto failure;
+
+        default:	/* bug: option not considered.  */
+          fprintf (stderr, "%s: option unknown: %c%s\n", CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : ""));
+          abort ();
+        } /* switch */
+    } /* while */
+
+
+
+  if (args_info->addmode_mode_counter && args_info->listmode_mode_counter) {
+    int addmode_given[] = {args_info->add_entry_given, args_info->eid_given, args_info->rloc_given, args_info->priority_given, args_info->weight_given, args_info->ttl_given,  -1};
+    const char *addmode_desc[] = {"--add-entry", "--eid", "--rloc", "--priority", "--weight", "--ttl",  0};
+    int listmode_given[] = {args_info->list_given,  -1};
+    const char *listmode_desc[] = {"--list",  0};
+    error += check_modes(addmode_given, addmode_desc, listmode_given, listmode_desc);
+  }
+  if (args_info->addmode_mode_counter && args_info->printmode_mode_counter) {
+    int addmode_given[] = {args_info->add_entry_given, args_info->eid_given, args_info->rloc_given, args_info->priority_given, args_info->weight_given, args_info->ttl_given,  -1};
+    const char *addmode_desc[] = {"--add-entry", "--eid", "--rloc", "--priority", "--weight", "--ttl",  0};
+    int printmode_given[] = {args_info->print_given, args_info->filter_prefix_given,  -1};
+    const char *printmode_desc[] = {"--print", "--filter-prefix",  0};
+    error += check_modes(addmode_given, addmode_desc, printmode_given, printmode_desc);
+  }
+  if (args_info->addmode_mode_counter && args_info->rlocmode_mode_counter) {
+    int addmode_given[] = {args_info->add_entry_given, args_info->eid_given, args_info->rloc_given, args_info->priority_given, args_info->weight_given, args_info->ttl_given,  -1};
+    const char *addmode_desc[] = {"--add-entry", "--eid", "--rloc", "--priority", "--weight", "--ttl",  0};
+    int rlocmode_given[] = {args_info->interface_given,  -1};
+    const char *rlocmode_desc[] = {"--interface",  0};
+    error += check_modes(addmode_given, addmode_desc, rlocmode_given, rlocmode_desc);
+  }
+  if (args_info->listmode_mode_counter && args_info->printmode_mode_counter) {
+    int listmode_given[] = {args_info->list_given,  -1};
+    const char *listmode_desc[] = {"--list",  0};
+    int printmode_given[] = {args_info->print_given, args_info->filter_prefix_given,  -1};
+    const char *printmode_desc[] = {"--print", "--filter-prefix",  0};
+    error += check_modes(listmode_given, listmode_desc, printmode_given, printmode_desc);
+  }
+  if (args_info->listmode_mode_counter && args_info->rlocmode_mode_counter) {
+    int listmode_given[] = {args_info->list_given,  -1};
+    const char *listmode_desc[] = {"--list",  0};
+    int rlocmode_given[] = {args_info->interface_given,  -1};
+    const char *rlocmode_desc[] = {"--interface",  0};
+    error += check_modes(listmode_given, listmode_desc, rlocmode_given, rlocmode_desc);
+  }
+  if (args_info->printmode_mode_counter && args_info->rlocmode_mode_counter) {
+    int printmode_given[] = {args_info->print_given, args_info->filter_prefix_given,  -1};
+    const char *printmode_desc[] = {"--print", "--filter-prefix",  0};
+    int rlocmode_given[] = {args_info->interface_given,  -1};
+    const char *rlocmode_desc[] = {"--interface",  0};
+    error += check_modes(printmode_given, printmode_desc, rlocmode_given, rlocmode_desc);
+  }
+  
+  if (check_required)
+    {
+      error += cmdline_parser_required2 (args_info, argv[0], additional_error);
+    }
+
+  cmdline_parser_release (&local_args_info);
+
+  if ( error )
+    return (EXIT_FAILURE);
+
+  return 0;
+
+failure:
+  
+  cmdline_parser_release (&local_args_info);
+  return (EXIT_FAILURE);
+}
Index: package/lispconf/src/Makefile
===================================================================
--- package/lispconf/src/Makefile	(revision 0)
+++ package/lispconf/src/Makefile	(revision 0)
@@ -0,0 +1,15 @@
+#	Makefile for lispconf
+LIBS		+= -lm
+INC		+= ./lisp_ipc.h
+OBJS		= cmdline.o lispconf.o
+EXE		= lispconf
+
+$(EXE): $(OBJS) 
+	$(CC) $(LDFLAGS) $(LIBS) -o $@ $^
+
+%.o: %.c $(INC)
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+clean:
+	rm -f *.o $(EXE)
+
Index: package/lispconf/src/lispconf.c
===================================================================
--- package/lispconf/src/lispconf.c	(revision 0)
+++ package/lispconf/src/lispconf.c	(revision 0)
@@ -0,0 +1,975 @@
+/*
+ * lispconf.c
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Lisp user-level configuration and querying utility. Communicate
+ * with lisp kernel module using netlink socket.
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    Chris White       <chris@logicalelegance.com>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <math.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <inttypes.h>
+#include <sys/ioctl.h>
+#include <netinet/in.h>
+#include <net/if.h>
+#include <arpa/inet.h>
+#include "./lisp_ipc.h"
+#include <linux/netlink.h>
+#include "cmdline.h"
+
+const int true = 1;
+const int false = 0;
+
+/*
+ * Globally reused socket parameters
+ */
+int    sock_fd;
+struct sockaddr_nl src_addr, dst_addr;
+
+int send_command(lisp_cmd_t *cmd, int length)
+{
+    struct nlmsghdr *nlh = NULL;
+    struct iovec iov;
+    struct msghdr msg;
+    int retval;
+
+    memset(&src_addr, 0, sizeof(src_addr));
+    memset(&iov,      0, sizeof(struct iovec));
+    memset(&msg,     0, sizeof(struct msghdr));
+
+    nlh = (struct nlmsghdr *) malloc(NLMSG_SPACE(MAX_MSG_LENGTH));
+    if (!nlh) {
+        return -1;
+    }
+
+    memset(nlh,       0, sizeof(struct nlmsghdr));
+
+    /* Fill the netlink message header */
+    nlh->nlmsg_len   = length + sizeof(struct nlmsghdr);
+    nlh->nlmsg_pid   = 0;  /* To kernel */
+    nlh->nlmsg_flags = 0;
+
+    /* Fill in the netlink message payload */
+    memcpy(NLMSG_DATA(nlh), (char *)cmd, length);
+
+    iov.iov_base     = (void *)nlh;
+    iov.iov_len      = nlh->nlmsg_len;
+    msg.msg_name     = (void *)&dst_addr;
+    msg.msg_namelen  = sizeof(dst_addr);
+    msg.msg_iov      = &iov;
+    msg.msg_iovlen   = 1;
+
+    printf("Socket file descriptor: %d\n", sock_fd);
+    printf("Cmd Length: %d\n", length);
+    printf("nlh nlmsg_len: %d\n", nlh->nlmsg_len);
+    if ((retval = sendmsg(sock_fd, &msg, 0)) < 0) {
+        perror("sendmsg");
+        exit(-1);
+    }
+    //  free(nlh);
+    return retval;
+}
+
+#if 0
+/*
+ * send_map_cache_msg_v4()
+ * 
+ * Send a single EID/RLOC mapping to the kernel module for the cache.
+ * This could easily be expanded to send a list of lisp_cmd_t's
+ * to the send_cmd function for multiple entries at once.
+ * 
+ * For ipv4.
+ */
+int send_map_cache_msg_v4(uint32_t eid, uint8_t prefixlen, lisp_addr_t rloc,
+                          int rloc_afi,
+                          uint32_t priority,
+                          uint32_t weight,
+                          uint32_t ttl)
+{
+    lisp_eid_map_msg_t map_msg;
+    lisp_cmd_t        *cmd;
+    int cmd_length = sizeof(lisp_cmd_t) + sizeof(lisp_eid_map_msg_t);
+
+    cmd = (lisp_cmd_t *)malloc(cmd_length);
+    if (!cmd) {
+        return -1;
+    }
+
+    cmd->type = LispMapCacheAdd;
+    cmd->length = cmd_length;
+    memset((char *)&map_msg, 0, sizeof(lisp_eid_map_msg_t));
+    map_msg.eid_prefix.address.ip.s_addr = eid;
+    map_msg.eid_prefix_length = prefixlen;
+    map_msg.eid_afi = AF_INET;
+    memcpy(&map_msg.locator, &rloc, sizeof(lisp_addr_t));
+    map_msg.loc_afi = rloc_afi;
+    map_msg.priority = priority;
+    map_msg.weight = weight;
+    map_msg.ttl = ttl;
+    map_msg.how_learned = 0; // Static
+    memcpy(cmd->val, (char *)&map_msg, cmd->length);
+
+    return(send_command(cmd, cmd_length + sizeof(lisp_cmd_t)));
+}
+
+/*
+ * send_map_cache_msg_v6()
+ * 
+ * Send a single EID/RLOC mapping to the kernel module for the cache.
+ * This could easily be expanded to send a list of lisp_cmd_t's
+ * to the send_cmd function for multiple entries at once.
+ * 
+ * For ipv6.
+ */
+int send_map_cache_msg_v6(struct in6_addr prefix, uint8_t prefixlen, 
+                          lisp_addr_t rloc,
+                          int rloc_afi,
+                          uint32_t priority,
+                          uint32_t weight,
+                          uint32_t ttl)
+{
+    lisp_eid_map_msg_t map_msg;
+    lisp_cmd_t        *cmd;
+    int cmd_length = sizeof(lisp_cmd_t) + sizeof(lisp_eid_map_msg_t);
+
+    cmd = (lisp_cmd_t *)malloc(cmd_length);
+    if (!cmd) {
+        return -1;
+    }
+
+    cmd->type = LispMapCacheAdd;
+    cmd->length = cmd_length;
+    memset((char *)&map_msg, 0, sizeof(lisp_eid_map_msg_t));
+    memcpy(&map_msg.eid_prefix.address.ipv6, &prefix, sizeof(struct in6_addr));
+    map_msg.eid_prefix_length = prefixlen;
+    map_msg.eid_afi = AF_INET6;
+    memcpy(&map_msg.locator, &rloc, sizeof(lisp_addr_t));
+    map_msg.loc_afi = rloc_afi;
+    map_msg.priority = priority;
+    map_msg.weight = weight;
+    map_msg.ttl = ttl;
+    map_msg.how_learned = 0; // Static
+    memcpy(cmd->val, (char *)&map_msg, cmd->length);
+
+    return(send_command(cmd, cmd_length + sizeof(lisp_cmd_t)));
+}
+
+/*
+ * send_map_db_msg_v6()
+ * 
+ * Send a single EID/RLOC mapping to the kernel module for the database.
+ * This could easily be expanded to send a list of lisp_cmd_t's
+ * to the send_cmd function for multiple entries at once.
+ * 
+ * For ipv6 eid's with ipv4 or ipv6 rlocs.
+ */
+int send_map_db_msg_v6(struct in6_addr prefix, uint8_t prefixlen, 
+                       lisp_addr_t rloc,
+                       int rloc_afi,
+                       uint32_t priority,
+                       uint32_t weight)
+{
+    lisp_db_add_msg_t map_msg;
+    lisp_cmd_t        *cmd;
+    int cmd_length = sizeof(lisp_cmd_t) + sizeof(lisp_db_add_msg_t);
+
+    cmd = (lisp_cmd_t *)malloc(cmd_length);
+    if (!cmd) {
+        return -1;
+    }
+
+    cmd->type = LispDatabaseAdd;
+    cmd->length = sizeof(lisp_db_add_msg_t);
+    memset((char *)&map_msg, 0, sizeof(lisp_db_add_msg_t));
+    memcpy(&map_msg.eid_prefix.address.ipv6, &prefix, sizeof(struct in6_addr));
+    map_msg.eid_prefix_length = prefixlen;
+    map_msg.eid_prefix.afi= AF_INET6;
+    memcpy(&map_msg.locator, &rloc, sizeof(lisp_addr_t));
+    map_msg.locator.afi = rloc_afi;
+    map_msg.priority = priority;
+    map_msg.weight = weight;
+
+    memcpy(cmd->val, (char *)&map_msg, cmd->length);
+
+    return(send_command(cmd, cmd_length + sizeof(lisp_cmd_t)));
+}
+
+/*
+ * send_map_db_msg_v4()
+ * 
+ * Send a single EID/RLOC mapping to the kernel module for the database.
+ * This could easily be expanded to send a list of lisp_cmd_t's
+ * to the send_cmd function for multiple entries at once.
+ * 
+ * For v4 eid's with v4 or v6 rloc's
+ */
+int send_map_db_msg_v4(uint32_t eid, uint8_t prefixlen, lisp_addr_t rloc,
+                       int loc_afi,
+                       uint32_t priority,
+                       uint32_t weight)
+{
+    lisp_db_add_msg_t map_msg;
+    lisp_cmd_t        *cmd;
+    int cmd_length = sizeof(lisp_cmd_t) + sizeof(lisp_db_add_msg_t);
+
+    cmd = (lisp_cmd_t *)malloc(cmd_length);
+    if (!cmd) {
+        return -1;
+    }
+
+    cmd->type = LispDatabaseAdd;
+    cmd->length = sizeof(lisp_db_add_msg_t);
+    memset((char *)&map_msg, 0, sizeof(lisp_db_add_msg_t));
+    map_msg.eid_prefix.address.ip.s_addr = eid;
+    map_msg.eid_prefix_length = prefixlen;
+    map_msg.eid_prefix.afi = AF_INET;
+    memcpy(&map_msg.locator, &rloc, sizeof(lisp_addr_t));
+    map_msg.locator.afi = loc_afi;
+    map_msg.priority = priority;
+    map_msg.weight = weight;
+
+    memcpy(cmd->val, (char *)&map_msg, cmd->length);
+
+    return(send_command(cmd, cmd_length + sizeof(lisp_cmd_t)));
+}
+
+#endif
+/*
+ * format_uptime
+ *
+ * Create a string in HH:MM:ss format given a number of seconds
+ */
+void format_uptime(int seconds, char *buffer) 
+{
+    double hours = seconds / 3600.0;
+    int    wholehours = floor(hours);
+    double    frachours = hours - wholehours;
+    double minutes = frachours * 60.0;
+    int   wholemins = floor(minutes);
+    double   fracmins = minutes - wholemins;
+    int   new_seconds = fracmins * 60.0;
+
+    sprintf(buffer, "%02d:%02d:%02d", wholehours, wholemins, new_seconds);
+}
+
+/*
+ * process_print_cache_responses
+ *
+ * Wait for, receive and process responses from the kernel 
+ * to the previous cache lookup request. A string of responses
+ * to a request will be terminated by a LispOk message.
+ *
+ */
+int process_print_cache_responses(void)
+{
+    struct nlmsghdr *nlh = malloc(NLMSG_SPACE(MAX_MSG_LENGTH));
+    lisp_cmd_t *cmd;
+    lisp_cache_response_msg_t *map_msg;
+    lisp_cache_response_loc_t *tmp_loc;
+    int retval;
+    int loc_count = 0;
+    struct sockaddr_nl nladdr;
+    struct msghdr msg;
+    struct iovec iov;
+    char buf[256], buf2[256];
+    char *formatted_eid = NULL;
+    char *formatted_rloc = NULL;
+    struct timeval uptime;
+    struct timeval expiretime;
+
+    iov.iov_base    = (void *)nlh;
+    iov.iov_len     = MAX_MSG_LENGTH;
+    msg.msg_name    = (void *)&(nladdr);
+    msg.msg_namelen = sizeof(nladdr);
+    msg.msg_iov     = &iov;
+    msg.msg_iovlen  = 1;
+    
+    if (!nlh) {
+        printf("Memory allocation failure\n");
+        return -1;
+    }
+
+    printf("LISP IP Mapping Cache\n\n");
+
+    while (1) {
+        if ((retval = recvmsg(sock_fd, &msg, 0)) < 0) {
+            perror("recvmsg");
+            break;
+        }
+        cmd = NLMSG_DATA(nlh);
+        map_msg = (lisp_cache_response_msg_t *)cmd->val;
+        if (cmd->type == LispOk) {
+            break;
+        }
+        if (cmd->type == LispMapCacheLookup) {
+            switch (map_msg->eid_prefix.afi) {
+            case AF_INET:
+                if ((formatted_eid = (char *)  inet_ntop(AF_INET,
+                                                         &(map_msg->eid_prefix.address.ip.s_addr),
+                                                         buf,
+                                                         sizeof(buf))) == NULL) {
+                    perror("inet_ntop (eid)");
+                    exit(-1);
+                }
+                break;
+            case AF_INET6:
+                if ((formatted_eid = (char *)  inet_ntop(AF_INET6,
+                                                         map_msg->eid_prefix.address.ipv6.s6_addr,
+                                                         buf,
+                                                         sizeof(buf))) == NULL) {
+                    perror("inet_ntop (eid)");
+                    exit(-1);
+                }
+                break;
+            default:
+                printf("Unknown address family in response\n");
+                continue;
+                break;
+            }
+
+            printf("%s/%d, ", formatted_eid, map_msg->eid_prefix_length);
+            gettimeofday(&uptime, NULL);
+            uptime.tv_sec = uptime.tv_sec - map_msg->timestamp;
+            format_uptime(uptime.tv_sec, buf);
+            expiretime.tv_sec = (map_msg->ttl * 60) - uptime.tv_sec;
+            if (expiretime.tv_sec > 0) {
+                format_uptime(expiretime.tv_sec, buf2);
+            }
+            printf("uptime: %s, expires: %s, via ", buf, expiretime.tv_sec > 0 ? buf2 : "EXPIRED");
+
+            if (map_msg->how_learned == 0) { // static
+                printf("static\n");
+            } else {
+                printf("map-reply\n");
+            }
+
+            tmp_loc = map_msg->locators;
+            if (map_msg->num_locators) {
+                printf("       Locator     State    Priority/Weight  Data In/Out\n");
+
+                // Loop through the locators and print each
+                while (loc_count < map_msg->num_locators) {
+                    switch (tmp_loc->locator.afi) {
+                    case AF_INET:
+                        if ((formatted_rloc = (char *) inet_ntop(AF_INET,
+                                                                 &(tmp_loc->locator.address.ip.s_addr),
+                                                                 buf,
+                                                                 sizeof(buf))) == NULL) {
+                            perror("inet_ntop (rloc)");
+                            exit(-1);
+                        }
+                        break;
+                    case AF_INET6:
+                        if ((formatted_rloc = (char *) inet_ntop(AF_INET6,
+                                                                 tmp_loc->locator.address.ipv6.s6_addr,
+                                                                 buf,
+                                                                 sizeof(buf))) == NULL) {
+                            perror("inet_ntop (rloc)");
+                            exit(-1);
+                        }
+                        break;
+                    default:
+                        printf(" Unknown address family in locator");
+                        tmp_loc++;
+                        loc_count++;
+                        continue;
+                        break;
+                    }
+
+                    printf(" %15s ", formatted_rloc);
+                    printf(" %5s ", tmp_loc->state ? "Up" : "Down");
+                    printf("         %3d/%-3d ", tmp_loc->priority, tmp_loc->weight);
+                    printf("      %5d/%-5d\n", tmp_loc->data_packets_in,
+                           tmp_loc->data_packets_out);
+                    tmp_loc++;
+                    loc_count++;
+                }
+                printf("\n");
+            }
+            loc_count = 0;
+            continue;
+        } else {
+            printf("Unexpected message type from kernel %d\n", cmd->type);
+            break;
+        }
+    }
+    return 0;
+}
+
+/*
+ * process_list_responses
+ *
+ * Wait for, receive and process responses from the kernel
+ * to the previous cache list request. A string of responses
+ * to a request will be terminated by a LispOk message.
+ *
+ */
+int process_list_responses(void)
+{
+    struct nlmsghdr *nlh = malloc(NLMSG_SPACE(MAX_MSG_LENGTH));
+    lisp_cmd_t *cmd;
+    lisp_cache_address_list_t *addr_list;
+    int retval;
+    int i;
+    struct sockaddr_nl nladdr;
+    struct msghdr msg;
+    struct iovec iov;
+    char *formatted_eid;
+    char buf[256];
+
+    iov.iov_base    = (void *)nlh;
+    iov.iov_len     = MAX_MSG_LENGTH;
+    msg.msg_name    = (void *)&(nladdr);
+    msg.msg_namelen = sizeof(nladdr);
+    msg.msg_iov     = &iov;
+    msg.msg_iovlen  = 1;
+
+    if (!nlh) {
+        printf("Memory allocation failure\n");
+        return -1;
+    }
+
+    while (1) {
+        if ((retval = recvmsg(sock_fd, &msg, 0)) < 0) {
+            perror("recvmsg");
+            break;
+        }
+        cmd = NLMSG_DATA(nlh);
+        addr_list = (lisp_cache_address_list_t *)cmd->val;
+        if (cmd->type == LispOk) {
+
+            printf("List complete.\n");
+            break;
+        }
+        if ((cmd->type == LispMapCacheEIDList) ||
+            (cmd->type == LispMapCacheRLOCList)) {
+            printf("Contains: %d addresses\n", addr_list->count);
+
+            for (i = 0; i < addr_list->count; i++) {
+                switch (addr_list->addr_list[i].afi) {
+                case AF_INET:
+                    if ((formatted_eid = (char *)  inet_ntop(AF_INET,
+                                                             &(addr_list->addr_list[i].address.ip.s_addr),
+                                                             buf,
+                                                             sizeof(buf))) == NULL) {
+                        perror("inet_ntop (eid)");
+                        exit(-1);
+                    }
+                    break;
+                case AF_INET6:
+                    if ((formatted_eid = (char *)  inet_ntop(AF_INET6,
+                                                             addr_list->addr_list[i].address.ipv6.s6_addr,
+                                                             buf,
+                                                             sizeof(buf))) == NULL) {
+                        perror("inet_ntop (eid)");
+                        exit(-1);
+                    }
+                    break;
+                default:
+                    printf("Unknown AFI %d in address list entry", addr_list->addr_list[i].afi);
+                    printf("First byte of address was %d", addr_list->addr_list[i].address.ip.s_addr);
+                    break;
+                }
+                printf("%s\n", formatted_eid);
+            }
+        } else {
+            printf("Unexpected message type from kernel %d\n", cmd->type);
+            break;
+        }
+    }
+    return 0;
+}
+
+/*
+ * process_print_db_responses
+ *
+ * Wait for, receive and process responses from the kernel 
+ * to the previous database lookup request. A string of responses
+ * to a request will be terminated by a LispOk message.
+ *
+ */
+int process_print_db_responses(void)
+{
+    struct nlmsghdr *nlh = malloc(NLMSG_SPACE(MAX_MSG_LENGTH));
+    lisp_cmd_t *cmd;
+    lisp_db_response_msg_t *map_msg;
+    lisp_db_response_loc_t *tmp_loc;
+    int retval;
+    int loc_count = 0;
+    struct sockaddr_nl nladdr;
+    struct msghdr msg;
+    struct iovec iov;
+    char buf[256];
+    char *formatted_eid = NULL;
+    char *formatted_rloc = NULL;
+    struct timeval uptime;
+
+    iov.iov_base    = (void *)nlh;
+    iov.iov_len     = MAX_MSG_LENGTH;
+    msg.msg_name    = (void *)&(nladdr);
+    msg.msg_namelen = sizeof(nladdr);
+    msg.msg_iov     = &iov;
+    msg.msg_iovlen  = 1;
+    
+    if (!nlh) {
+        printf("Memory allocation failure\n");
+        return -1;
+    }
+
+    printf("LISP IP Mapping Database\n\n");
+
+    while (1) {
+        if ((retval = recvmsg(sock_fd, &msg, 0)) < 0) {
+            perror("recvmsg");
+            break;
+        }
+        cmd = NLMSG_DATA(nlh);
+        map_msg = (lisp_db_response_msg_t *) cmd->val;
+        if (cmd->type == LispOk) {
+            break;
+        }
+        if (cmd->type == LispDatabaseLookup) {
+            switch (map_msg->eid_prefix.afi) {
+            case AF_INET:
+                if ((formatted_eid = (char *)  inet_ntop(AF_INET,
+                                                         &(map_msg->eid_prefix.address.ip.s_addr),
+                                                         buf,
+                                                         sizeof(buf))) == NULL) {
+                    perror("inet_ntop (eid)");
+                    exit(-1);
+                }
+                break;
+            case AF_INET6:
+                if ((formatted_eid = (char *)  inet_ntop(AF_INET6,
+                                                         map_msg->eid_prefix.address.ipv6.s6_addr,
+                                                         buf,
+                                                         sizeof(buf))) == NULL) {
+                    perror("inet_ntop (eid)");
+                    exit(-1);
+                }
+                break;
+            default:
+                printf("Unknown address family in response\n");
+                continue;
+                break;
+            }
+
+            printf("%s/%d, ", formatted_eid, map_msg->eid_prefix_length);
+
+            tmp_loc = map_msg->locators;
+            if (map_msg->num_locators) {
+                //printf("\n  Locator    State    Priority/Weight\n");
+                printf("\n       Locator             Priority/Weight\n");
+
+                // Loop through the locators and print each
+                while (loc_count < map_msg->num_locators) {
+                    switch (tmp_loc->locator.afi) {
+                    case AF_INET:
+                        if ((formatted_rloc = (char *) inet_ntop(AF_INET,
+                                                                 &(tmp_loc->locator.address.ip.s_addr),
+                                                                 buf,
+                                                                 sizeof(buf))) == NULL) {
+                            perror("inet_ntop (rloc)");
+                            exit(-1);
+                        }
+                        break;
+                    case AF_INET6:
+                        if ((formatted_rloc = (char *) inet_ntop(AF_INET6,
+                                                                 tmp_loc->locator.address.ipv6.s6_addr,
+                                                                 buf,
+                                                                 sizeof(buf))) == NULL) {
+                            perror("inet_ntop (rloc)");
+                            exit(-1);
+                        }
+                        break;
+                    default:
+                        printf(" Unknown address family in locator");
+                        tmp_loc++; loc_count++;
+                        continue;
+                        break;
+                    }
+
+                    printf(" %15s ", formatted_rloc);
+                    //printf(" %5s ", tmp_loc->state ? "Up" : "Down");
+                    printf("               %3d/%-3d ", tmp_loc->priority, tmp_loc->weight);
+                    //printf("        %5d/%-5d\n", tmp_loc->data_packets_in,
+                    //       tmp_loc->data_packets_out);
+                    tmp_loc++;
+                    loc_count++;
+                }
+                printf("\n");
+            }
+            loc_count = 0;
+            continue;
+        } else {
+            printf("Unexpected message type from kernel %d\n", cmd->type);
+            break;
+        }
+    }
+    return 0;
+}
+
+/*
+ * send_print_command
+ *
+ * Send a request to the kernel module to print the contents
+ * of the static mapping table. If eidprefix is given, the search
+ * will list all entries as and/or more specfic that match.
+ */
+int send_print_command(struct gengetopt_args_info *args_info)
+{
+    lisp_lookup_msg_t prt_msg;
+    lisp_cmd_t        *cmd;
+    int cmd_length = sizeof(lisp_cmd_t) + sizeof(lisp_lookup_msg_t);
+    int retval;
+    lisp_addr_t eid_prefix;
+    int eid_prefix_len;
+    int eid_af;
+    char *token;
+    int cache = true;
+
+    cmd = (lisp_cmd_t *)malloc(cmd_length);
+    if (!cmd) {
+        return -1;
+    }
+
+    if (args_info->filter_prefix_given) {
+        /*
+         * Parse the EID addr/prefix length first
+         */
+
+        /*
+         * Detect address family
+         */
+        eid_af = detect_af(args_info->filter_prefix_arg);
+        eid_prefix.afi = eid_af;
+        token = strtok(args_info->filter_prefix_arg, "/");
+        if (!token) {
+            printf("Improper format for EID (x.x.x.x/p) or (xxxx:xxxx:xxxx:xxxx/p)\n");
+            exit(1);
+        }
+
+        if (eid_af == AF_INET) {
+            inet_pton(eid_af, token, &eid_prefix.address.ip);
+            token = strtok(NULL, "/");
+
+            if (!token) {
+                eid_prefix_len = 0;
+            } else {
+                eid_prefix_len = atoi(token);
+                if (eid_prefix_len > 32 || eid_prefix_len < 1) {
+                    printf("Prefix length must be between 1 and 32\n");
+                    exit(1);
+                }
+            }
+        } else {
+            inet_pton(eid_af, token, eid_prefix.address.ipv6.s6_addr);
+            token = strtok(NULL, "/");
+            if (!token) {
+                eid_prefix_len = 0;
+            } else {
+                eid_prefix_len = atoi(token);
+                if (eid_prefix_len > 128 || eid_prefix_len < 1) {
+                    printf("Prefix length must be between 1 and 128\n");
+                    exit(1);
+                }
+            }
+        }
+    }
+
+    // Lookup in the cache or the database
+    if (!strncmp(args_info->print_arg, "cache", strlen("cache"))) {
+        cmd->type = LispMapCacheLookup;
+        cache = true;
+    } else {
+        cmd->type = LispDatabaseLookup;
+        cache = false;
+    }
+
+    cmd->length = sizeof(lisp_lookup_msg_t);
+    memset((char *)&prt_msg, 0, sizeof(lisp_lookup_msg_t));
+    if (!args_info->filter_prefix_given) {
+        prt_msg.all_entries = 1;
+        prt_msg.exact_match = 0;
+    } else {
+        prt_msg.all_entries = 0;
+        prt_msg.exact_match = 0;
+        memcpy(&prt_msg.prefix, &eid_prefix, sizeof(lisp_addr_t));
+        prt_msg.prefix_length = eid_prefix_len;
+    }
+    memcpy(cmd->val, (char *)&prt_msg, sizeof(lisp_lookup_msg_t));
+
+    retval = send_command(cmd, cmd_length);
+    
+    if (cache) {
+        process_print_cache_responses();
+    } else {
+        process_print_db_responses();
+    }
+    return retval;
+}
+
+/*
+ * send_list_command
+ *
+ * Send a request to the kernel module to print the contents
+ * of the static mapping table, only including the prefixes or rlocs.
+ * This is primarily for testing the kernel interfaces, not for
+ * user debug.
+ */
+int send_list_command(struct gengetopt_args_info *args_info)
+{
+    lisp_cmd_t        *cmd;
+    int cmd_length = sizeof(lisp_cmd_t);
+    int retval;
+
+    cmd = (lisp_cmd_t *)malloc(cmd_length);
+    if (!cmd) {
+        return -1;
+    }
+
+    // List EIDs or RLOCs
+    if (!strncmp(args_info->list_arg, "eids", strlen("eids"))) {
+        printf("Current map cache EIDs:\n");
+        cmd->type = LispMapCacheEIDList;
+    } else {
+        printf("Current map cache RLOCs:\n");
+        cmd->type = LispMapCacheRLOCList;
+    }
+    cmd->length = 0;
+
+    retval = send_command(cmd, cmd_length);
+
+    process_list_responses();
+    return retval;
+}
+
+int set_rloc_interface(struct gengetopt_args_info *args_info)
+{
+    int s;
+    struct ifreq ifr;
+    lisp_set_rloc_msg_t *rloc_msg;
+    lisp_cmd_t          *cmd;
+    int cmd_length = sizeof(lisp_cmd_t) + sizeof(lisp_set_rloc_msg_t);
+    int retval;
+
+    /*
+     * Look up the given inteface in the kernel and get the ip address
+     */
+    s = socket(AF_INET, SOCK_DGRAM, 0);
+
+    /*
+     * IPV4 for now XXX
+     */
+    ifr.ifr_addr.sa_family = AF_INET;
+
+    /*
+     * Pass in the device string
+     */
+    strncpy(ifr.ifr_name, args_info->interface_arg, IFNAMSIZ - 1);
+    retval = ioctl(s, SIOCGIFADDR, &ifr);
+    close(s);
+
+    if (retval != 0) {
+        printf("Failed to find active interface %s\n", ifr.ifr_name);
+        return -1;
+    }
+
+    cmd = (lisp_cmd_t *)malloc(cmd_length);
+    if (!cmd) {
+        return -1;
+    }
+
+    cmd->type = LispSetRLOC;
+    cmd->length = sizeof(lisp_set_rloc_msg_t);
+    memset((char *)&rloc_msg, 0, sizeof(lisp_set_rloc_msg_t));
+    rloc_msg = (lisp_set_rloc_msg_t *)cmd->val;
+    rloc_msg->addr.address.ip.s_addr = ((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr;
+
+    retval = send_command(cmd, cmd_length + sizeof(lisp_cmd_t));
+
+    return retval;
+}
+
+int detect_af(char *str)
+{
+    if (!strstr(str,":")) {
+        return AF_INET;
+    }
+    return AF_INET6;
+}
+
+void add_entry(struct gengetopt_args_info *args_info)
+{
+    char *token;
+    struct in_addr  eid4;
+    struct in6_addr eid6;
+    lisp_addr_t     eid;
+    int plen;
+    struct in_addr  rloc4;
+    struct in6_addr rloc6;
+    lisp_addr_t rloc;
+    uint32_t priority;
+    uint32_t weight;
+    uint32_t ttl;
+    int      eid_af, rloc_af;
+
+    /*
+     * Parse the EID addr/prefix length first
+     */
+    
+    /*
+     * Detect address family
+     */
+    eid_af = detect_af(args_info->eid_arg);
+
+    token = strtok(args_info->eid_arg, "/");
+    if (!token) {
+        printf("Improper format for EID (x.x.x.x/p) or (xxxx:xxxx:xxxx:xxxx/p)\n");
+        exit(1);
+    }
+
+    if (eid_af == AF_INET) {
+        inet_pton(eid_af, token, &eid4);
+        token = strtok(NULL, "/");
+        plen = atoi(token);
+        if (plen > 32 || plen < 1) {
+            printf("Prefix length must be between 1 and 32\n");
+            exit(1);
+        }
+    } else {
+        inet_pton(eid_af, token, &eid6);
+        token = strtok(NULL, "/");
+        plen = atoi(token);
+        if (plen > 128 || plen < 1) {
+            printf("Prefix length must be between 1 and 128\n");
+            exit(1);
+        }
+    }
+
+    rloc_af = detect_af(args_info->rloc_arg);
+    if (rloc_af == AF_INET) {
+        inet_pton(rloc_af, args_info->rloc_arg, &rloc4);
+        rloc.address.ip.s_addr = rloc4.s_addr;
+    } else {
+        inet_pton(rloc_af, args_info->rloc_arg, &rloc6);
+        // Investigate: couldn't get memcpy to work without crashing
+        // elsewhere. XXX
+        rloc.address.ipv6.s6_addr32[0] = rloc6.s6_addr32[0];
+        rloc.address.ipv6.s6_addr32[1] = rloc6.s6_addr32[1];
+        rloc.address.ipv6.s6_addr32[2] = rloc6.s6_addr32[2];
+        rloc.address.ipv6.s6_addr32[3] = rloc6.s6_addr32[3];
+    }
+
+    // Range check these xxx
+    priority = args_info->priority_arg;
+    weight   = args_info->weight_arg;
+    ttl      = args_info->ttl_arg;
+
+    /*
+     * Cache or database
+     */
+    if (!strncmp(args_info->add_entry_arg, "cache", strlen("cache"))) {
+        if (eid_af == AF_INET) {
+            //send_map_cache_msg_v4(eid4.s_addr, plen, rloc, rloc_af, priority,
+            //                      weight, ttl);
+        } else {
+            // send_map_cache_msg_v6(eid6, plen, rloc, rloc_af, priority,
+            //                      weight, ttl);
+        }
+    } else {
+        if (eid_af == AF_INET) {
+          //  send_map_db_msg_v4(eid4.s_addr, plen, rloc, rloc_af, priority,
+          //                     weight);
+        } else {
+          //  send_map_db_msg_v6(eid6, plen, rloc, rloc_af, priority, weight);
+        }
+    }
+}
+
+int main(int argc, char **argv) 
+{
+
+    struct gengetopt_args_info args_info;
+
+    int i;
+
+    /*
+     * Parse command line options
+     */
+    if (cmdline_parser(argc, argv, &args_info) != 0) {
+        exit(1);
+    }
+    memset(&src_addr, 0, sizeof(src_addr));
+    src_addr.nl_family = AF_NETLINK;
+    src_addr.nl_pid    = getpid();  /* self pid */
+    src_addr.nl_groups = 0;  /* not in mcast groups */
+
+    memset(&dst_addr, 0, sizeof(dst_addr));
+    dst_addr.nl_family = AF_NETLINK;
+    dst_addr.nl_pid    = 0;   /* For Linux Kernel */
+    dst_addr.nl_groups = 0; /* unicast */
+
+    /*
+     * Connect to the kernel module
+     */
+    if ((sock_fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_LISP)) < 0) {
+        perror("socket");
+        exit(-1);
+    }
+    if (bind(sock_fd, (struct sockaddr *)&src_addr, sizeof(src_addr)) < 0) {
+        perror("bind: ");
+        exit(-1);
+    }
+
+    if (args_info.add_entry_given) {
+        add_entry(&args_info);
+        exit(0);
+    }
+
+    if (args_info.print_given) {
+        send_print_command(&args_info);
+        exit(0);
+    }
+
+    if (args_info.interface_given) {
+        set_rloc_interface(&args_info);
+        exit(0);
+    }
+
+    if (args_info.list_given) {
+        send_list_command(&args_info);
+        exit(0);
+    }
+    return 0;
+}
Index: package/lispconf/Makefile
===================================================================
--- package/lispconf/Makefile	(revision 0)
+++ package/lispconf/Makefile	(revision 0)
@@ -0,0 +1,46 @@
+#
+# OpenWrt LISPconf Package
+# Vasileios Lakafosis (vasileios@gatech.edu)
+#
+
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=lispconf
+PKG_RELEASE:=1
+PKG_VERSION:=0.1
+
+PKG_BUILD_DIR:=$(BUILD_DIR)/$(PKG_NAME)
+include $(INCLUDE_DIR)/package.mk
+
+define Package/$(PKG_NAME)
+  SECTION:=utils
+  CATEGORY:=Utilities
+  TITLE:=$(PKG_NAME) -- Vasileios' lispconf Application
+endef
+
+define Package/$(PKG_NAME)/default
+  URL:=http://lisp.cisco.com/
+endef
+
+define Package/$(PKG_NAME)
+  SECTION:=utils
+  CATEGORY:=Utilities
+  TITLE:=$(PKG_NAME) -- Vasileios' lispconf Application
+  $(call Package/$(PKG_NAME)/default)
+endef
+
+define Package/$(PKG_NAME)/description
+Run with "-x cache" to see cache map.
+endef
+
+define Build/Prepare
+	mkdir -p $(PKG_BUILD_DIR)
+	$(CP) ./src/* $(PKG_BUILD_DIR)/
+endef
+
+define Package/$(PKG_NAME)/install
+	$(INSTALL_DIR) $(1)/usr/sbin/lisp
+	$(INSTALL_BIN) $(PKG_BUILD_DIR)/$(PKG_NAME) $(1)/usr/sbin/lisp
+endef
+
+$(eval $(call BuildPackage,$(PKG_NAME)))
Index: package/lisp_int/src/lisp_int.c
===================================================================
--- package/lisp_int/src/lisp_int.c	(revision 0)
+++ package/lisp_int/src/lisp_int.c	(revision 0)
@@ -0,0 +1,165 @@
+/*
+ * lisp_int.c
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * This is the LISP MN EID Interface module.
+ * This module creates an "ethernet-like" interface
+ * and registers the interface with the kernel 
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+#include "lisp_int.h"
+#include <linux/string.h>
+
+//vlakafos
+//#define DEBUG
+
+struct net_device   *lispint_dev;
+struct lispint_priv {
+    struct net_device_stats stats;
+};
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Logical Inerface for LISP");
+
+int lispint_open (struct net_device *dev)
+{
+    netif_start_queue(dev);
+    return 0;
+}
+
+int lispint_stop (struct net_device *dev)
+{
+    netif_stop_queue(dev);
+    return 0;
+}
+
+static netdev_tx_t lispint_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+
+        dev->stats.tx_packets++;
+        dev->stats.tx_bytes += skb->len;
+
+        dev_kfree_skb(skb);
+#ifdef DEBUG
+        printk(KERN_INFO "lisp_int: from xmit(): skb freed\n");
+#endif
+        return NETDEV_TX_OK;
+
+}
+
+static const struct net_device_ops    lispint_device_ops = {
+
+    .ndo_open   =   lispint_open,
+    .ndo_stop   =   lispint_stop,
+    .ndo_start_xmit =   lispint_xmit,
+
+};
+
+static void lispint_setup(struct net_device *dev)
+{
+    struct lispint_priv *priv;
+
+    /* Initialize dev structure */
+    ether_setup(dev);
+
+    dev->netdev_ops     =   &lispint_device_ops;
+    dev->flags          |=  IFF_NOARP;
+
+    priv   =   netdev_priv(dev);
+    memset(priv, 0 , sizeof(struct lispint_priv));
+
+}
+static void __exit lispint_cleanup (void) {
+
+    unregister_netdev(lispint_dev);
+    printk(KERN_INFO "lisp_int: LISP interface unregistered");
+
+    free_netdev(lispint_dev);
+
+}
+
+static int __init lispint_init(void)
+{
+    int err = 0;
+
+    printk(KERN_INFO "lisp_int initialization");
+
+    lispint_dev = alloc_netdev(sizeof(struct lispint_priv), "lmn%d", lispint_setup);
+    if (!lispint_dev) {
+        printk(KERN_INFO "lisp_int: No memory");
+        return -ENOMEM;
+    }
+
+    /*
+     * Register device with kernel
+     */
+    err = register_netdev(lispint_dev);
+
+    if (err < 0) {
+        printk(KERN_INFO "lisp_int: device registration failed");
+        free_netdev(lispint_dev);
+        return err;
+    }
+
+    printk(KERN_INFO "lisp_int: LISP interface registered");
+
+    return 0;
+
+}
+
+/*
+ * Module initialization
+ */
+
+/*
+ * lispint_init_module()
+ *
+ * Main entry point for the module, performs all sub-initialization
+ */
+static int __init lispint_init_module (void)
+{
+  int result = 0;
+
+  printk(KERN_INFO "lispint init module...\n");
+  result    =   lispint_init();
+  return result;
+}
+
+/*
+ * lispint_exit_module()
+ *
+ * Cleanup routine, called when module is removed from the
+ * kernel.
+ */
+static void __exit lispint_exit_module (void)
+{
+
+  printk(KERN_INFO "lispint module cleaning up...\n");
+  lispint_cleanup();
+}
+
+module_init(lispint_init_module);
+module_exit(lispint_exit_module);
Index: package/lisp_int/src/LICENSE
===================================================================
--- package/lisp_int/src/LICENSE	(revision 0)
+++ package/lisp_int/src/LICENSE	(revision 0)
@@ -0,0 +1,341 @@
+  GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+               51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) 19yy  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) 19yy name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
Index: package/lisp_int/src/lisp_int.h
===================================================================
--- package/lisp_int/src/lisp_int.h	(revision 0)
+++ package/lisp_int/src/lisp_int.h	(revision 0)
@@ -0,0 +1,38 @@
+/*
+ * lisp_int.h
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Header includes for lisp_int module
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+
+#pragma once
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <net/net_namespace.h>
+#include <linux/if_arp.h>
Index: package/lisp_int/src/Makefile
===================================================================
--- package/lisp_int/src/Makefile	(revision 0)
+++ package/lisp_int/src/Makefile	(revision 0)
@@ -0,0 +1,9 @@
+EXTRA_CFLAGS += -Wno-strict-prototypes
+obj-m += lisp_int.o
+lispint-objs += lisp_int.o
+
+#all:
+#
+#.PHONY: clean
+#clean:
+#	rm -f *.o
Index: package/lisp_int/Makefile
===================================================================
--- package/lisp_int/Makefile	(revision 0)
+++ package/lisp_int/Makefile	(revision 0)
@@ -0,0 +1,49 @@
+#
+# OpenWrt LISP_int Package
+# Vasileios Lakafosis (vasileios@gatech.edu)
+#
+
+include $(TOPDIR)/rules.mk
+include $(INCLUDE_DIR)/kernel.mk
+
+PKG_NAME:=lisp_int
+PKG_RELEASE:=1
+PKG_VERSION:=0.1
+
+PKG_BUILD_DIR:=$(KERNEL_BUILD_DIR)/$(PKG_NAME)
+include $(INCLUDE_DIR)/package.mk
+
+define KernelPackage/$(PKG_NAME)
+  SUBMENU:=Network Support
+  TITLE:=LISP Virtual Interface support
+  URL:=http://lisp.cisco.com/
+  FILES:=$(PKG_BUILD_DIR)/$(PKG_NAME).$(LINUX_KMOD_SUFFIX)
+  AUTOLOAD:=$(call AutoLoad,50,$(PKG_NAME))
+endef
+
+define KernelPackage/$(PKG_NAME)/description
+ This package contains a virtual interface driver by Vasileios.
+endef
+
+define Build/Prepare
+	mkdir -p $(PKG_BUILD_DIR)
+	$(CP) -r ./src/* $(PKG_BUILD_DIR)/
+endef
+
+define Build/Compile
+	$(MAKE) -C "$(LINUX_DIR)" \
+		ARCH="$(LINUX_KARCH)" \
+		CROSS_COMPILE="$(TARGET_CROSS)" \
+		SUBDIRS="$(PKG_BUILD_DIR)" \
+		M="$(PKG_BUILD_DIR)" \
+		V="$(V)" \
+		modules
+endef
+
+
+define KernelPackage/$(PKG_NAME)/install
+	$(INSTALL_DIR) $(1)/usr/sbin
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/*.ko $(1)/usr/sbin
+endef
+
+$(eval $(call KernelPackage,$(PKG_NAME)))
Index: package/lisp_mod/src/packettypes.h
===================================================================
--- package/lisp_mod/src/packettypes.h	(revision 0)
+++ package/lisp_mod/src/packettypes.h	(revision 0)
@@ -0,0 +1,58 @@
+/*
+ * packettypes.h
+ *
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Header definitions for LISP control
+ * and encapsulation packets.
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    Chris White       <chris@logicalelegance.com>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+#pragma once
+
+#define LISP_ENCAP_PORT 4341
+#define LISP_CONTROL_PORT 4342
+
+typedef struct lisphdr { 
+#ifdef __LITTLE_ENDIAN_BITFIELD
+    uint8_t rflags:3;
+    uint8_t instance_id:1;
+    uint8_t map_version:1;
+    uint8_t echo_nonce:1;
+    uint8_t lsb:1;
+    uint8_t nonce_present:1;
+#else
+  uint8_t nonce_present:1;
+  uint8_t lsb:1;
+  uint8_t echo_nonce:1;
+  uint8_t map_version:1;
+  uint8_t instance_id:1;
+  uint8_t rflags:3;
+#endif
+  uint8_t nonce[3];
+  uint32_t lsb_bits;
+} lisphdr_t;
+
Index: package/lisp_mod/src/LICENSE
===================================================================
--- package/lisp_mod/src/LICENSE	(revision 0)
+++ package/lisp_mod/src/LICENSE	(revision 0)
@@ -0,0 +1,341 @@
+  GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+               51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) 19yy  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) 19yy name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
Index: package/lisp_mod/src/lisp_ipc.c
===================================================================
--- package/lisp_mod/src/lisp_ipc.c	(revision 0)
+++ package/lisp_mod/src/lisp_ipc.c	(revision 0)
@@ -0,0 +1,1075 @@
+/*
+ * lisp_ipc.c
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Implements message handling functions for communication
+ * between the kerenl and user-level processes.
+ *
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    Chris White       <chris@logicalelegance.com>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+#include "lisp_mod.h"
+#include "tables.h"
+
+/*
+ * Import symbols
+ */
+extern lisp_globals globals;
+extern spinlock_t table_lock;
+
+/*
+ * Command types
+ */
+typedef void(*ipc_handler)(lisp_cmd_t *cmd, int pid);
+
+struct ipc_handler_struct {
+    const char    *description;
+    ipc_handler    handler;
+};
+
+/*
+ * Command table for IPC messages. This must
+ * match the contents and order of the lisp_msgtype_e
+ * enum defined in the header.
+ */
+const struct ipc_handler_struct ipc_table[] = {
+    { "Ok", handle_no_action },
+    { "Failed", handle_no_action },
+    { "Map Cache Lookup", handle_map_cache_lookup },
+    { "Map Cache EID List", handle_map_cache_list_request },
+    { "Map Cache RLOC List", handle_map_cache_list_request },
+    { "Database Lookup", handle_map_db_lookup },
+    { "Cache Sample", handle_cache_sample },
+    { "Set RLOC", handle_set_rloc },
+    { "Add Map Cache Entry", handle_map_cache_add },
+    { "Delete Map Cache", handle_no_action },
+    { "Map Cache Clear", clear_map_cache },
+    { "Add Database Entry", handle_map_db_add },
+    { "Delete Database Entry", handle_map_db_delete },
+    { "Register Daemon", handle_daemon_register },
+    { "Start Traffic Monitor", handle_traffic_mon_start },
+    { "Set UDP Ports", handle_set_udp_ports }
+};
+
+/*
+ * dump_message()
+ * 
+ * Debug facility to print the contents of a message as
+ * as series of hexadecimal 32-bit words.
+ * 
+ * Length is in bytes.
+ */
+void dump_message(char *msg, int length)
+{
+  int words = length / sizeof(uint32_t);
+  int i;
+
+  printk(KERN_INFO "Lisp message dump:\n");
+  for (i = 0; i < words; i++) { 
+      printk(KERN_INFO "%08x: %02x %02x %02x %02x\n", i,  *msg,*(msg + 1), *(msg + 2), *(msg + 3));
+      msg = msg + 4;
+  }
+}
+
+int send_message(lisp_cmd_t *cmd, int length)
+{
+    return 0;
+}
+
+/*
+ * send_command_complete_msg()
+ *
+ * Send a message to user-level client that the previous
+ * command is complete.
+ */
+int send_command_complete_msg(int dstpid)
+{
+  struct nlmsghdr *nlh;
+  lisp_cmd_t *cmd;
+  /* PN
+   * GFP_ATOMIC vs. GFP_KERNEL
+   */
+  //vlakafos
+  struct sk_buff *skb = alloc_skb(NLMSG_SPACE(MAX_MSG_LENGTH), GFP_KERNEL);
+  //struct sk_buff *skb = alloc_skb(NLMSG_SPACE(MAX_MSG_LENGTH), GFP_ATOMIC);
+ 
+  if (!skb) {
+    printk(KERN_INFO "Unable to allocate skb for response.\n");
+    return -1;
+  }
+  nlh = (struct nlmsghdr *) skb_put(skb, NLMSG_SPACE(MAX_MSG_LENGTH));
+  nlh->nlmsg_len            = NLMSG_SPACE(MAX_MSG_LENGTH);
+  NETLINK_CB(skb).pid       = 0;    /* from kernel */
+  NETLINK_CB(skb).dst_group = 0;    /* unicast */
+  cmd                       = NLMSG_DATA(nlh);
+  cmd->type                 = LispOk;
+  cmd->length               = 0;
+
+  netlink_unicast(globals.nl_socket, skb, dstpid, MSG_DONTWAIT);
+  return 0;
+}
+
+/*
+ * send_cache_miss_notification()
+ *
+ * Send a message to the registered lispd (if any)
+ * that an EID lookup has failed in the forwarding
+ * path.
+ */
+void send_cache_miss_notification(lisp_addr_t addr, short af)
+{
+  struct nlmsghdr *nlh;
+  lisp_cmd_t *cmd;
+  struct sk_buff *skb;
+  lisp_cache_sample_msg_t *msg;
+  int err;
+
+  if (!globals.daemonPID) {
+    printk(KERN_INFO "  No lispd process has registered, notification aborted.\n");
+    return;
+  } else {
+    if (af == AF_INET) {
+      printk(KERN_INFO "  Sending notification to %d for EID %pI4\n", globals.daemonPID, &addr.address.ip.s_addr);
+    } else if (af == AF_INET6) {
+      printk(KERN_INFO "  Sending notification to %d for EID %pI6\n", globals.daemonPID, addr.address.ipv6.s6_addr);
+    }
+  }
+
+  /*
+   * This operation CAN fail (because GFP_ATOMIC tries to allocate
+   * memory quickly without much thought). If it does, we'll try again
+   * on the next packet.
+   */
+  skb = alloc_skb(NLMSG_SPACE(MAX_MSG_LENGTH), GFP_ATOMIC);
+  
+  if (!skb) {
+    printk(KERN_INFO "Unable to allocate skb for notification.\n");
+    return;
+  }
+  nlh = (struct nlmsghdr *) skb_put(skb, NLMSG_SPACE(MAX_MSG_LENGTH));
+  nlh->nlmsg_len            = NLMSG_SPACE(MAX_MSG_LENGTH);
+  NETLINK_CB(skb).pid       = 0;    /* from kernel */
+  NETLINK_CB(skb).dst_group = 0;    /* unicast */
+  cmd                       = NLMSG_DATA(nlh);
+  cmd->type                 = LispCacheSample;
+  cmd->length               = sizeof(lisp_cache_sample_msg_t);
+
+  msg = (lisp_cache_sample_msg_t *)cmd->val;
+  msg->reason = CacheMiss;
+  if (af == AF_INET) {
+    msg->eid.address.ip.s_addr = addr.address.ip.s_addr;
+    msg->eid.afi = af;
+  } else if (af == AF_INET6) {
+    memcpy(msg->eid.address.ipv6.s6_addr, addr.address.ipv6.s6_addr,
+	   sizeof(lisp_addr_t));
+    msg->eid.afi = af;
+  }
+  msg->num_locators = 0; // Cache miss message, EID only
+  err = netlink_unicast(globals.nl_socket, skb, globals.daemonPID, 
+			MSG_DONTWAIT);
+  if (err < 0) {
+    printk(KERN_INFO "Error sending to lispd. Clearing PID.\n");
+    globals.daemonPID = 0;
+  }
+  return;
+}
+
+/*
+ * send_cache_sample_notification()
+ *
+ * Send a message to the registered lispd with details
+ * of the given eid cache entry. Primarily intended
+ * for RLOC-probing. TBD: Check if all locators should be included
+ * for SMR'ing.
+ */
+void send_cache_sample_notification(lisp_map_cache_t *entry, sample_reason_e reason)
+{
+  struct nlmsghdr *nlh;
+  lisp_cmd_t *cmd;
+  struct sk_buff *skb;
+  lisp_cache_sample_msg_t *msg;
+  lisp_map_cache_loc_t *loc;
+  int i;
+  int err;
+
+  if (!globals.daemonPID) {
+    printk(KERN_INFO "  No lispd process has registered, sample notification aborted.\n");
+    return;
+  } else {
+    if (entry->eid_prefix.afi == AF_INET) {
+      printk(KERN_INFO "  Sending sample to %d for EID %pI4\n", globals.daemonPID, &entry->eid_prefix.address.ip.s_addr);
+    } else if (entry->eid_prefix.afi == AF_INET6) {
+      printk(KERN_INFO "  Sending sample to %d for EID %pI6\n", globals.daemonPID, &entry->eid_prefix.address.ipv6.s6_addr);
+    }
+  }
+
+  /*
+   * This operation CAN fail (because GFP_ATOMIC tries to allocate
+   * memory quickly without much thought). If it does, we'll try again
+   * on the next packet.
+   */
+  skb = alloc_skb(NLMSG_SPACE(MAX_MSG_LENGTH), GFP_ATOMIC);
+
+  if (!skb) {
+    printk(KERN_INFO "Unable to allocate skb for notification.\n");
+    return;
+  }
+  nlh = (struct nlmsghdr *) skb_put(skb, NLMSG_SPACE(MAX_MSG_LENGTH));
+  nlh->nlmsg_len            = NLMSG_SPACE(MAX_MSG_LENGTH);
+  NETLINK_CB(skb).pid       = 0;    /* from kernel */
+  NETLINK_CB(skb).dst_group = 0;    /* unicast */
+  cmd                       = NLMSG_DATA(nlh);
+  cmd->type                 = LispCacheSample;
+  cmd->length               = sizeof(lisp_cache_sample_msg_t) + sizeof(lisp_addr_t) * entry->count;
+
+  msg = (lisp_cache_sample_msg_t *)cmd->val;
+  msg->reason = reason;
+  msg->eid_prefix_length = entry->eid_prefix_length;
+
+  msg->eid.afi = entry->eid_prefix.afi;
+  memcpy(&msg->eid.address, &entry->eid_prefix.address, sizeof(lisp_addr_t));
+
+  msg->num_locators = entry->count;
+
+  /*
+   * Populate the locators
+   */
+  for (i = 0; i < entry->count; i++) {
+    loc = entry->locator_list[i];
+
+    memcpy(&msg->locators[i].address,
+           &loc->locator.address,
+           sizeof(lisp_addr_t));
+
+    msg->locators[i].afi = loc->locator.afi;
+  }
+
+  err = netlink_unicast(globals.nl_socket, skb, globals.daemonPID,
+                        MSG_DONTWAIT);
+  if (err < 0) {
+    printk(KERN_INFO "Error sending to lispd. Clearing PID.\n");
+    globals.daemonPID = 0;
+  }
+  return;
+}
+
+/*
+ * send_cache_lookup_response_msg()
+ *
+ * Send a response message to user-level clients for
+ * a cache lookup.
+ */
+int send_cache_lookup_response_msg(lisp_map_cache_t *entry, int dstpid)
+{
+  struct nlmsghdr       *nlh;
+  lisp_cmd_t            *cmd;
+  /* PN
+   * GFP_ATOMIC vs. GFP_KERNEL
+   */
+  //vlakafos
+  struct sk_buff        *skb = alloc_skb(NLMSG_SPACE(MAX_MSG_LENGTH), GFP_KERNEL);
+  //struct sk_buff        *skb = alloc_skb(NLMSG_SPACE(MAX_MSG_LENGTH), GFP_ATOMIC);
+  int                        max_locators;
+  lisp_cache_response_loc_t *tmp_loc;
+  lisp_map_cache_loc_t      *locator;
+  int                        loc_count = 0, err = 0;
+  lisp_cache_response_msg_t *map_msg;
+
+  if (!skb) {
+    printk(KERN_INFO "Unable to allocate skb for response.\n");
+    return -1;
+  }
+
+  max_locators = (MAX_MSG_LENGTH - sizeof(lisp_cache_response_msg_t)) /
+    sizeof(lisp_cache_response_loc_t);
+
+  // Instead of just pointing to skb data, must do a put()
+  nlh = (struct nlmsghdr *) skb_put(skb, NLMSG_SPACE(MAX_MSG_LENGTH));
+  NETLINK_CB(skb).pid       = 0;      /* from kernel */
+  NETLINK_CB(skb).dst_group = 0;  /* unicast */
+  
+  nlh->nlmsg_len            = NLMSG_SPACE(MAX_MSG_LENGTH);
+  cmd                       = NLMSG_DATA(nlh);
+  cmd->type                 = LispMapCacheLookup;
+  cmd->length               = sizeof(lisp_eid_map_msg_t); // XXX reflect locators
+  map_msg  = (lisp_cache_response_msg_t *)cmd->val;
+  
+  memcpy(&map_msg->eid_prefix, &entry->eid_prefix,
+     sizeof(lisp_addr_t));
+  map_msg->eid_prefix_length = entry->eid_prefix_length;
+  map_msg->ttl         = entry->ttl;
+  map_msg->how_learned = entry->how_learned;
+  map_msg->nonce0      = entry->nonce0;
+  map_msg->nonce1      = entry->nonce1;
+  map_msg->lsb         = entry->lsb;
+  map_msg->timestamp   = entry->timestamp;
+  map_msg->control_packets_in  = entry->control_packets_in;
+  map_msg->control_packets_out = entry->control_packets_out;
+
+  /*
+   * Walk the locator list and fill in the locator entries.
+   */
+  for (loc_count = 0; loc_count < entry->count; loc_count++) {
+      tmp_loc = map_msg->locators + loc_count;
+      locator = entry->locator_list[loc_count];
+      if (locator) {
+          memcpy(&tmp_loc->locator, &locator->locator, sizeof(lisp_addr_t));
+          tmp_loc->priority = locator->priority;
+          tmp_loc->weight = locator->weight;
+          tmp_loc->mpriority = locator->mpriority;
+          tmp_loc->mweight = locator->mweight;
+          tmp_loc->reachability_alg = locator->reachability_alg;
+          tmp_loc->state = locator->state;
+          tmp_loc->data_packets_in = locator->data_packets_in;
+          tmp_loc->data_packets_out = locator->data_packets_out;
+      }
+  }
+  map_msg->num_locators = entry->count;
+  printk(KERN_INFO " Added %d locators\n", entry->count);
+  printk(KERN_INFO " Sending response to %d\n", dstpid);
+
+  err =  netlink_unicast(globals.nl_socket, skb, dstpid, MSG_DONTWAIT);
+  printk(KERN_INFO " netlink_unicast() returned %d\n", err);
+  return 0;
+}
+
+/*
+ * send_db_lookup_response_msg()
+ *
+ * Send a response message to user-level clients for
+ * a cache lookup.
+ */
+int send_db_lookup_response_msg(lisp_database_entry_t *entry, int dstpid)
+{
+  struct nlmsghdr       *nlh;
+  lisp_cmd_t                *cmd;
+  /* PN
+   * GFP_ATOMIC vs. GFP_KERNEL
+   */
+  //vlakafos
+  struct sk_buff        *skb = alloc_skb(NLMSG_SPACE(MAX_MSG_LENGTH), GFP_KERNEL);
+  //struct sk_buff        *skb = alloc_skb(NLMSG_SPACE(MAX_MSG_LENGTH), GFP_ATOMIC);
+  int                    err;
+  int                        max_locators;
+  lisp_database_loc_t       *locator;
+  lisp_db_response_loc_t    *tmp_loc;
+  int                        loc_count = 0;
+  lisp_db_response_msg_t    *map_msg;
+
+  if (!skb) {
+    printk(KERN_INFO "Unable to allocate skb for response.\n");
+    return -1;
+  }
+
+  max_locators = (MAX_MSG_LENGTH - sizeof(lisp_db_response_msg_t)) /
+    sizeof(lisp_db_response_loc_t);
+
+  // Instead of just pointing to skb data, must do a put()
+  nlh = (struct nlmsghdr *) skb_put(skb, NLMSG_SPACE(MAX_MSG_LENGTH));
+  NETLINK_CB(skb).pid       = 0;      /* from kernel */
+  NETLINK_CB(skb).dst_group = 0;  /* unicast */
+  
+  nlh->nlmsg_len            = NLMSG_SPACE(MAX_MSG_LENGTH);
+  cmd                       = NLMSG_DATA(nlh);
+  cmd->type                 = LispDatabaseLookup;
+  cmd->length               = sizeof(lisp_eid_map_msg_t);
+  map_msg  = (lisp_db_response_msg_t *)cmd->val;
+  
+  memcpy(&map_msg->eid_prefix, &entry->eid_prefix,
+     sizeof(lisp_addr_t));
+  map_msg->eid_prefix_length = entry->eid_prefix_length;
+  map_msg->lsb = entry->lsb;
+
+  /*
+   * Walk the locator list and fill in the locator entries.
+   */
+  for (loc_count = 0; loc_count < entry->count; loc_count++) {
+      tmp_loc = map_msg->locators + loc_count;
+      locator = entry->locator_list[loc_count];
+      if (locator) {
+          memcpy(&tmp_loc->locator, &locator->locator, sizeof(lisp_addr_t));
+          tmp_loc->priority = locator->priority;
+          tmp_loc->weight = locator->weight;
+          tmp_loc->mpriority = locator->mpriority;
+          tmp_loc->mweight = locator->mweight;
+      }
+  }
+  map_msg->num_locators = entry->count;
+
+  printk(KERN_INFO " Added %d locators\n", loc_count);
+  printk(KERN_INFO " Sending response to %d\n", dstpid);
+
+  err =  netlink_unicast(globals.nl_socket, skb, dstpid, MSG_DONTWAIT);
+  printk(KERN_INFO " netlink_unicast() returned %d\n", err);
+  return 0;
+}
+
+/*
+ * handle_map_cache_lookup()
+ *
+ * Process a cache lookup request message from user-level
+ */
+void handle_map_cache_lookup(lisp_cmd_t *cmd, int pid)
+{
+  patricia_node_t *node;
+  lisp_map_cache_t *map_entry = NULL;
+  lisp_lookup_msg_t *lu_msg = (lisp_lookup_msg_t *)cmd->val;
+
+  spin_lock_bh(&table_lock);
+
+  /*
+   * Exact match request? Do the lookup and send a single
+   * response
+   */
+  if (!lu_msg->all_entries) {
+      switch (lu_msg->prefix.afi) {
+            case AF_INET:
+                 if (lu_msg->exact_match) {
+                     lookup_eid_cache_v4_exact(lu_msg->prefix.address.ip.s_addr,
+                                               lu_msg->prefix_length,
+                                               &map_entry);
+                 } else {
+                     lookup_eid_cache_v4(lu_msg->prefix.address.ip.s_addr, &map_entry);
+                 }
+                 break;
+           case AF_INET6:
+                if (lu_msg->exact_match) {
+                    lookup_eid_cache_v6_exact(lu_msg->prefix,
+                                              lu_msg->prefix_length,
+                                              &map_entry);
+                } else {
+                    lookup_eid_cache_v6(lu_msg->prefix, &map_entry);
+                }
+                break;
+      }
+      if (map_entry != NULL) {
+          send_cache_lookup_response_msg(map_entry, pid);
+      }
+  } else {
+
+      /*
+       * Walk the cache patricia trie and send a message back
+       * for each entry.
+       */
+      PATRICIA_WALK(AF4_eid_cache->head, node) {
+          map_entry = node->data;
+          printk(KERN_INFO "at node %pi4/%d @0x%x\n",
+                 &(node->prefix->add.sin.s_addr),
+                 node->prefix->bitlen,
+                 (unsigned) map_entry);
+          if (map_entry)
+              send_cache_lookup_response_msg(map_entry, pid);
+      } PATRICIA_WALK_END;
+
+      PATRICIA_WALK(AF6_eid_cache->head, node) {
+          map_entry = node->data;
+          printk(KERN_INFO "at node %pi6/%d @0x%x\n",
+                 node->prefix->add.sin6.s6_addr,
+                 node->prefix->bitlen,
+                 (unsigned) map_entry);
+          if (map_entry)
+              send_cache_lookup_response_msg(map_entry, pid);
+      } PATRICIA_WALK_END;
+  }
+  spin_unlock_bh(&table_lock);
+
+  /*
+   * Notify the client that the walk is complete
+   */
+  send_command_complete_msg(pid);
+}
+
+/*
+ * allocate_nl_buffer()
+ *
+ * Allocate a new skb and form a netlink hdr around it.
+ * Return a pointer to the skb and modify the passed in
+ * pointer to refer to the user data area.
+ */
+ struct sk_buff *allocate_nl_buffer(lisp_cmd_t **cmd, lisp_msgtype_e type, int len)
+ {
+     struct sk_buff *skb = alloc_skb(NLMSG_SPACE(MAX_MSG_LENGTH), GFP_ATOMIC);
+     struct nlmsghdr *nlh;
+
+     if (!skb) {
+        printk(KERN_INFO "Failed to allocate skb for %s message", ipc_table[type].description);
+        return NULL;
+     }
+     nlh = (struct nlmsghdr *) skb_put(skb, NLMSG_SPACE(MAX_MSG_LENGTH));
+     nlh->nlmsg_len            = NLMSG_SPACE(MAX_MSG_LENGTH);
+     NETLINK_CB(skb).pid       = 0;    /* from kernel */
+     NETLINK_CB(skb).dst_group = 0;    /* unicast */
+     *cmd                       = NLMSG_DATA(nlh);
+     (*cmd)->type                 = type;
+     (*cmd)->length               = len;
+
+     return (skb);
+ }
+
+ /*
+  * build_eid_list_entry()
+  *
+  * Place a single eid address in the eid list for a message
+  */
+ bool build_eid_list_entry(int *count, struct sk_buff **skb, int dstpid, lisp_cmd_t **cmd,
+                           lisp_addr_t *addr)
+ {
+     int err;
+     int max_entries = (MAX_MSG_LENGTH - (sizeof(lisp_cmd_t) + sizeof(lisp_cache_address_list_t))) /
+                                                 sizeof(lisp_addr_t);
+     lisp_cache_address_list_t *eidlist = (lisp_cache_address_list_t *)(*cmd)->val;
+
+     if (*count == max_entries) {
+         printk("Entries exceeds single message size, sending current and building new");
+         (*cmd)->length = sizeof(lisp_cache_address_list_t) + sizeof(lisp_addr_t) * (*count);
+         eidlist->count = *count;
+         err = netlink_unicast(globals.nl_socket, *skb, dstpid, MSG_DONTWAIT);
+         if (err < 0) {
+             printk(KERN_INFO "Error sending to lispd. Clearing PID.\n");
+             globals.daemonPID = 0;
+             return false;
+         }
+
+         /* Grab a new buffer */
+         *count = 0;
+         *skb = allocate_nl_buffer(cmd, LispMapCacheEIDList, 0); // Set length later
+         if (!*skb) {
+             return false; // Client can retry on schedule.
+         }
+         eidlist = (lisp_cache_address_list_t *)(*cmd)->val;
+     }
+     (*count)++;
+     memcpy(&eidlist->addr_list[*count - 1], addr,
+            sizeof(lisp_addr_t));
+     return true;
+ }
+
+ /*
+  * build_rloc_list_entry()
+  *
+  * Place a single rloc address in the list for a message
+  */
+ bool build_rloc_list_entry(int *count, struct sk_buff **skb, int dstpid, lisp_cmd_t **cmd,
+                            lisp_map_cache_t *entry)
+ {
+     int err;
+     int i;
+     int max_entries = (MAX_MSG_LENGTH - (sizeof(lisp_cmd_t) + sizeof(lisp_cache_address_list_t))) /
+                                                 sizeof(lisp_addr_t);
+     lisp_cache_address_list_t *rloclist = (lisp_cache_address_list_t *)(*cmd)->val;
+
+     for (i = 0; i < entry->count; i++) {
+         if (*count == max_entries) {
+             printk("Entries exceeds single message size, sending current and building new");
+             (*cmd)->length = sizeof(lisp_cache_address_list_t) + sizeof(lisp_addr_t) * (*count);
+             rloclist->count = *count;
+             err = netlink_unicast(globals.nl_socket, *skb, dstpid, MSG_DONTWAIT);
+             if (err < 0) {
+                 printk(KERN_INFO "Error sending to lispd. Clearing PID.\n");
+                 globals.daemonPID = 0;
+                 return false;
+             }
+
+             /* Grab a new buffer */
+             *count = 0;
+             *skb = allocate_nl_buffer(cmd, LispMapCacheRLOCList, 0); // Set length later
+             if (!*skb) {
+                 return false; // Client can retry on schedule.
+             }
+             rloclist = (lisp_cache_address_list_t *)(*cmd)->val;
+         }
+         (*count)++;
+         memcpy(&rloclist->addr_list[*count - 1], &entry->locator_list[i]->locator,
+                sizeof(lisp_addr_t));
+     }
+     return true;
+ }
+
+/*
+ * send_map_cache_list()
+ *
+ * Provide a list of all EIDs or RLOCs in all address families
+ * currently in the map cache, addresses and AFIs only.
+ */
+void send_map_cache_list(int dstpid, uint16_t request_type,
+                                   char with_traffic_only)
+{
+    patricia_node_t *node;
+    lisp_map_cache_t *map_entry = NULL;
+    lisp_cmd_t *cmd;
+    int addr_count = 0;
+    struct sk_buff *skb;
+    int    err;
+
+    skb = allocate_nl_buffer(&cmd, request_type, 0); // Set length later
+    if (!skb) {
+        return; // Client can retry on schedule.
+    }
+    spin_lock_bh(&table_lock);
+
+    /*
+     * Walk the cache patricia trie and build a
+     * message containing the list of addresses
+     * of each EID entry.
+     */
+    PATRICIA_WALK(AF4_eid_cache->head, node) {
+        map_entry = node->data;
+        printk(KERN_INFO "at node %pi4/%d @0x%x\n",
+               &(node->prefix->add.sin.s_addr),
+               node->prefix->bitlen,
+               (unsigned) map_entry);
+
+        if (request_type == LispMapCacheEIDList) {
+            if (!build_eid_list_entry(&addr_count, &skb, dstpid, &cmd,
+                                      &map_entry->eid_prefix)) {
+                return;
+            }
+        } else if (request_type == LispMapCacheRLOCList) {
+
+            /*
+             * If for traffic monitoring function, only add those
+             * entries that had traffic.
+             */
+            if (!(with_traffic_only && !map_entry->active_within_period)) {
+                if (!build_rloc_list_entry(&addr_count, &skb, dstpid, &cmd,
+                                           map_entry)) {
+                    return;
+                }
+            }
+        } else {
+            printk(KERN_INFO "Unknown map cache request type %d\n", request_type);
+            return;
+        }
+    } PATRICIA_WALK_END;
+
+    PATRICIA_WALK(AF6_eid_cache->head, node) {
+        map_entry = node->data;
+        printk(KERN_INFO "at node %pi6/%d @0x%x\n",
+               node->prefix->add.sin6.s6_addr,
+               node->prefix->bitlen,
+               (unsigned) map_entry);
+
+        if (request_type == LispMapCacheEIDList) {
+            if (!build_eid_list_entry(&addr_count, &skb, dstpid, &cmd,
+                                      &map_entry->eid_prefix)) {
+                return;
+            }
+        } else if (request_type == LispMapCacheRLOCList) {
+
+            /*
+             * If for traffic monitoring function, only add those
+             * entries that had traffic.
+             */
+            if (!(with_traffic_only && !map_entry->active_within_period)) {
+                if (!build_rloc_list_entry(&addr_count, &skb, dstpid, &cmd,
+                                           map_entry)) {
+                    return;
+                }
+            }
+        } else {
+            printk(KERN_INFO "Unknown map cache request type %d\n", request_type);
+            return;
+        }
+    } PATRICIA_WALK_END;
+
+    /*
+     * If any are left after the above run, send them out
+     */
+    if (addr_count) {
+        printk("Sending map-cache list to lispd with %d entries.", addr_count);
+        ((lisp_cache_address_list_t *)(cmd->val))->count = addr_count;
+        cmd->length = sizeof(lisp_cache_address_list_t) + sizeof(lisp_addr_t) * (addr_count);
+        err = netlink_unicast(globals.nl_socket, skb, dstpid, MSG_DONTWAIT);
+        if (err < 0) {
+            printk(KERN_INFO "Error sending to lispd. Clearing PID.\n");
+            globals.daemonPID = 0;
+            return;
+        }
+    }
+
+    spin_unlock_bh(&table_lock);
+
+    /*
+     * Notify the client that the list is complete
+     */
+    send_command_complete_msg(dstpid);
+}
+
+/*
+ * handle_map_cache_list_request()
+ *
+ * Respond to a cache list request from a process-level client
+ */
+void handle_map_cache_list_request(lisp_cmd_t *cmd, int srcpid)
+{
+    send_map_cache_list(srcpid, cmd->type, 0);
+}
+
+/*
+ * handle_map_db_delete()
+ *
+ * Delete a mapping entry, locator or set of locators
+ * from the database.
+ */
+void handle_map_db_delete(lisp_cmd_t *cmd, int length)
+{
+  return;
+}
+
+
+/*
+ * handle_map_db_lookup()
+ *
+ * Process a databse lookup request message from user-level
+ */
+void handle_map_db_lookup(lisp_cmd_t *cmd, int pid)
+{
+  patricia_node_t *node;
+  lisp_database_entry_t *db_entry;
+
+  /*
+   * Walk the cache patricia trie and send a message back
+   * for each entry.
+   */
+  spin_lock_bh(&table_lock);
+  PATRICIA_WALK(AF4_eid_db->head, node) {
+    db_entry = node->data;
+    printk(KERN_INFO "at node %pi4/%d @0x%x\n",
+       &(node->prefix->add.sin.s_addr),
+       node->prefix->bitlen,
+       (unsigned) db_entry);
+    if (db_entry)
+      send_db_lookup_response_msg(db_entry, pid);
+    } PATRICIA_WALK_END;
+  
+  PATRICIA_WALK(AF6_eid_db->head, node) {
+    db_entry = node->data;
+    printk(KERN_INFO "at node %pi6/%d @0x%x\n",
+	   node->prefix->add.sin6.s6_addr,
+	   node->prefix->bitlen,
+	   (unsigned) db_entry);
+    if (db_entry)
+      send_db_lookup_response_msg(db_entry, pid);
+  } PATRICIA_WALK_END;
+  spin_unlock_bh(&table_lock);
+
+  /*
+   * Notify the client that the walk is complete
+   */
+  send_command_complete_msg(pid);
+}
+
+/*
+ * handle_map_cache_add()
+ *
+ * Process an eid mapping message from user-level
+ */
+void handle_map_cache_add(lisp_cmd_t *cmd, int pid)
+{
+    int entries;
+    lisp_eid_map_msg_t     *current_entry;
+    lisp_eid_map_msg_loc_t *current_loc;
+    char eid_str[128];
+    char loc_str[128];
+    int i;
+  
+    printk(KERN_INFO "   Contains %d mapping(s)", entries);
+  
+    /*
+     * Dump the info for each entry to the kernel log
+     */
+    current_entry = (lisp_eid_map_msg_t *)cmd->val;
+    if (current_entry->eid_prefix.afi == AF_INET) {
+        snprintf(eid_str, 128, "  %pi4/%d -> ",
+                 &(current_entry->eid_prefix.address.ip.s_addr),
+                 current_entry->eid_prefix_length);
+    } else if (current_entry->eid_prefix.afi == AF_INET6) {
+        snprintf(eid_str, 128, " %pi6/%d ->",
+                 current_entry->eid_prefix.address.ipv6.s6_addr,
+                 current_entry->eid_prefix_length);
+    } else {
+        printk(KERN_INFO "     Unknown address family %d, skipping\n",
+               current_entry->eid_prefix.afi);
+        return;
+    }
+
+    entries = current_entry->count;
+
+    printk(KERN_INFO "   Contains %d locators(s)\n", entries);
+
+    for (i = 0; i < entries; i++) {
+        current_loc = (lisp_eid_map_msg_loc_t *)(current_entry->locators + i * sizeof(lisp_eid_map_msg_loc_t));
+        if (current_loc->locator.afi == AF_INET) {
+            snprintf(loc_str, 128, " to %pi4",
+                     &current_loc->locator.address.ip.s_addr);
+        } else if (current_loc->locator.afi == AF_INET6) {
+            snprintf(loc_str, 128, " to %pi6",
+                     current_loc->locator.address.ipv6.s6_addr);
+        } else {
+            printk(KERN_INFO " Unknown locator address family %d, skipping\n",
+                   current_loc->locator.afi);
+            continue;
+        }
+        printk(KERN_INFO "%s%s, (%d, %d)\n",
+               eid_str, loc_str,
+               current_loc->priority,
+               current_loc->weight);
+    }
+    if (!i) {
+        printk(KERN_INFO "Negative cache entry\n");
+    }
+    add_eid_cache_entry(current_entry);
+    return;
+}
+
+/*
+ * handle_map_db_add()
+ *
+ * Process an eid database mapping message from user-level
+ */
+void handle_map_db_add(lisp_cmd_t *cmd, int length)
+{
+    lisp_db_add_msg_t *current_entry;
+    lisp_db_add_msg_loc_t *loc;
+    char eid_str[128];
+    char loc_str[128];
+    int i;
+  
+    /*
+     * Dump the info for each entry to the kernel log
+     */
+    current_entry = (lisp_db_add_msg_t *)cmd->val;
+    if (current_entry->eid_prefix.afi == AF_INET) {
+      snprintf(eid_str, 128, "  %pi4/%d -> ", 
+           &(current_entry->eid_prefix.address.ip.s_addr),
+           current_entry->eid_prefix_length);
+    } else if (current_entry->eid_prefix.afi == AF_INET6) {
+      snprintf(eid_str, 128, " %pi6/%d ->",
+           current_entry->eid_prefix.address.ipv6.s6_addr,
+           current_entry->eid_prefix_length);
+    } else {
+      printk(KERN_INFO " Unknown address family %d, skipping", 
+         current_entry->eid_prefix.afi);
+      return;
+    }
+
+    for (i = 0; i < current_entry->count; i++) {
+        loc = (lisp_db_add_msg_loc_t *)(current_entry->locators + i * sizeof(lisp_db_add_msg_loc_t));
+        if (loc->locator.afi == AF_INET) {
+            snprintf(loc_str, 128, " to %pi4",
+                     &loc->locator.address.ip.s_addr);
+        } else if (loc->locator.afi == AF_INET6) {
+            snprintf(loc_str, 128, " to %pi6",
+                     loc->locator.address.ipv6.s6_addr);
+        } else {
+            printk(KERN_INFO " Unknown locator address family %d!",
+                   loc->locator.afi);
+            sprintf(loc_str, "N/A");
+        }
+        printk(KERN_INFO "%s%s, (%d, %d)",
+               eid_str, loc_str,
+               loc->priority,
+               loc->weight);
+    }
+    add_eid_db_entry(current_entry);
+}
+
+/*
+ * handle_set_rloc()
+ *
+ * Set our local rloc to the address provided in the message.
+ * This is used as the source address of all encapsulated packets.
+ */
+void handle_set_rloc(lisp_cmd_t *cmd, int pid)
+{
+  lisp_set_rloc_msg_t *msg = (lisp_set_rloc_msg_t *)cmd->val;
+
+  if (msg->addr.afi == AF_INET) {
+    globals.my_rloc.address.ip.s_addr = msg->addr.address.ip.s_addr;
+    globals.my_rloc_af = msg->addr.afi;
+    printk(KERN_INFO "  Set to %pI4\n", &globals.my_rloc.address.ip.s_addr);
+  } else {
+    if (msg->addr.afi == AF_INET6) {
+      memcpy(globals.my_rloc.address.ipv6.s6_addr, 
+	     msg->addr.address.ipv6.s6_addr,
+	     sizeof(lisp_addr_t));
+      globals.my_rloc_af = msg->addr.afi;
+      printk(KERN_INFO "  Set to %pI6\n", globals.my_rloc.address.ipv6.s6_addr);
+    } else {
+      printk(KERN_INFO "Unknown AF %d in set rloc message\n", msg->addr.afi);
+    }
+  }
+}
+
+/*
+ * handle_cache_sample()
+ *
+ * Process a reponse to our cache sample message, containing
+ * marked status for locators.
+ */
+void handle_cache_sample(lisp_cmd_t *cmd, int srcpid)
+{
+    lisp_cache_sample_msg_t *msg;
+
+    msg = (lisp_cache_sample_msg_t *)cmd->val;
+
+    if (msg->eid.afi == AF_INET) {
+        printk(KERN_INFO "Received returned cache sample message for EID %pI4/%d\n",
+               &msg->eid.address, msg->eid_prefix_length);
+    } else if (msg->eid.afi == AF_INET6) {
+        printk(KERN_INFO "Received returned cache sample message for EID %pI6/%d\n",
+               msg->eid.address.ipv6.s6_addr, msg->eid_prefix_length);
+    } else {
+        printk(KERN_INFO "Received returned cache sample message for EID with unknown AFI");
+        return;
+    }
+
+    update_locator_set_by_msg(msg);
+}
+
+/*
+ * handle_traffic_mon_start
+ *
+ * Start the traffic monitoring timer, and mark the current
+ * cache entries with their traffic stats so we can compare
+ * later.
+ */
+void handle_traffic_mon_start(lisp_cmd_t *cmd, int pid) {
+    start_traffic_monitor();
+}
+
+/*
+ * handle_set_udp_ports
+ *
+ * lispd is informing us that the udp ports have changed, update
+ * our values.
+ */
+void handle_set_udp_ports(lisp_cmd_t *cmd, int pid) {
+    lisp_set_ports_msg_t *msg = (lisp_set_ports_msg_t *)cmd->val;
+
+    globals.udp_encap_port = msg->data_port;
+    globals.udp_control_port = msg->control_port;
+    printk(KERN_INFO "Set UDP ports to %d (control), %d (encap)",
+           globals.udp_control_port, globals.udp_encap_port);
+}
+
+
+/*
+ * handle_daemon_register()
+ *
+ * Accept a new lispd registration and cache
+ * it's pid for later communication.
+ */
+void handle_daemon_register(lisp_cmd_t *cmd, int pid)
+{
+    if (globals.daemonPID != 0) {
+        printk(KERN_INFO "   Warning, a lisp daemon was already registered, replacing PID\n");
+    }
+    globals.daemonPID = pid;
+}
+
+/*
+ * handle_no_action()
+ *
+ * Generic handler for messages we either don't take action on or don't
+ * support.
+ */
+void handle_no_action(lisp_cmd_t *cmd, int pid)
+{
+    printk(KERN_INFO "  No action taken for this message type.");
+}
+
+/*
+ * lisp_netlink_input()
+ *
+ * Message entry point for LISP user-space to kernel module
+ * control processing. 
+*/
+void lisp_netlink_input(struct sk_buff *skb)
+{ 
+
+  struct nlmsghdr *nlh = NULL;
+  int lispmsglen       = 0;
+  int pid;
+  lisp_cmd_t *cmd;
+    
+  nlh        = (struct nlmsghdr *)(skb->data);
+  cmd        = (lisp_cmd_t *)NLMSG_DATA(nlh);
+  pid        = NETLINK_CB(skb).pid;
+  lispmsglen = nlh->nlmsg_len - NLMSG_HDRLEN;
+
+  printk(KERN_INFO "  Received netlink input, PID %d, len %d.\n",
+     pid, lispmsglen);
+
+#ifdef DEBUG
+  dump_message((char *)cmd, lispmsglen);
+#endif
+
+  if (cmd->type <= LispMaxType) {
+      printk(KERN_INFO "  Got %s message.\n", ipc_table[cmd->type].description);
+  } else {
+      printk(KERN_INFO "  Message type out of range: %d\n", cmd->type);
+  }
+
+  /*
+   * Call the handler from the table
+   */
+  (*(ipc_table[cmd->type].handler))(cmd, pid);
+  return;
+}
+
+/* 
+ * setup_netlink_socket
+ *
+ * Create the netlink socket through which user-level process
+ * can communicate with the module. Configuration and status
+ * messages traverse this channel.
+ */
+int setup_netlink_socket(void)
+{ 
+
+  // Set up the socket in the init network namespace
+  globals.nl_socket = netlink_kernel_create(&init_net, NETLINK_LISP, 0,
+                        lisp_netlink_input, NULL, THIS_MODULE);
+
+  if (globals.nl_socket != NULL) {
+    printk(KERN_INFO "  Netlink socket created.\n");
+    return 0;
+  } else {
+    printk(KERN_INFO "  Failed to create Netlink socket.\n");
+    return -1;
+  }
+}
+
+/*
+ * teardown_netlink_socket
+ *
+ * Disconnect the netlink socket
+ */
+void teardown_netlink_socket(void) {
+  netlink_kernel_release(globals.nl_socket);
+  return;
+}
+
Index: package/lisp_mod/src/timers.c
===================================================================
--- package/lisp_mod/src/timers.c	(revision 0)
+++ package/lisp_mod/src/timers.c	(revision 0)
@@ -0,0 +1,42 @@
+/*
+ * timers.h
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Support for a scalable timer mechanism in the 
+ * lisp kernel module. Uses the normal kernel
+ * timer facility to wake up every second and
+ * walk a sorted list of timers, expiring as necessary. * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    Chris White       <chris@logicalelegance.com>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+#include "timers.h"
+
+
+/*
+ * insertion sorted list of timers, closest
+ * to expiration first. If we need to scale
+ * up further than this can reasonably handle,
+ * implemenet as wheel or heap.
+ */
Index: package/lisp_mod/src/lisp_mod.c
===================================================================
--- package/lisp_mod/src/lisp_mod.c	(revision 0)
+++ package/lisp_mod/src/lisp_mod.c	(revision 0)
@@ -0,0 +1,166 @@
+/*
+ * lisp_mod.c
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Main entry point and initialization code
+ * for the LISP kernel module.
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    Chris White       	<chris@logicalelegance.com>
+ *    Preethi Natarajan 	<prenatar@cisco.com>
+ *    Vasileios Lakafosis   	<vasileios@gatech.edu>
+ *
+ */
+
+#include "lisp_mod.h"
+#include "lisp_slab.h"
+#include "packettypes.h"
+#include "tables.h"
+#include "version.h"
+
+MODULE_LICENSE("GPL");  /* Temporary, just quiets the kernel down */
+MODULE_AUTHOR("Christopher White");
+MODULE_DESCRIPTION("LISP Protocol Support");
+
+/*
+ * Module globals
+ */
+lisp_globals globals;
+
+/*
+ * setup_netfilter_hooks()
+ *
+ * Wire up our input and output routines into the
+ * ip stack.
+ */
+int setup_netfilter_hooks(void)
+{
+  globals.netfilter_ops_in.hook     = lisp_input;
+  globals.netfilter_ops_in.pf       = PF_INET;
+  globals.netfilter_ops_in.hooknum  = NF_INET_PRE_ROUTING;
+  globals.netfilter_ops_in.priority = NF_IP_PRI_FIRST;
+
+  globals.netfilter_ops_out.hook    = lisp_output4;
+  globals.netfilter_ops_out.pf      = PF_INET;
+  globals.netfilter_ops_out.hooknum = NF_INET_LOCAL_OUT;
+  globals.netfilter_ops_out.priority = NF_IP_PRI_FIRST;
+
+  globals.netfilter_ops_out6.hook    = lisp_output6;
+  globals.netfilter_ops_out6.pf      = PF_INET6;
+  globals.netfilter_ops_out6.hooknum = NF_INET_LOCAL_OUT;
+  globals.netfilter_ops_out6.priority = NF_IP_PRI_FIRST;
+    
+  globals.udp_control_port = LISP_CONTROL_PORT;
+  globals.udp_encap_port   = LISP_ENCAP_PORT;
+  nf_register_hook(&globals.netfilter_ops_in); 
+  nf_register_hook(&globals.netfilter_ops_out);
+  nf_register_hook(&globals.netfilter_ops_out6);
+  printk(KERN_INFO "   Netfilter hooks created.");
+
+  return 0;
+}
+
+/* 
+ * teardown_netfilter_hooks()
+ *
+ * Remove ourselves from the IP stack if the module
+ * is being removed.
+ */
+int teardown_netfilter_hooks(void)
+{
+  nf_unregister_hook(&globals.netfilter_ops_in);
+  nf_unregister_hook(&globals.netfilter_ops_out);
+  nf_unregister_hook(&globals.netfilter_ops_out6);
+  return 0;
+}
+
+/*
+ * Module initialization
+ */
+
+/*
+ * lisp_init()
+ *
+ * Main entry point for the module, performs all sub-initialization
+ */
+static int __init lisp_init (void)
+{
+  int result = 0;
+
+  printk(KERN_INFO "lisp_mod version %d.%d.%d starting up...\n",
+         MAJOR_VERSION, MINOR_VERSION, PATCH_VERSION);
+
+  result = setup_netfilter_hooks(); 
+
+  if (result != 0) {
+    printk(KERN_INFO "   failed to create hooks...\n");
+    return -1;
+  }
+
+  result = setup_netlink_socket();
+
+  if (result != 0) { 
+    printk(KERN_INFO "   failed to create NL socket...\n");
+    return -1;
+  }
+
+  create_tables();
+
+#ifdef	USE_LISP_SLAB_ALLOCATOR
+  if (init_lisp_caches()) {
+    printk(KERN_INFO "lisp caches created\n");
+  } else {
+    printk(KERN_INFO "couldn't create lisp caches\n");
+    return -1;
+  }
+#endif 
+
+  globals.always_encap = 1;       // XXX temporary for testing
+  memset(&globals.my_rloc, 0, sizeof(lisp_addr_t));
+  globals.my_rloc_af = 0;
+  globals.daemonPID = 0;          // 0 indicates unset
+
+  return 0;
+}
+
+/* 
+ * lisp_exit()
+ *
+ * Cleanup routine, called when module is removed from the
+ * kernel.
+ */
+static void __exit lisp_exit (void)
+{
+
+  printk(KERN_INFO "lisp_mod cleaning up...\n");
+  teardown_netfilter_hooks();
+  printk(KERN_INFO "   Netfilter hooks removed.");
+  teardown_netlink_socket();
+  printk(KERN_INFO "   Netlink socket closed.");
+#ifdef	USE_LISP_SLAB_ALLOCATOR
+  delete_lisp_caches();
+  printk(KERN_INFO "   lisp caches deleted\n");
+#endif
+}
+
+module_init(lisp_init);
+module_exit(lisp_exit);
Index: package/lisp_mod/src/lisp_ipc.h
===================================================================
--- package/lisp_mod/src/lisp_ipc.h	(revision 0)
+++ package/lisp_mod/src/lisp_ipc.h	(revision 0)
@@ -0,0 +1,267 @@
+/*
+ * lisp_ipc.h
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Defines the message structure for lisp ipc messages.
+ * These messages can be used to communicate between
+ * lisp user-level processes and the kernel, for example.
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    Chris White       <chris@logicalelegance.com>
+ *    David Meyer		<dmm@cisco.com>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+#pragma once
+
+#ifdef KERNEL
+#include <linux/in.h>
+#include <linux/inet.h>
+#include <linux/in6.h>
+#endif /* KERNEL */
+
+/*
+ * Constants
+ */
+#define MAX_MSG_LENGTH 1024  /* Max total message size. */
+
+/*
+ * XXX Temporary, needs to be in 
+ * /usr/include/linux/netlink.h
+ * formally.
+ */
+#define NETLINK_LISP 20 
+
+/*
+ * Lisp message types
+ */
+typedef enum {
+  LispOk = 0,
+  LispFailed = 1,
+  LispMapCacheLookup = 2,
+  LispMapCacheEIDList = 3,  // For ???
+  LispMapCacheRLOCList = 4, // For SMR's
+  LispDatabaseLookup = 5,
+  LispCacheSample = 6,      /* Kernel to process-level */
+  LispSetRLOC = 7,
+  LispMapCacheAdd = 8,
+  LispMapCacheDelete = 9,
+  LispMapCacheClear = 10,
+  LispDatabaseAdd = 11,
+  LispDatabaseDelete = 12,
+  LispDaemonRegister = 13,
+  LispTrafficMonStart = 14,
+  LispSetUDPPorts = 15,
+  LispMaxType = LispSetUDPPorts
+} lisp_msgtype_e;
+
+/* 
+ * Lisp address structure
+ */
+typedef struct {
+  union {
+    struct in_addr ip;
+    struct in6_addr ipv6;
+  } address;
+  int afi;
+} lisp_addr_t;
+
+/*
+ * Top level LISP message type, 
+ * all other messages are placed inside.
+ */
+typedef struct _lisp_cmd {
+  uint16_t type;
+  uint16_t length; // No message can exceed MAX_MSG_LENGTH - nlmsghdr length
+  char val[0];
+} lisp_cmd_t;
+
+/*
+ * Convey the UDP ports to use for encapsulation
+ * and controlto the kernel module. Sent by lispd.
+ */
+typedef struct {
+    uint16_t data_port;
+    uint16_t control_port;
+} lisp_set_ports_msg_t;
+
+typedef struct _lisp_lookup_msg {
+  lisp_addr_t prefix;
+  uint32_t    prefix_length;
+  int         exact_match;
+  int         all_entries;
+} lisp_lookup_msg_t;
+
+typedef struct _lisp_set_rloc_msg {
+  lisp_addr_t addr;
+} lisp_set_rloc_msg_t;
+
+#define ACTION_DROP         0
+#define ACTION_FORWARD      1
+#define ACTION_SEND_MAP_REQ 2
+
+/*
+ * Locator portion of eid map msg
+ */
+typedef struct {
+  lisp_addr_t locator;
+  uint8_t priority;
+  uint8_t weight;
+  uint8_t mpriority;
+  uint8_t mweight;
+} lisp_eid_map_msg_loc_t;
+
+/*
+ * Message structure for adding a cache entry,
+ * sent from user-space processes to the kernel.
+ */
+typedef struct {
+  lisp_addr_t   eid_prefix;
+  uint16_t      eid_prefix_length;
+  uint8_t       count;
+  uint8_t       actions; /* Defined above */
+  uint16_t      how_learned; /* 0: static or 1: map-reply */
+  uint32_t      ttl;
+  uint32_t      sampling_interval; /* In seconds, 0 never sample */
+  uint8_t       locators[0];
+} lisp_eid_map_msg_t;
+
+/*
+ * Compact response types for parties only
+ * interested in a list of RLOC's or EID's
+ * currently in use (for SMR, rloc probe purposes).
+ */
+typedef struct {
+    int cookie;               // opaque value passed back to lispd
+    int count;
+    lisp_addr_t addr_list[0];
+} lisp_cache_address_list_t;
+
+/*
+ * Response type for a cache entry lookup,
+ * sent from the kernel to user-space.
+ */
+typedef struct {
+  lisp_addr_t   locator;
+  uint8_t       priority;
+  uint8_t       weight;
+  uint8_t       mpriority;
+  uint8_t       mweight;
+  uint8_t       reachability_alg:2; /* rloc_prob | echo_none */
+  uint8_t       state:1;
+  uint8_t       reserved:5;
+  uint32_t      data_packets_in;
+  uint32_t      data_packets_out;
+} lisp_cache_response_loc_t;
+
+typedef struct {
+  lisp_addr_t eid_prefix;
+  uint8_t     eid_prefix_length;
+  uint8_t     how_learned:1;
+  uint8_t     complete:1;
+  uint8_t     actions:2;
+  uint8_t     locators_present:1;
+  uint8_t     reserved:3;
+  uint32_t    nonce0;
+  uint32_t    nonce1;
+  uint16_t    lsb;
+  uint16_t    ttl;
+  uint32_t    timestamp;
+  uint32_t    control_packets_in;
+  uint32_t    control_packets_out;
+  uint8_t     num_locators;
+  lisp_cache_response_loc_t locators[0];
+} lisp_cache_response_msg_t;
+
+/*
+ * Message structure for adding a database entry,
+ * sent from user-space to the kernel.
+ */
+typedef struct {
+    lisp_addr_t locator;
+    uint8_t     priority;
+    uint8_t     weight;
+    uint8_t     mpriority;
+    uint8_t     mweight;
+} lisp_db_add_msg_loc_t;
+
+typedef struct {
+  lisp_addr_t           eid_prefix;
+  uint16_t              eid_prefix_length;
+  uint16_t              count;
+  lisp_db_add_msg_loc_t locators[0];
+} lisp_db_add_msg_t;
+
+/* 
+ * Response type for a database entry lookup,
+ * sent from the kernel to user-space.
+ */
+typedef struct {
+  lisp_addr_t    locator;
+  uint8_t        priority;
+  uint8_t	 weight;
+  uint8_t        mpriority;
+  uint8_t	 mweight;
+  uint8_t	 reserved:4;		
+} lisp_db_response_loc_t;
+
+typedef struct {
+  lisp_addr_t    eid_prefix;
+  uint8_t        eid_prefix_length;
+  uint8_t        num_locators;
+  uint16_t         lsb;
+  lisp_db_response_loc_t locators[0];
+} lisp_db_response_msg_t;
+
+/* 
+ * Database deletion message type. Sent
+ * from user-space to the kernel.
+ */
+typedef struct {
+  lisp_addr_t eid_prefix;
+  uint8_t     eid_prefix_length;
+  lisp_addr_t     locator;
+} lisp_db_delete_msg_t;
+  
+/*
+ * Cache miss or sampling notification, sent from kernel
+ * to lispd. When sent with no locators, indicates cache
+ * miss. Also sent *back* from lispd to the kernel
+ * when an RLOC probe sequence is completed for an EID.
+ * In this case, the status bits indicate the reachability
+ * of the locators in the list.
+ */
+typedef enum {
+    ProbeSample,
+    SMRSample,
+    CacheMiss
+} sample_reason_e;
+
+typedef struct {
+  int         reason;
+  lisp_addr_t eid;
+  int         eid_prefix_length; /* Unused when cache miss */
+  int         num_locators;      /* zero when cache miss */
+  int         status_bits;       /* Bitfield filled by lispd when sending back to kernel */
+  lisp_addr_t locators[0];
+} lisp_cache_sample_msg_t;
Index: package/lisp_mod/src/lisp_ipc_kernel.h
===================================================================
--- package/lisp_mod/src/lisp_ipc_kernel.h	(revision 0)
+++ package/lisp_mod/src/lisp_ipc_kernel.h	(revision 0)
@@ -0,0 +1,60 @@
+/*
+ * lisp_ipc_kernel.h
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Declares the kernel private structures and 
+ * functions for inter-process communications. 
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    Chris White       <chris@logicalelegance.com>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ */
+
+#pragma once
+
+#include "net/ip.h"
+
+/*
+ * Function declarations
+ */
+void dump_message(char *msg, int length);
+void send_cache_miss_notification(lisp_addr_t, short);
+void send_cache_sample_notification(lisp_map_cache_t *, sample_reason_e);
+void send_map_cache_list(int dstpid, uint16_t request_type,
+                         char with_traffic_only);
+
+void handle_no_action(lisp_cmd_t *cmd, int pid);
+void handle_map_cache_lookup(lisp_cmd_t *cmd, int pid);
+void handle_map_cache_add(lisp_cmd_t *cmd, int pid);
+void handle_map_cache_list_request(lisp_cmd_t *cmd, int pid);
+void handle_map_db_lookup(lisp_cmd_t *cmd, int pid);
+void handle_map_db_add(lisp_cmd_t *cmd, int pid);
+void handle_map_db_delete(lisp_cmd_t *cmd, int pid);
+void handle_cache_sample(lisp_cmd_t *cmd, int pid);
+void handle_set_rloc(lisp_cmd_t *cmd, int pid);
+void handle_daemon_register(lisp_cmd_t *cmd, int pid);
+void handle_traffic_mon_start(lisp_cmd_t *cmd, int pid);
+void handle_set_udp_ports(lisp_cmd_t *cmd, int pid);
+
+void lisp_netlink_input(struct sk_buff *skb);
+int setup_netlink_socket(void);
+void teardown_netlink_socket(void);
Index: package/lisp_mod/src/lisp_slab.c
===================================================================
--- package/lisp_mod/src/lisp_slab.c	(revision 0)
+++ package/lisp_mod/src/lisp_slab.c	(revision 0)
@@ -0,0 +1,103 @@
+/*
+ * lisp_slab.c
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Initialize/destroy and support for the slab allocator
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    David Meyer       <dmm@.com>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+
+#include "tables.h"
+#include "lisp_mod.h"
+
+#ifdef	USE_LISP_SLAB_ALLOCATOR
+struct kmem_cache *lisp_map_cache;		/* map cache */
+struct kmem_cache *lisp_map_cache_loctype;	/* mc locators */
+struct kmem_cache *lisp_database;		/* database */
+struct kmem_cache *lisp_database_loctype;	/* db locators */
+
+int init_lisp_caches(void)
+{
+    lisp_map_cache = kmem_cache_create("lisp_map_cache_t",
+				       sizeof(lisp_map_cache_t), 
+				       0,                  
+				       SLAB_HWCACHE_ALIGN, 
+				       NULL);              
+    if (lisp_map_cache == NULL) {
+	printk(KERN_INFO "Couldn't create lisp_map_cache_t cache\n");
+	return (0);
+    }
+
+    lisp_map_cache_loctype = kmem_cache_create("lisp_map_cache_loc_t",
+				       sizeof(lisp_map_cache_loc_t), 
+				       0,                  
+				       SLAB_HWCACHE_ALIGN, 
+				       NULL);              
+    if (lisp_map_cache_loctype == NULL) {
+	printk(KERN_INFO "Couldn't create lisp_map_cache_loc_t cache\n");
+	return (0);
+    }
+
+    lisp_database = kmem_cache_create("lisp_database_entry_t",
+				       sizeof(lisp_database_entry_t), 
+				       0,                  
+				       SLAB_HWCACHE_ALIGN, 
+				       NULL);              
+    if (lisp_database == NULL) {
+	printk(KERN_INFO "Couldn't create lisp_database_entry_t cache\n");
+	return (0);
+    }
+
+    lisp_database_loctype = kmem_cache_create("lisp_database_loc_t",
+				       sizeof(lisp_database_loc_t), 
+				       0,                  
+				       SLAB_HWCACHE_ALIGN, 
+				       NULL);              
+    if (lisp_database_loctype == NULL) {
+	printk(KERN_INFO "Couldn't create lisp_database_loc_t cache\n");
+	return (0);
+    }
+
+    return(1);
+}
+
+void delete_lisp_caches(void)
+{
+    teardown_trees();
+
+    if (lisp_map_cache)
+	kmem_cache_destroy(lisp_map_cache);
+    if (lisp_map_cache_loctype)
+	kmem_cache_destroy(lisp_map_cache_loctype);
+    if (lisp_database)
+	kmem_cache_destroy(lisp_database);
+    if (lisp_database_loctype)
+	kmem_cache_destroy(lisp_database_loctype);
+    return;
+}
+
+#endif
+
Index: package/lisp_mod/src/tables.c
===================================================================
--- package/lisp_mod/src/tables.c	(revision 0)
+++ package/lisp_mod/src/tables.c	(revision 0)
@@ -0,0 +1,1278 @@
+/*
+ * tables.c
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Support and storage for LISP EID maps and other tables.
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    Chris White       <chris@logicalelegance.com>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+#include "tables.h"
+#include "lisp_mod.h"
+
+#define SECS_PER_MIN 60
+#define DEBUG_HASHES
+
+/*
+ * Import symbols
+ */
+extern lisp_globals globals;
+
+/*
+ * Tables
+ */
+spinlock_t table_lock;
+
+patricia_tree_t *AF4_eid_cache;
+patricia_tree_t *AF6_eid_cache;
+
+patricia_tree_t *AF4_eid_db;
+patricia_tree_t *AF6_eid_db;
+
+// A populated count to bit table for lsb setup.
+// This is for when we assume all locators are
+// available when setting up an entry. i.e.
+// 3 locators --> 0000000....00000111
+int lsb_table[32 + 1];
+void build_lsb_table(void);
+
+/*
+ * create_tables
+ */
+void create_tables(void)
+{
+  
+  printk(KERN_INFO " Creating mapping tables...");
+  
+  AF4_eid_cache = New_Patricia(sizeof(struct in_addr) * 8);
+  AF6_eid_cache = New_Patricia(sizeof(struct in6_addr) * 8);
+  AF4_eid_db = New_Patricia(sizeof(struct in_addr) * 8);
+  AF6_eid_db = New_Patricia(sizeof(struct in6_addr) * 8);
+
+  if (!AF4_eid_cache || !AF6_eid_cache || !AF4_eid_db || !AF6_eid_db) {
+    printk(KERN_INFO "    FAILED.");
+  } else {
+    printk(KERN_INFO "    Success.");
+  }
+  spin_lock_init(&table_lock);
+
+  build_lsb_table();
+}
+
+/*
+ * build_lsb_table()
+ *
+ * Build a lookup table for initial lsb setup.
+ */
+void build_lsb_table(void)
+{
+    int i, j;
+
+    lsb_table[0] = 0;
+    for (i = 1; i <= 32; i++) {
+        lsb_table[i] = 0;
+        for (j = 0; j < i; j++) {
+            lsb_table[i] |= 1 << j;
+        }
+    }
+}
+
+/*
+ * lookup_eid_cache_v4()
+ *
+ * Look up a given ipv4 eid in the cache, returning true and
+ * filling in the entry pointer if found, or false if not found.
+ */
+int lookup_eid_cache_v4(int eid, lisp_map_cache_t **entry)
+{
+  patricia_node_t *result;
+  prefix_t prefix;
+  
+  spin_lock_bh(&table_lock);
+  prefix.family = AF_INET;
+  prefix.bitlen = 32;
+  prefix.ref_count = 0;
+  prefix.add.sin.s_addr = eid;
+
+  result = patricia_search_best(AF4_eid_cache, &prefix);
+  if (!result) {
+    spin_unlock_bh(&table_lock);
+    return(0);
+  }
+
+  *entry = (lisp_map_cache_t *)(result->data);
+  spin_unlock_bh(&table_lock);
+  return(1);
+}
+
+/*
+ * lookup_eid_cache_v4_exact()
+ *
+ * Find an exact match for a prefix/prefixlen if possible
+ */
+int lookup_eid_cache_v4_exact(int eid, int prefixlen, lisp_map_cache_t **entry)
+{
+  patricia_node_t *result;
+  prefix_t prefix;
+
+  spin_lock_bh(&table_lock);
+  
+  prefix.family = AF_INET;
+  prefix.bitlen = prefixlen;
+  prefix.ref_count = 0;
+  prefix.add.sin.s_addr = eid;
+
+  result = patricia_search_exact(AF4_eid_cache, &prefix);
+  if (!result) {
+    spin_unlock_bh(&table_lock);
+    *entry = NULL;
+    return(0);
+  }
+
+  *entry = (lisp_map_cache_t *)(result->data);
+  spin_unlock_bh(&table_lock);
+  return(1);
+}
+
+/*
+ * lookup_eid_cache_v6_exact()
+ *
+ * Find an exact match for a prefix/prefixlen if possible
+ */
+int lookup_eid_cache_v6_exact(lisp_addr_t eid_prefix, int prefixlen, lisp_map_cache_t **entry)
+{
+  patricia_node_t *result;
+  prefix_t prefix;
+  
+  spin_lock_bh(&table_lock);
+  prefix.family = AF_INET6;
+  prefix.bitlen = prefixlen;
+  prefix.ref_count = 0;
+  memcpy(prefix.add.sin6.s6_addr, eid_prefix.address.ipv6.s6_addr, 
+     sizeof(struct in6_addr));
+
+  result = patricia_search_exact(AF6_eid_cache, &prefix);
+  if (!result) {
+    spin_unlock_bh(&table_lock);
+    *entry = NULL;
+    return(0);
+  }
+
+  *entry = (lisp_map_cache_t *)(result->data);
+  spin_unlock_bh(&table_lock);
+  return(1);
+}
+
+/*
+ * lookup_eid_cache_v6()
+ *
+ * Find a longest match for a prefix if possible
+ */
+int lookup_eid_cache_v6(lisp_addr_t eid, lisp_map_cache_t **entry)
+{
+  patricia_node_t *result;
+  prefix_t prefix;
+  
+  spin_lock_bh(&table_lock);
+  prefix.family = AF_INET6;
+  prefix.bitlen = 128;
+  prefix.ref_count = 0;
+  memcpy(prefix.add.sin6.s6_addr, eid.address.ipv6.s6_addr, 
+     sizeof(struct in6_addr));
+
+  result = patricia_search_best(AF6_eid_cache, &prefix);
+  if (!result) {
+    spin_unlock_bh(&table_lock);
+    return(0);
+  }
+
+  *entry = (lisp_map_cache_t *)(result->data);
+  spin_unlock_bh(&table_lock);
+  return(1);
+}
+
+/*
+ * lookup_eid_db_v4()
+ *
+ * Look up a given ipv4 eid in the database, returning true and
+ * filling in the entry pointer if found, or false if not found.
+ */
+int lookup_eid_db_v4(int eid, lisp_database_entry_t **entry)
+{
+  patricia_node_t *result;
+  prefix_t prefix;
+  
+  prefix.family = AF_INET;
+  prefix.bitlen = 32;
+  prefix.ref_count = 0;
+  prefix.add.sin.s_addr = eid;
+
+  spin_lock_bh(&table_lock);
+  result = patricia_search_best(AF4_eid_db, &prefix);
+  if (!result) {
+    spin_unlock_bh(&table_lock);
+    return(0);
+  }
+
+  *entry = (lisp_database_entry_t *)(result->data);
+  spin_unlock_bh(&table_lock);
+  return(1);
+}
+
+/*
+ * lookup_eid_db_v4_exact()
+ *
+ * Look up a given ipv4 eid/prefixlen in the database, returning true and
+ * filling in the entry pointer if found, or false if not found.
+ */
+int lookup_eid_db_v4_exact(int eid, int prefixlen, lisp_database_entry_t **entry)
+{
+  patricia_node_t *result;
+  prefix_t prefix;
+  
+  prefix.family = AF_INET;
+  prefix.bitlen = prefixlen;
+  prefix.ref_count = 0;
+  prefix.add.sin.s_addr = eid;
+  spin_lock_bh(&table_lock);
+  result = patricia_search_exact(AF4_eid_db, &prefix);
+  if (!result) {
+    spin_unlock_bh(&table_lock);
+    return(0);
+  }
+
+  *entry = (lisp_database_entry_t *)(result->data);
+  spin_unlock_bh(&table_lock);
+  return(1);
+}
+
+/*
+ * lookup_eid_db_v6_exact()
+ *
+ * Find an exact match for a prefix/prefixlen if possible in the
+ * database, using an ipv6 prefix.
+ */
+int lookup_eid_db_v6_exact(lisp_addr_t eid_prefix, int prefixlen, lisp_database_entry_t **entry)
+{
+  patricia_node_t *result;
+  prefix_t prefix;
+  
+  spin_lock_bh(&table_lock);
+  prefix.family = AF_INET6;
+  prefix.bitlen = prefixlen;
+  prefix.ref_count = 0;
+  memcpy(prefix.add.sin6.s6_addr, eid_prefix.address.ipv6.s6_addr, 
+     sizeof(struct in6_addr));
+
+  result = patricia_search_exact(AF6_eid_db, &prefix);
+  if (!result) {
+    spin_unlock_bh(&table_lock);
+    return(0);
+  }
+
+  *entry = (lisp_database_entry_t *)(result->data);
+  spin_unlock_bh(&table_lock);
+  return(1);
+}
+
+/*
+ * eid_entry_expiration()
+ *
+ * Called when the timer associated with an EID entry expires.
+ */
+void eid_entry_expiration(unsigned long arg)
+{
+  lisp_map_cache_t *entry = (lisp_map_cache_t *)arg;
+  
+  printk(KERN_INFO "Got expiration for EID %pi4", &entry->eid_prefix.address.ip.s_addr);
+  del_eid_cache_entry(entry->eid_prefix, entry->eid_prefix_length);
+}
+
+/*
+ * eid_entry_probe_sample()
+ *
+ * Called when the sampling timer expires, send a sample
+ * of the EID cache entry to lispd.
+ */
+void eid_entry_probe_sample(unsigned long arg)
+{
+    lisp_map_cache_t *entry = (lisp_map_cache_t *)arg;
+
+    spin_lock_bh(&table_lock);
+    printk(KERN_INFO "Sending sample of EID %pi4 for probe", &entry->eid_prefix.address.ip.s_addr);
+    send_cache_sample_notification(entry, ProbeSample);
+
+    /*
+     * Restart the timer
+     */
+    mod_timer(&entry->probe_timer, jiffies + entry->sampling_interval * HZ);
+    spin_unlock_bh(&table_lock);
+    return;
+}
+
+/*
+ * eid_entry_smr_sample()
+ *
+ * Called when the sampling timer expires, send a sample
+ * of the EID cache entry to lispd.
+ */
+void eid_entry_smr_sample(unsigned long arg)
+{
+    lisp_map_cache_t *entry = (lisp_map_cache_t *)arg;
+
+    spin_lock_bh(&table_lock);
+    if (entry->active_within_period) {
+        printk(KERN_INFO "Sending sample of EID %pi4 for SMR", &entry->eid_prefix.address.ip.s_addr);
+        send_cache_sample_notification(entry, SMRSample);
+    }
+    spin_unlock_bh(&table_lock);
+    return;
+}
+
+/*
+ * add_db_entry_locator
+ *
+ * Add a new locator to a database entry. If the given locator
+ * is already in the list, return the pointer to that list
+ * member, otherwise allocate a new one.
+ */
+void add_db_entry_locator(lisp_database_entry_t *db_entry,
+                          lisp_db_add_msg_loc_t *locator_list,
+                          int index)
+{
+  lisp_database_loc_t *locator_entry;
+  lisp_db_add_msg_loc_t *new_locator =
+          locator_list + index;
+
+  locator_entry = db_entry->locator_list[index];
+
+  if (!locator_entry) {
+      printk(KERN_INFO "No existing locator at index %d, creating...\n", index);
+
+    /*
+     * Allocate a new locator
+     */
+      locator_entry  = kmem_cache_alloc(lisp_database_loctype, GFP_KERNEL);
+      printk(KERN_INFO "Allocating map-cache locator from %s\n",
+             kmem_cache_name(lisp_database_loctype));
+      if (!locator_entry) {
+          printk(KERN_INFO "Couldn't allocate from %s\n",
+                 kmem_cache_name(lisp_database_loctype));
+          return;
+      }
+      db_entry->locator_list[index] = locator_entry;
+  }
+
+  /*
+   * Copy in the fields
+   */
+  memset(locator_entry, 0, sizeof(lisp_database_loc_t));
+  locator_entry->priority  = new_locator->priority;
+  locator_entry->weight    = new_locator->weight;
+  locator_entry->mpriority = new_locator->mpriority;
+  memcpy(&locator_entry->locator, &new_locator->locator, sizeof(lisp_addr_t));
+
+  printk("   Added locator %pI4 (%pI4)", &locator_entry->locator.address.ip,
+         &new_locator->locator.address.ip);
+}
+
+/*
+ * add_eid_db_entry_v4()
+ *
+ * Add an EID/Locator mapping to the database for ipv4
+ */
+void add_eid_db_entry_v4(lisp_db_add_msg_t *entry)
+{
+  patricia_node_t       *node;
+  lisp_database_entry_t *db_entry;
+  struct timeval         timestamp;
+  int entry_exists = 0;
+  int locator_idx;
+
+  printk(KERN_INFO " Adding database mapping: %pi4/%d\n",
+         &entry->eid_prefix.address.ip.s_addr,
+         entry->eid_prefix_length);
+
+  /*
+   * Check for existing entry
+   */
+  if (!lookup_eid_db_v4_exact(entry->eid_prefix.address.ip.s_addr,
+                              entry->eid_prefix_length, &db_entry)) {
+
+      db_entry = kmem_cache_alloc(lisp_database, GFP_KERNEL);
+      printk(KERN_INFO "Allocating new map-database entry from %s\n",
+             kmem_cache_name(lisp_database));
+      if (!db_entry) {
+          printk(KERN_INFO "Couldn't allocate from %s\n",
+                 kmem_cache_name(lisp_database));
+          return;               /* XXX: correct? */
+      }
+
+      memset(db_entry, 0, sizeof(lisp_database_entry_t));
+      db_entry->eid_prefix.address.ip.s_addr    = entry->eid_prefix.address.ip.s_addr;
+      db_entry->eid_prefix_length       = entry->eid_prefix_length;
+      db_entry->eid_prefix.afi          = AF_INET;
+      do_gettimeofday(&timestamp);
+      db_entry->timestamp               = timestamp.tv_sec;
+
+      printk(KERN_INFO "  Entry not found, creating new entry");
+  } else {
+      printk(KERN_INFO "  Existing entry found, replacing locator list");
+      entry_exists = 1;
+  }
+
+  /*
+   * Add the locators
+   */
+  for (locator_idx = 0; locator_idx < MAX_LOCATORS; locator_idx++) {
+      if (locator_idx < entry->count) {
+          add_db_entry_locator(db_entry, (lisp_db_add_msg_loc_t *)entry->locators,
+                               locator_idx);
+      } else if (db_entry->locator_list[locator_idx]) {
+
+          /*
+           * Free old locators beyond what's current
+           */
+          kmem_cache_free(lisp_database_loctype, db_entry->locator_list[locator_idx]);
+          db_entry->locator_list[locator_idx] = NULL;
+      }
+  }
+  db_entry->count                   = entry->count;
+
+  /* Insert new prefix if not found */
+  if (!entry_exists) {
+      spin_lock_bh(&table_lock);
+      node = make_and_lookup_v4(AF4_eid_db, entry->eid_prefix.address.ip.s_addr,
+                                entry->eid_prefix_length);
+
+      if (!node) {
+          printk(KERN_INFO " Failed to allocate EID db tree node");
+          spin_unlock_bh(&table_lock);
+          return;
+      }
+      node->data = db_entry;
+      spin_unlock_bh(&table_lock);
+  }
+}
+
+/*
+ * add_eid_db_entry_v6()
+ *
+ * Add an EID/Locator mapping to the database for ipv6 eid
+ */
+void add_eid_db_entry_v6(lisp_db_add_msg_t *entry)
+{
+    patricia_node_t       *node;
+    lisp_database_entry_t *db_entry;
+    struct timeval         timestamp;
+    int entry_exists = 0;
+    int locator_idx;
+
+    printk(KERN_INFO " Adding database mapping: %pi6/%d\n",
+           entry->eid_prefix.address.ipv6.s6_addr,
+           entry->eid_prefix_length);
+
+    /*
+     * Check for existing entry
+     */
+    if (!lookup_eid_db_v6_exact(entry->eid_prefix,
+                                entry->eid_prefix_length, &db_entry)) {
+
+      db_entry = kmem_cache_alloc(lisp_database, GFP_KERNEL);
+      printk(KERN_INFO "Allocating new map-database entry from %s\n",
+             kmem_cache_name(lisp_database));
+      if (!db_entry) {
+        printk(KERN_INFO "Couldn't allocate from %s\n",
+               kmem_cache_name(lisp_database));
+        return;               /* XXX: correct? */
+      }
+
+      memset(db_entry, 0, sizeof(lisp_database_entry_t));
+      memcpy(&db_entry->eid_prefix, &entry->eid_prefix, sizeof(lisp_addr_t));
+      db_entry->eid_prefix_length       = entry->eid_prefix_length;
+      db_entry->eid_prefix.afi          = AF_INET6;
+      do_gettimeofday(&timestamp);
+      db_entry->timestamp               = timestamp.tv_sec;
+
+      printk(KERN_INFO "  Entry not found, creating new entry");
+    } else {
+      printk(KERN_INFO "  Existing entry found, replacing locator list");
+      entry_exists = 1;
+    }
+
+    /*
+     * Add the locators
+     */
+    for (locator_idx = 0; locator_idx < MAX_LOCATORS; locator_idx++) {
+        if (locator_idx < entry->count) {
+            add_db_entry_locator(db_entry, (lisp_db_add_msg_loc_t *)entry->locators,
+                                 locator_idx);
+        } else if (db_entry->locator_list[locator_idx]) {
+
+            /*
+                 * Free old locators beyond what's current
+                 */
+            kmem_cache_free(lisp_database_loctype, db_entry->locator_list[locator_idx]);
+            db_entry->locator_list[locator_idx] = NULL;
+        }
+    }
+    db_entry->count                   = entry->count;
+
+    /* Insert new prefix if not found */
+    if (!entry_exists) {
+        spin_lock_bh(&table_lock);
+        node = make_and_lookup_v6(AF6_eid_db, entry->eid_prefix.address.ipv6, entry->eid_prefix_length);
+
+        if (!node) {
+            printk(KERN_INFO " Failed to allocate EID db tree node");
+            spin_unlock_bh(&table_lock);
+            return;
+        }
+        node->data = db_entry;
+        spin_unlock_bh(&table_lock);
+    }
+}
+
+
+/*
+ * update_locator_hash_table()
+ *
+ * Update the hash table used to assign packets to locators
+ * based on priority and weight. Adapted from the NX/OS
+ * code.
+ */
+void update_locator_hash_table(lisp_map_cache_t *entry)
+{
+    lisp_map_cache_loc_t *loc;
+    int i, j, best_priority = 255;
+    int percent_left = 100;
+    int loc_count = 0;
+    int table_index, weight;
+    unsigned char used_locs[MAX_LOCATORS];
+
+    printk(KERN_INFO "Recomputing locator hash table for %pI4/%d\n",
+           &entry->eid_prefix, entry->eid_prefix_length);
+
+    memset(used_locs, 0, sizeof(unsigned char) * MAX_LOCATORS);
+
+    /*
+     * Find the highest priority RLOCS that are up.
+     */
+    for (i = 0; i < MAX_LOCATORS; i++) {
+        loc = entry->locator_list[i];
+        if (!loc || (loc->state == 0)) {
+            continue;
+        }
+        if (loc->priority < best_priority) {
+            best_priority = loc->priority;
+        }
+    }
+
+    /*
+     * Build a set of locators that we are going to use.
+     * This is at the priority established above, up, etc.
+     * (Can these two ops be merged?)
+     */
+    for (i = 0; i < MAX_LOCATORS; i++) {
+        loc = entry->locator_list[i];
+
+        // Match criteria
+        if (!loc || (loc->priority != best_priority) || (loc->state == 0)) {
+            continue;
+        }
+
+        // Out of available weight? Then we're done.
+        if ((percent_left - loc->weight) < 0) {
+            break;
+        }
+        percent_left -= loc->weight;
+
+        used_locs[loc_count] = i;
+        loc_count++;
+    }
+
+    /*
+     * Failed to find any usable? Set the buckets to invalid
+     */
+    if (!loc_count) {
+        for (i = 0; i < LOC_HASH_SIZE; i++) {
+            entry->locator_hash_table[i] = -1;
+        }
+        printk(KERN_INFO "   No usable locators found, hash table invalidated.");
+        return;
+    }
+
+    /*
+     * Divide up the remaining weight amongst the
+     * locators we're using. This is in case some of
+     * the best priority locators were down or the sum
+     * of weights was not 100.
+     */
+    percent_left = percent_left / loc_count;
+
+    /*
+     * Fill in the hash table for each locator, up to the
+     * weight it has been alloted.
+     */
+    table_index = 0;
+    for (i = 0; i < loc_count; i++) {
+        weight = (percent_left + entry->locator_list[used_locs[i]]->weight) >> 2;
+        for (j = table_index; j < (table_index + weight); j++) {
+            entry->locator_hash_table[j] = used_locs[i];
+        }
+        table_index += weight;
+    }
+
+    /*
+     * Fill up any remaining space in the hash table
+     * with the last locator.
+     */
+    if (table_index != LOC_HASH_SIZE) {
+        for (i = table_index; i < LOC_HASH_SIZE; i++) {
+            entry->locator_hash_table[i] = used_locs[loc_count - 1];
+        }
+    }
+
+#ifdef DEBUG_HASHES
+    char hash_str[LOC_HASH_SIZE + 1];
+    for (i = 0; i < LOC_HASH_SIZE; i++) {
+        hash_str[i] = (char)(entry->locator_hash_table[i]) + 0x30; // Quick convesion
+    }
+    hash_str[i] = '\0';
+    printk("     New hash table: %s\n", hash_str);
+#endif
+}
+
+/*
+ * add_cache_entry_locator
+ *
+ * Add a new locator to a cache entry. If the given locator
+ * is already in the list, return the pointer to that list
+ * member, otherwise allocate a new one.
+ */
+void add_cache_entry_locator(lisp_map_cache_t *cache_entry,
+                                              lisp_eid_map_msg_loc_t *locator_list,
+                                              int index)
+{
+  lisp_map_cache_loc_t *locator_entry;
+  lisp_eid_map_msg_loc_t *new_locator =
+          locator_list + index;
+  int input_count = 0, output_count = 0;
+
+  locator_entry = cache_entry->locator_list[index];
+
+  if (!locator_entry) {
+      printk(KERN_INFO "No existing locator at index %d, creating...\n", index);
+
+    /*
+     * Allocate a new locator
+     */
+      locator_entry  = kmem_cache_alloc(lisp_map_cache_loctype, GFP_KERNEL);
+      printk(KERN_INFO "Allocating map-cache locator from %s\n",
+             kmem_cache_name(lisp_map_cache_loctype));
+      if (!locator_entry) {
+          printk(KERN_INFO "Couldn't allocate from %s\n",
+                 kmem_cache_name(lisp_map_cache_loctype));
+          return;
+      }
+      memset(locator_entry, 0, sizeof(lisp_map_cache_loc_t));
+      cache_entry->locator_list[index] = locator_entry;
+  }
+
+  /*
+   * Copy in the fields
+   */
+  if (!memcmp(&locator_entry->locator, &new_locator->locator, sizeof(lisp_addr_t))) {
+      // Preserve the counters
+      input_count = locator_entry->data_packets_in;
+      output_count = locator_entry->data_packets_out;
+  }
+
+  memset(locator_entry, 0, sizeof(lisp_map_cache_loc_t));
+  locator_entry->data_packets_in = input_count;
+  locator_entry->data_packets_out = output_count;
+  locator_entry->priority  = new_locator->priority;
+  locator_entry->weight    = new_locator->weight;
+  locator_entry->mpriority = new_locator->mpriority;
+  locator_entry->reachability_alg = 0;  // Undef XXX
+  locator_entry->state = 1;
+
+  memcpy(&locator_entry->locator, &new_locator->locator, sizeof(lisp_addr_t));
+}
+
+
+/* 
+ * del_eid_cache_entry() 
+ *
+ * Delete an EID mapping from the cache
+ */
+void del_eid_cache_entry(lisp_addr_t eid,
+             int prefixlen)
+{
+  lisp_map_cache_loc_t *locator;
+  lisp_map_cache_t     *entry;
+  patricia_node_t      *result;
+  prefix_t              prefix;
+  int                   loc_idx = 0;
+
+  prefix.family = AF_INET;
+  prefix.bitlen = prefixlen;
+  prefix.ref_count = 0;
+  prefix.add.sin.s_addr = eid.address.ip.s_addr;
+  spin_lock_bh(&table_lock);
+  result = patricia_search_exact(AF4_eid_cache, &prefix);
+  if (!result) {
+      printk(KERN_INFO "   Unable to locate cache entry %pi4 for deletion",
+             &eid.address.ip.s_addr);
+      spin_unlock_bh(&table_lock);
+      return;
+  } else {
+      printk(KERN_INFO "   Deleting map cache EID entry %pi4", &eid.address.ip.s_addr);
+  }
+  
+  /*
+   * Remove the entry from the trie
+   */
+  entry = (lisp_map_cache_t *)(result->data);
+  patricia_remove(AF4_eid_cache, result);
+
+  /*
+    * Free the locators
+    */
+  for (loc_idx = 0; loc_idx < MAX_LOCATORS; loc_idx++) {
+      locator = entry->locator_list[loc_idx];
+      if (locator) {
+          kmem_cache_free(lisp_map_cache_loctype, locator);
+      }
+  }
+
+  /*
+   * Free the entry
+   */
+  if (entry->how_learned) {
+      del_timer(&entry->expiry_timer);
+      del_timer(&entry->smr_timer);
+  }
+  del_timer(&entry->probe_timer);
+  kmem_cache_free(lisp_map_cache, entry);
+  spin_unlock_bh(&table_lock);
+}
+
+/*
+ * add_eid_cache_entry_v4()
+ *
+ * Add an EID/locator mapping to the v4 map cache 
+ */
+void add_eid_cache_entry_v4(lisp_eid_map_msg_t *entry)
+{
+  patricia_node_t       *node;
+  lisp_map_cache_t      *map_entry;
+  struct timeval         timestamp;
+  int                    locator_idx = 0;
+  int                    entry_exists = 0;
+
+  printk(KERN_INFO " Adding cache mapping: %pi4/%d\n",
+         &entry->eid_prefix,
+         entry->eid_prefix_length);
+
+  /*
+   * Check for existing entry
+   */
+  if (!lookup_eid_cache_v4_exact(entry->eid_prefix.address.ip.s_addr,
+				 entry->eid_prefix_length, &map_entry)) {
+      map_entry = kmem_cache_alloc(lisp_map_cache,GFP_KERNEL);
+      printk(KERN_INFO "Allocating new map-cache entry from %s\n",
+             kmem_cache_name(lisp_map_cache));
+      if (!map_entry) {
+          printk(KERN_INFO "Couldn't allocate from %s\n",
+                 kmem_cache_name(lisp_map_cache));
+          return;               /* XXX: correct? */
+      }
+
+      memset(map_entry, 0, sizeof(lisp_map_cache_t));
+      map_entry->eid_prefix.address.ip.s_addr    = entry->eid_prefix.address.ip.s_addr;
+      map_entry->eid_prefix_length               = entry->eid_prefix_length;
+      map_entry->eid_prefix.afi                  = AF_INET;
+      map_entry->how_learned                     = entry->how_learned;
+      map_entry->ttl                             = entry->ttl;
+      map_entry->sampling_interval               = entry->sampling_interval;
+
+      /*
+       * If not static, start the expiration timers, and set up the smr timer.
+       */
+      if (map_entry->how_learned) {
+          setup_timer(&map_entry->expiry_timer, &eid_entry_expiration, (unsigned long)map_entry);
+          mod_timer(&map_entry->expiry_timer, jiffies + entry->ttl * HZ * SECS_PER_MIN);
+
+          setup_timer(&map_entry->smr_timer, &eid_entry_smr_sample, (unsigned long)map_entry);
+          // Jitter XXX
+      } else {
+          printk(KERN_INFO "Not starting expiration timer.");
+      }
+
+     /*
+      * Start the sampling timer
+      */
+      if (entry->sampling_interval) {
+          setup_timer(&map_entry->probe_timer, &eid_entry_probe_sample, (unsigned long)map_entry);
+          mod_timer(&map_entry->probe_timer, jiffies + entry->sampling_interval * HZ);
+          printk(KERN_INFO " Started probe sampling timer at %d second interval", entry->sampling_interval);
+      }
+      do_gettimeofday(&timestamp);
+      map_entry->timestamp               = timestamp.tv_sec;
+
+      printk(KERN_INFO "  Entry not found, creating new entry");
+  } else {
+    printk(KERN_INFO "  Existing entry found, replacing locator list");
+    entry_exists = 1;
+
+    // XXX NEED TO UPDATE TIMERS/TTL HERE???
+  } 
+  
+  /* 
+   * Create the locators list
+   */
+
+  // Negative cache entry??
+  if (!entry->count) {
+      map_entry->locators_present = 0;
+      for (locator_idx = 0; locator_idx < MAX_LOCATORS; locator_idx++) {
+          if (map_entry->locator_list[locator_idx]) {
+              kmem_cache_free(lisp_map_cache_loctype, map_entry->locator_list[locator_idx]);
+              map_entry->locator_list[locator_idx] = NULL;
+          }
+      }
+  } else {  // Has locators
+      map_entry->locators_present = 1;
+      for (locator_idx = 0; locator_idx < MAX_LOCATORS; locator_idx++) {
+          if (locator_idx < entry->count) {
+              add_cache_entry_locator(map_entry, (lisp_eid_map_msg_loc_t *)entry->locators,
+                                      locator_idx);
+          } else if (map_entry->locator_list[locator_idx]) {
+
+              /*
+               * Free old locators beyond what's current
+               */
+              kmem_cache_free(lisp_map_cache_loctype, map_entry->locator_list[locator_idx]);
+              map_entry->locator_list[locator_idx] = NULL;
+          }
+      }
+  }
+  map_entry->count                           = entry->count;
+
+  // Update LSBs
+  map_entry->lsb = lsb_table[map_entry->count];
+
+  // Update weight table
+  update_locator_hash_table(map_entry);
+
+  /* Insert new prefix if it doesn't exist */
+  if (!entry_exists) {
+      spin_lock_bh(&table_lock);
+      node = make_and_lookup_v4(AF4_eid_cache, entry->eid_prefix.address.ip.s_addr,
+                                entry->eid_prefix_length);
+
+      if (!node) {
+          printk(KERN_INFO " Failed to allocate EID tree node");
+          spin_unlock_bh(&table_lock);
+          return;
+      }
+      node->data = map_entry;
+      spin_unlock_bh(&table_lock);
+  }
+}
+
+/*
+ * add_eid_cache_entry_v6()
+ *
+ * Add an EID/locator mapping to the v6 map cache. Needs updating to match v4 XXX
+ */
+void add_eid_cache_entry_v6(lisp_eid_map_msg_t *entry)
+{
+  patricia_node_t        *node;
+  lisp_map_cache_t       *map_entry;
+  struct timeval          timestamp;
+  int                     locator_idx = 0;
+  int                     entry_exists = 0;
+
+  printk(KERN_INFO " Adding cache mapping: %pi6/%d\n",
+         entry->eid_prefix.address.ipv6.s6_addr,
+         entry->eid_prefix_length);
+
+  /*
+   * Check for existing entry
+   */
+  if (!lookup_eid_cache_v6_exact(entry->eid_prefix, 
+                 entry->eid_prefix_length, &map_entry)) {
+
+    map_entry = kmem_cache_alloc(lisp_map_cache, GFP_KERNEL);
+    printk(KERN_INFO "Allocating new map-cache entry from %s\n",
+	   kmem_cache_name(lisp_map_cache));
+    if (!map_entry) {
+      printk(KERN_INFO "Couldn't allocate from %s\n",
+	     kmem_cache_name(lisp_map_cache));
+      return;               /* XXX: correct? */
+    }
+    
+    memset(map_entry, 0, sizeof(lisp_map_cache_t));
+    memcpy(&map_entry->eid_prefix, &entry->eid_prefix, sizeof(lisp_addr_t));
+    map_entry->eid_prefix_length       = entry->eid_prefix_length;
+    map_entry->eid_prefix.afi          = AF_INET6;
+    map_entry->how_learned             = entry->how_learned;   
+    map_entry->ttl                     = entry->ttl;
+    map_entry->sampling_interval       = entry->sampling_interval;
+
+    /*
+     * If not static, start the timer
+     */
+    if (map_entry->how_learned) {
+      setup_timer(&map_entry->expiry_timer, &eid_entry_expiration, (unsigned long)map_entry);
+      mod_timer(&map_entry->expiry_timer, jiffies + map_entry->ttl * HZ);
+
+      // Jitter XXX
+    }
+
+    /*
+     * Start the sampling timer
+     */
+    if (entry->sampling_interval) {
+        setup_timer(&map_entry->probe_timer, &eid_entry_smr_sample, (unsigned long)map_entry);
+        mod_timer(&map_entry->probe_timer, jiffies + entry->sampling_interval * HZ * SECS_PER_MIN);
+    }
+    do_gettimeofday(&timestamp);
+    map_entry->timestamp               = timestamp.tv_sec;
+  
+    printk(KERN_INFO "  Entry not found, creating new entry");
+  } else {
+    printk(KERN_INFO "  Existing entry found, extending locator list");
+    entry_exists = 1;
+  } 
+
+  /*
+   * Create the locators list
+   */
+  // clear previous locators? XXX
+  // Negative cache entry?? XXX
+  if (!entry->count) {
+      map_entry->locators_present = 0;
+  } else {
+      map_entry->locators_present = 1;
+
+      for (locator_idx = 0; locator_idx < entry->count; locator_idx++) {
+          add_cache_entry_locator(map_entry, (lisp_eid_map_msg_loc_t *)entry->locators,
+                                  locator_idx);
+      }
+  }
+
+  map_entry->count                   = entry->count;
+  // Update LSBs??? XXX
+  // Update weight table XXX
+
+  /* Insert new entry if it doesn't exist */
+  if (!entry_exists) {
+      spin_lock_bh(&table_lock);
+      node = make_and_lookup_v6(AF6_eid_cache, entry->eid_prefix.address.ipv6,
+                                entry->eid_prefix_length);
+
+      if (!node) {
+          printk(KERN_INFO " Failed to allocate EID tree node");
+          spin_unlock_bh(&table_lock);
+          return;
+      }
+      node->data = map_entry;
+      spin_unlock_bh(&table_lock);
+  }
+}
+
+/*
+ * add_eid_cache_entry()
+ *
+ * Dispatch to the appropriate routine for the given EID address family.
+ */
+void add_eid_cache_entry(lisp_eid_map_msg_t *entry)
+{
+  switch (entry->eid_prefix.afi) {
+  case AF_INET:
+    add_eid_cache_entry_v4(entry);
+    break;
+  case AF_INET6:
+    add_eid_cache_entry_v6(entry);
+    break;
+  default:
+    printk(KERN_INFO " Unknown AF ");
+    break;
+  }
+}
+
+/*
+ * add_eid_db_entry()
+ *
+ * Dispatch to the appropriate routine for the given EID address family.
+ */
+void add_eid_db_entry(lisp_db_add_msg_t *entry)
+{
+  switch (entry->eid_prefix.afi) {
+  case AF_INET:
+    add_eid_db_entry_v4(entry);
+    break;
+  case AF_INET6:
+    add_eid_db_entry_v6(entry);
+    break;
+  default:
+    printk(KERN_INFO " Unknown AF ");
+    break;
+  }
+}
+
+/*
+ * update_locator_set_by_msg()
+ *
+ * For the EID in the returned cache sample message, go through
+ * the list of locators and mark them according to the status
+ * in the message. This is primarly as a result of RLOC probing,
+ * but could be used by any liveness detection procedure at the
+ * protocol level.
+ */
+void update_locator_set_by_msg(lisp_cache_sample_msg_t *msg) {
+    int i, j;
+    int loc_mask = 1;
+    char loc_status = 0;
+    lisp_map_cache_t      *map_entry = NULL;
+    lisp_addr_t *loc_addr;
+    lisp_map_cache_loc_t *locator = NULL;
+
+    int status;
+
+    /*
+     * Lookup the EID and get the entry for it in the cache
+     */
+     switch (msg->eid.afi) {
+     case AF_INET:
+         status = lookup_eid_cache_v4_exact(msg->eid.address.ip.s_addr, msg->eid_prefix_length,
+                                            &map_entry);
+         break;
+     case AF_INET6:
+         status = lookup_eid_cache_v6_exact(msg->eid, msg->eid_prefix_length,
+                                      &map_entry);
+         break;
+     default:
+         printk(KERN_INFO "  Unknown EID AFI %d in update_locator_set_by_msg()",
+                msg->eid.afi);
+         return;
+         break;
+     }
+
+     if (!map_entry || !status) {
+         printk(KERN_INFO "  No such EID in map cache.");
+         return;
+     }
+
+    for (i = 0; i < msg->num_locators; i++) {
+        locator = NULL;
+        loc_addr = &(msg->locators[i]);
+        loc_status = !!(msg->status_bits & loc_mask);
+        loc_mask = loc_mask << 1;
+
+        /*
+         * Match the locator to one in our entry.
+         */
+        for (j = 0; j < MAX_LOCATORS; j++) {
+            if (map_entry->locator_list[j]) {
+                if (!memcmp(&map_entry->locator_list[j]->locator,
+                            loc_addr, sizeof(lisp_addr_t))) {
+                    locator = map_entry->locator_list[j];
+                }
+            } else {
+                break;
+            }
+        }
+
+        if (!locator) {
+            if (loc_addr->afi == AF_INET) {
+                printk("  Locator %pI4 not found in cache entry, skipping.\n",
+                       &loc_addr->address.ip.s_addr);
+            } else if (loc_addr->afi == AF_INET6) {
+                printk("  Locator %pI6 not found in cache entry, skipping.\n",
+                       loc_addr->address.ipv6.s6_addr);
+            } else {
+                printk("  Unknown AFI %d for locator, skipping.\n",
+                       loc_addr->afi);
+            }
+            continue;
+        }
+
+        /*
+         * Mark the locator as up or down as the message says.
+         */
+        if (loc_addr->afi == AF_INET) {
+            printk("  Marking locator %pI4 as %s\n",
+                   &locator->locator.address.ip.s_addr,
+                   loc_status ? "up" : "down");
+        } else if (loc_addr->afi == AF_INET6) {
+            printk("  Marking locator %pI6 as %s\n",
+                   locator->locator.address.ipv6.s6_addr,
+                   loc_status ? "up" : "down");
+        }
+        locator->state = loc_status;
+    }
+    update_locator_hash_table(map_entry);
+}
+
+/*
+ * free_database_entry
+ */
+void free_database_entry(void *entry)
+{
+    lisp_database_entry_t *db_entry = (lisp_database_entry_t *)entry;
+    int i;
+
+    /*
+     * Free locators
+     */
+    for (i = 0; i < MAX_LOCATORS; i++) {
+        if (db_entry->locator_list[i] != 0) {
+            kmem_cache_free(lisp_database_loctype, db_entry->locator_list[i]);
+        }
+    }
+    kmem_cache_free(lisp_database, db_entry);
+}
+
+/*
+ * free_cache_entry
+ */
+void free_cache_entry(void *entry)
+{
+    lisp_map_cache_t       *map_entry;
+    int i;
+
+    map_entry = (lisp_map_cache_t *)entry;
+
+    /*
+     * Free locators
+     */
+    for (i = 0; i < MAX_LOCATORS; i++) {
+        if (map_entry->locator_list[i] != 0) {
+            kmem_cache_free(lisp_map_cache_loctype, map_entry->locator_list[i]);
+        }
+    }
+    if (map_entry->how_learned) {
+        del_timer(&map_entry->smr_timer);
+        del_timer(&map_entry->expiry_timer);
+    }
+    del_timer(&map_entry->probe_timer);
+    kmem_cache_free(lisp_map_cache, map_entry);
+}
+
+/*
+ * clear_map_cache()
+ *
+ * Clear the entire contents of the map cache.
+ * Could be performed, for example, when a roaming event occurs.
+ *
+ * Arguments unused. Provided to match command table.
+ */
+void clear_map_cache(lisp_cmd_t *cmd, int pid)
+{
+    patricia_node_t  *node;
+    lisp_map_cache_t *entry;
+
+    printk(KERN_INFO "Clearing map caches....");
+    spin_lock_bh(&table_lock);
+
+    PATRICIA_WALK(AF4_eid_cache->head, node) {
+       patricia_remove(AF4_eid_cache, node);
+       entry = (lisp_map_cache_t *)node->data;
+       free_cache_entry(entry);
+    } PATRICIA_WALK_END;
+
+    PATRICIA_WALK(AF6_eid_cache->head, node) {
+       patricia_remove(AF6_eid_cache, node);
+       entry = (lisp_map_cache_t *)node->data;
+       free_cache_entry(entry);
+    } PATRICIA_WALK_END;
+
+    spin_unlock_bh(&table_lock);
+    printk(KERN_INFO "Done.");
+}
+
+/*
+ * teardown_trees
+ *
+ * Remove all allocated trees and associated kernel memory
+ */
+void teardown_trees(void)
+{
+    spin_lock_bh(&table_lock);
+    Destroy_Patricia(AF4_eid_cache, free_cache_entry);
+    printk(KERN_INFO "Destroyed ipv4 EID trie\n");
+
+    Destroy_Patricia(AF6_eid_cache, free_cache_entry);
+    printk(KERN_INFO "Destroyed ipv6 EID trie\n");
+
+    Destroy_Patricia(AF4_eid_db, free_database_entry);
+    printk(KERN_INFO "Destroyed ipv4 EID db\n");
+
+    Destroy_Patricia(AF6_eid_db, free_database_entry);
+    printk(KERN_INFO "Destroyed ipv6 EID db\n");
+    spin_unlock_bh(&table_lock);
+
+    Cleanup_Patricia();
+    printk(KERN_INFO "Destroyed patricia structures\n");
+
+}
+
+/*
+ * start_traffic_monitor()
+ *
+ * Mark each cache entry as "no traffic" in preparation
+ * for traffic monitoring. If a packet comes in or goes out
+ * to the EID later then the traffic bit gets set to true.
+ */
+void start_traffic_monitor(void)
+{
+    patricia_node_t *node;
+    lisp_map_cache_t *entry;
+
+    spin_lock_bh(&table_lock);
+
+    /*
+     * Set all entries in the cache to start
+     * traffic monitoring.
+     */
+    PATRICIA_WALK(AF4_eid_cache->head, node) {
+        entry = (lisp_map_cache_t *)node->data;
+        entry->active_within_period = 0;
+        mod_timer(&entry->smr_timer, jiffies + TRAFFIC_MON_PERIOD * HZ);
+    } PATRICIA_WALK_END;
+
+    PATRICIA_WALK(AF6_eid_cache->head, node) {
+        entry = (lisp_map_cache_t *)node->data;
+        entry->active_within_period = 0;
+        mod_timer(&entry->smr_timer, jiffies + TRAFFIC_MON_PERIOD * HZ);
+    } PATRICIA_WALK_END;
+
+    printk(KERN_INFO "Marked cache entries for traffic monitoring.");
+    spin_unlock_bh(&table_lock);
+}
Index: package/lisp_mod/src/lisp_mod.h
===================================================================
--- package/lisp_mod/src/lisp_mod.h	(revision 0)
+++ package/lisp_mod/src/lisp_mod.h	(revision 0)
@@ -0,0 +1,62 @@
+/*
+ * lisp_mod.h
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Declarations and constants for the LISP kernel module.
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    Chris White       <chris@logicalelegance.com>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+#pragma once
+
+#include "linux/module.h"	
+#include "linux/kernel.h"
+#include "linux/netfilter.h"
+#include "linux/netfilter_ipv4.h"
+#include "linux/netlink.h"
+#include "net/net_namespace.h"
+#include "tables.h"
+#include "lisp_ipc.h"
+#include "lisp_ipc_kernel.h"
+#include "lisp_input.h"
+#include "lisp_output.h"
+#include "lisp_slab.h"
+#include "lib/patricia/patricia.h"
+
+#define NETLINK_LISP 20  /* XXX Temporary, needs to be in /usr/include/linux/netlink.h */
+
+typedef struct {
+  struct sock *nl_socket;       /* Netlink socket */
+  struct nf_hook_ops netfilter_ops_in;  /* Netfilter hook definition, input */
+  struct nf_hook_ops netfilter_ops_out; /* Netfilter hook definition, output */
+  struct nf_hook_ops netfilter_ops_out6; /* "" For ipv6 */
+  int    always_encap;         /* Always LISP encapsulate? */
+  lisp_addr_t my_rloc; /* Locally generated packets source RLOC, set via command-line */
+  ushort my_rloc_af;
+  ushort udp_encap_port;
+  ushort udp_control_port;
+  int   daemonPID; /* Process ID for lispd */
+} lisp_globals;
+
Index: package/lisp_mod/src/lisp_slab.h
===================================================================
--- package/lisp_mod/src/lisp_slab.h	(revision 0)
+++ package/lisp_mod/src/lisp_slab.h	(revision 0)
@@ -0,0 +1,43 @@
+/* 
+ * lisp_slab.h 
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Main entry point and initialization code
+ * for the LISP kernel module.
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    David Meyer	<dmm@cisco.com>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+#define	USE_LISP_SLAB_ALLOCATOR
+
+#ifdef USE_LISP_SLAB_ALLOCATOR
+extern struct kmem_cache *lisp_map_cache;		/* map cache */
+extern struct kmem_cache *lisp_map_cache_loctype;	/* mc locators */
+extern struct kmem_cache *lisp_database;		/* database */
+extern struct kmem_cache *lisp_database_loctype;	/* db locators */
+
+int init_lisp_caches(void);
+void delete_lisp_caches(void);
+#endif
Index: package/lisp_mod/src/tables.h
===================================================================
--- package/lisp_mod/src/tables.h	(revision 0)
+++ package/lisp_mod/src/tables.h	(revision 0)
@@ -0,0 +1,144 @@
+/*
+ * tables.h
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Support and storage declarations for LISP EID maps and other
+ * tables.
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    Chris White       <chris@logicalelegance.com>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+#pragma once
+
+#include "linux/timer.h"
+#include "lib/patricia/patricia.h"
+#include "lisp_ipc.h"
+
+#define TRAFFIC_MON_PERIOD (15)
+
+/*
+ * Table externs
+ */
+extern patricia_tree_t *AF4_eid_cache;
+extern patricia_tree_t *AF6_eid_cache;
+
+extern patricia_tree_t *AF4_eid_db;
+extern patricia_tree_t *AF6_eid_db;
+
+
+/******************************************
+ * Map Cache Definitions
+ ******************************************/
+
+/*
+ * Locator structure definition
+ */
+typedef struct _lisp_map_cache_loctype {
+  lisp_addr_t   locator;
+  uint8_t       priority;
+  uint8_t       weight;
+  uint8_t       mpriority;
+  uint8_t       mweight;
+  uint8_t       reachability_alg:2; /* rloc_prob | echo_none */
+  uint8_t       state:1;            /* 1: up, 0: down */
+  uint8_t       reserved:5; 
+  uint32_t      data_packets_in;
+  uint32_t      data_packets_out;
+} lisp_map_cache_loc_t;
+
+/*
+ * EID Map cache entry
+ */
+#define MAX_LOCATORS 8
+#define LOC_HASH_SIZE 25
+
+typedef struct _lisp_map_cache_t {
+  lisp_addr_t             eid_prefix;         /* EID Prefix */
+  uint8_t                 eid_prefix_length;  /* length */
+  uint8_t                 how_learned:1;      /* 0: static or 1: map-reply */
+  uint8_t                 actions:2;           /* Defined in lisp_ipc.h */
+  uint8_t                 locators_present:1; /* No locators: negative cache entry */
+  uint8_t                 active_within_period:1; /* Traffic was tx/rx during monitor period */
+  uint8_t                 reserved:3;         /* */
+  uint32_t                nonce0;             /* 64 bit nonce */
+  uint32_t                nonce1;             /*  "" */
+  ushort                  ttl;                /* ttl for the whole mapping */
+  uint32_t                sampling_interval;    /* how often to send a copy to lispd */
+  uint32_t                timestamp;          /* entry creation time */
+  struct timer_list       expiry_timer;       /* Expiration kernel timer */
+  struct timer_list       smr_timer;       /* Sample to user space timer for SMR */
+  struct timer_list       probe_timer;     /* Sample to user space timer for RLOC Probe */
+  uint32_t                control_packets_in; 
+  uint32_t                control_packets_out;
+  uint32_t                lsb;                /* Locator status bits */
+  uint32_t                count;
+  lisp_map_cache_loc_t   *locator_list[MAX_LOCATORS];
+  char                    locator_hash_table[25];
+} lisp_map_cache_t;
+
+
+/******************************************
+ * Map Database Definitions
+ ******************************************/
+
+typedef struct _lisp_database_loc_t {
+   lisp_addr_t    	locator;
+   uint8_t		priority;
+   uint8_t		weight;
+   uint8_t		mpriority;
+   uint8_t		mweight;
+   uint8_t		state:4;		/* e.g., up, local */
+   uint8_t		reserved:4;
+} lisp_database_loc_t;
+
+typedef struct _lisp_database_entry_t {
+  lisp_addr_t    	  eid_prefix;		/* eid prefix */
+   uint32_t	          eid_prefix_length;	/* length */
+   ushort		  lsb;			/* local locator status bits */
+   uint32_t		  timestamp;		/* when entry was created */
+   int                    count;
+   lisp_database_loc_t *locator_list[MAX_LOCATORS];		/* locators */
+} lisp_database_entry_t;
+
+/*
+ * Function declarations
+ */
+void create_tables(void);
+void add_eid_cache_entry(lisp_eid_map_msg_t *entry);
+void update_locator_hash_table(lisp_map_cache_t *entry);
+void del_eid_cache_entry(lisp_addr_t prefix, int prefixlen);
+void add_eid_db_entry(lisp_db_add_msg_t *entry);
+int lookup_eid_cache_v4(int, lisp_map_cache_t **);
+int lookup_eid_cache_v4_exact(int eid, int prefixlen, lisp_map_cache_t **entry);
+int lookup_eid_cache_v6_exact(lisp_addr_t eid_prefix, int prefixlen, lisp_map_cache_t **entry);
+int lookup_eid_cache_v6(lisp_addr_t, lisp_map_cache_t **);
+int lookup_eid_db_v4(int, lisp_database_entry_t **);
+lisp_map_cache_loc_t *get_locator_for_eid(lisp_addr_t *, ushort *,
+					  lisp_map_cache_t *);
+void start_traffic_monitor(void);
+void finish_traffic_monitor(unsigned long);
+void update_locator_set_by_msg(lisp_cache_sample_msg_t *);
+void clear_map_cache(lisp_cmd_t *cmd, int pid);
+void teardown_trees(void);
Index: package/lisp_mod/src/lib/patricia/test.c
===================================================================
--- package/lisp_mod/src/lib/patricia/test.c	(revision 0)
+++ package/lisp_mod/src/lib/patricia/test.c	(revision 0)
@@ -0,0 +1,71 @@
+/*
+ * test.c
+ * 
+ * Simple test for patricia tree library.
+ */
+
+/*
+ * $Id: demo.c,v 1.4 2005/12/07 20:55:52 dplonka Exp $
+ *
+ * This is based on "demo.c" provided with MRT-2.2.2a.
+ */
+
+#include "patricia.h"
+#include <stdio.h> /* printf */
+#include <stdlib.h> /* exit */
+
+void func(prefix_t *prefix) {
+    printf("node: %s/%d\n", prefix_toa(prefix), prefix->bitlen);
+}
+
+int
+main(void)
+{
+    prefix_t *prefix;
+    patricia_tree_t *tree;
+    patricia_node_t *node;
+
+    tree = New_Patricia(32);
+
+    make_and_lookup(tree, "127.0.0.0/8");
+
+    try_search_best(tree, "127.0.0.1");
+    try_search_best(tree, "10.0.0.1");
+
+    make_and_lookup(tree, "10.42.42.0/24");
+    make_and_lookup(tree, "10.42.69.0/24");
+    make_and_lookup(tree, "10.0.0.0/8");
+    make_and_lookup(tree, "10.0.0.0/9");
+
+    try_search_best(tree, "10.42.42.0/24");
+    try_search_best(tree, "10.10.10.10");
+    try_search_best(tree, "10.10.10.1");
+    try_search_exact(tree, "10.0.0.0");
+    try_search_exact(tree, "10.0.0.0/8");
+
+#if 0
+    PATRICIA_WALK(tree->head, node) {
+       printf("node: %s/%d\n", 
+              prefix_toa(node->prefix), node->prefix->bitlen);
+    } PATRICIA_WALK_END;
+#else
+    printf("%u total nodes.\n", patricia_walk_inorder(tree->head, func));
+#endif
+
+    lookup_then_remove(tree, "42.0.0.0/8");
+    lookup_then_remove(tree, "10.0.0.0/8");
+    try_search_exact(tree, "10.0.0.0");
+
+#if 0
+    PATRICIA_WALK(tree->head, node) {
+       printf("node: %s/%d\n", 
+              prefix_toa(node->prefix), node->prefix->bitlen);
+    } PATRICIA_WALK_END;
+#else
+    printf("%u total nodes.\n", patricia_walk_inorder(tree->head, func));
+#endif
+
+    Destroy_Patricia(tree, (void *)0);
+
+    exit(0);
+}
Index: package/lisp_mod/src/lib/patricia/patricia.h
===================================================================
--- package/lisp_mod/src/lib/patricia/patricia.h	(revision 0)
+++ package/lisp_mod/src/lib/patricia/patricia.h	(revision 0)
@@ -0,0 +1,156 @@
+/*
+ * $Id: patricia.h,v 1.6 2005/12/07 20:53:01 dplonka Exp $
+ * Dave Plonka <plonka@doit.wisc.edu>
+ *
+ * This product includes software developed by the University of Michigan,
+ * Merit Network, Inc., and their contributors. 
+ *
+ * This file had been called "radix.h" in the MRT sources.
+ *
+ * I renamed it to "patricia.h" since it's not an implementation of a general
+ * radix trie.  Also, pulled in various requirements from "mrt.h" and added
+ * some other things it could be used as a standalone API.
+ */
+
+#ifndef _PATRICIA_H
+#define _PATRICIA_H
+
+#define HAVE_IPV6
+
+typedef void (*void_fn_t)();
+
+/* { from defs.h */
+#define prefix_touchar(prefix) ((u_char *)&(prefix)->add.sin)
+#define MAXLINE 1024
+#define BIT_TEST(f, b)  ((f) & (b))
+/* } */
+
+#define addroute make_and_lookup
+
+#include <linux/in.h> /* for struct in_addr */
+#include <linux/inet.h>
+
+#ifdef HAVE_IPV6
+#include <linux/in6.h>
+#endif
+
+#include <linux/string.h>
+#include <linux/socket.h> /* for AF_INET */
+#include <linux/errno.h>
+#include <linux/ctype.h>
+#include <linux/netfilter.h>
+
+#ifdef __KERNEL__
+#include <linux/vmalloc.h>
+#endif
+
+/* { from mrt.h */
+
+typedef struct _prefix4_t {
+    u_short family;		/* AF_INET | AF_INET6 */
+    u_short bitlen;		/* same as mask? */
+    int ref_count;		/* reference count */
+    struct in_addr sin;
+} prefix4_t;
+
+typedef struct _prefix_t {
+    u_short family;		/* AF_INET | AF_INET6 */
+    u_short bitlen;		/* same as mask? */
+    int ref_count;		/* reference count */
+    union {
+		struct in_addr sin;
+#ifdef HAVE_IPV6
+		struct in6_addr sin6;
+#endif /* IPV6 */
+    } add;
+} prefix_t;
+
+/* } */
+
+typedef struct _patricia_node_t {
+   u_int bit;			/* flag if this node used */
+   prefix_t *prefix;		/* who we are in patricia tree */
+   struct _patricia_node_t *l, *r;	/* left and right children */
+   struct _patricia_node_t *parent;/* may be used */
+   void *data;			/* pointer to data */
+   void	*user1;			/* pointer to usr data (ex. route flap info) */
+} patricia_node_t;
+
+typedef struct _patricia_tree_t {
+   patricia_node_t 	*head;
+   u_int		maxbits;	/* for IP, 32 bit addresses */
+   int num_active_node;		/* for debug purpose */
+} patricia_tree_t;
+
+size_t patricia_walk_inorder(patricia_node_t *node, void_fn_t func);
+patricia_node_t *patricia_search_exact (patricia_tree_t *patricia, prefix_t *prefix);
+patricia_node_t *patricia_search_best (patricia_tree_t *patricia, prefix_t *prefix);
+patricia_node_t * patricia_search_best2 (patricia_tree_t *patricia, prefix_t *prefix, 
+				   int inclusive);
+patricia_node_t *patricia_lookup (patricia_tree_t *patricia, prefix_t *prefix);
+void patricia_remove (patricia_tree_t *patricia, patricia_node_t *node);
+patricia_tree_t *New_Patricia (int maxbits);
+void Clear_Patricia (patricia_tree_t *patricia, void_fn_t func);
+void Destroy_Patricia (patricia_tree_t *patricia, void_fn_t func);
+void Cleanup_Patricia(void);
+void patricia_process (patricia_tree_t *patricia, void_fn_t func);
+
+/* { from demo.c */
+
+prefix_t *
+ascii2prefix (int family, char *string);
+
+patricia_node_t *
+make_and_lookup_v4 (patricia_tree_t *tree, ulong prefix, int prefixlen);
+patricia_node_t *
+make_and_lookup_v6 (patricia_tree_t *tree, struct in6_addr, int prefixlen);
+/* } */
+
+#define PATRICIA_MAXBITS	(sizeof(struct in6_addr) * 8)
+#define PATRICIA_NBIT(x)        (0x80 >> ((x) & 0x7f))
+#define PATRICIA_NBYTE(x)       ((x) >> 3)
+
+#define PATRICIA_DATA_GET(node, type) (type *)((node)->data)
+#define PATRICIA_DATA_SET(node, value) ((node)->data = (void *)(value))
+
+#define PATRICIA_WALK(Xhead, Xnode) \
+    do { \
+        patricia_node_t *Xstack[PATRICIA_MAXBITS+1]; \
+        patricia_node_t **Xsp = Xstack; \
+        patricia_node_t *Xrn = (Xhead); \
+        while ((Xnode = Xrn)) { \
+            if (Xnode->prefix)
+
+#define PATRICIA_WALK_ALL(Xhead, Xnode) \
+do { \
+        patricia_node_t *Xstack[PATRICIA_MAXBITS+1]; \
+        patricia_node_t **Xsp = Xstack; \
+        patricia_node_t *Xrn = (Xhead); \
+        while ((Xnode = Xrn)) { \
+	    if (1)
+
+#define PATRICIA_WALK_BREAK { \
+	    if (Xsp != Xstack) { \
+		Xrn = *(--Xsp); \
+	     } else { \
+		Xrn = (patricia_node_t *) 0; \
+	    } \
+	    continue; }
+
+#define PATRICIA_WALK_END \
+            if (Xrn->l) { \
+                if (Xrn->r) { \
+                    *Xsp++ = Xrn->r; \
+                } \
+                Xrn = Xrn->l; \
+            } else if (Xrn->r) { \
+                Xrn = Xrn->r; \
+            } else if (Xsp != Xstack) { \
+                Xrn = *(--Xsp); \
+            } else { \
+                Xrn = (patricia_node_t *) 0; \
+            } \
+        } \
+    } while (0)
+
+#endif /* _PATRICIA_H */
Index: package/lisp_mod/src/lib/patricia/copyright
===================================================================
--- package/lisp_mod/src/lib/patricia/copyright	(revision 0)
+++ package/lisp_mod/src/lib/patricia/copyright	(revision 0)
@@ -0,0 +1,34 @@
+Copyright (c) 1997, 1998, 1999
+
+
+The Regents of the University of Michigan ("The Regents") and Merit Network,
+Inc.  All rights reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1.  Redistributions of source code must retain the above 
+    copyright notice, this list of conditions and the 
+    following disclaimer.
+2.  Redistributions in binary form must reproduce the above 
+    copyright notice, this list of conditions and the 
+    following disclaimer in the documentation and/or other 
+    materials provided with the distribution.
+3.  All advertising materials mentioning features or use of 
+    this software must display the following acknowledgement:  
+This product includes software developed by the University of Michigan, Merit
+Network, Inc., and their contributors. 
+4.  Neither the name of the University, Merit Network, nor the
+    names of their contributors may be used to endorse or 
+    promote products derived from this software without 
+    specific prior written permission.
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS" AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  
+
+
Index: package/lisp_mod/src/lib/patricia/patricia.c
===================================================================
--- package/lisp_mod/src/lib/patricia/patricia.c	(revision 0)
+++ package/lisp_mod/src/lib/patricia/patricia.c	(revision 0)
@@ -0,0 +1,984 @@
+/*
+ * $Id: patricia.c,v 1.7 2005/12/07 20:46:41 dplonka Exp $
+ * Dave Plonka <plonka@doit.wisc.edu>
+ *
+ * This product includes software developed by the University of Michigan,
+ * Merit Network, Inc., and their contributors. 
+ *
+ * This file had been called "radix.c" in the MRT sources.
+ *
+ * I renamed it to "patricia.c" since it's not an implementation of a general
+ * radix trie.  Also I pulled in various requirements from "prefix.c" and
+ * "demo.c" so that it could be used as a standalone API.
+ */
+
+static char copyright[] =
+"This product includes software developed by the University of Michigan, Merit"
+"Network, Inc., and their contributors.";
+
+#include "patricia.h"
+
+int errno = 0;
+
+/* kernel memory caches */
+static struct kmem_cache *prefix_cache;    /* prefix memory pool */
+static struct kmem_cache *node_cache;       /* node memory pool */
+
+#ifdef __KERNEL__
+#define assert(_x) { \
+  if (!(_x)) { \
+    printk(KERN_INFO "patricia tree assertion failed at %s:%d", __FILE__, __LINE__); } \
+  } 
+#endif /* __KERNEL __ */
+
+/* { from prefix.c */
+
+/* prefix_tochar
+ * convert prefix information to bytes
+ */
+u_char *
+prefix_tochar (prefix_t * prefix)
+{
+    if (prefix == NULL)
+	return (NULL);
+
+    return ((u_char *) & prefix->add.sin);
+}
+
+int 
+comp_with_mask (void *addr, void *dest, u_int mask)
+{
+
+    if ( /* mask/8 == 0 || */ memcmp (addr, dest, mask / 8) == 0) {
+	int n = mask / 8;
+	int m = ((-1) << (8 - (mask % 8)));
+
+	if (mask % 8 == 0 || (((u_char *)addr)[n] & m) == (((u_char *)dest)[n] & m))
+	    return (1);
+    }
+    return (0);
+}
+
+/* inet_pton substitute implementation
+ * Uses inet_addr to convert an IP address in dotted decimal notation into 
+ * unsigned long and copies the result to dst.
+ * Only supports AF_INET.  Follows standard error return conventions of 
+ * inet_pton.
+ */
+int
+inet_pton (int af, const char *src, void *dst)
+{
+    u_long result;  
+
+    if (af == AF_INET) {
+      result = in4_pton(src, strlen(src), dst, -1, NULL);
+	if (result == -1)
+	    return 0;
+	else {
+	    memcpy (dst, &result, sizeof(struct in_addr));
+	    return 1;
+	}
+    }
+#ifndef NT
+    else {
+
+	errno = EAFNOSUPPORT;
+	return -1;
+    }
+#endif /* NT */
+}
+
+/* this allows incomplete prefix */
+int
+my_inet_pton (int af, const char *src, void *dst)
+{
+    if (af == AF_INET) {
+        int i, c, val;
+        u_char xp[sizeof(struct in_addr)] = {0, 0, 0, 0};
+
+        for (i = 0; ; i++) {
+	    c = *src++;
+	    if (!isdigit (c))
+		return (-1);
+	    val = 0;
+	    do {
+		val = val * 10 + c - '0';
+		if (val > 255)
+		    return (0);
+		c = *src++;
+	    } while (c && isdigit (c));
+            xp[i] = val;
+	    if (c == '\0')
+		break;
+            if (c != '.')
+                return (0);
+	    if (i >= 3)
+		return (0);
+        }
+	memcpy (dst, xp, sizeof(struct in_addr));
+        return (1);
+#ifdef HAVE_IPV6
+    } else if (af == AF_INET6) {
+        return (inet_pton (af, src, dst));
+#endif /* HAVE_IPV6 */
+    } else {
+#ifndef NT
+	errno = EAFNOSUPPORT;
+#endif /* NT */
+	return -1;
+    }
+}
+
+#define PATRICIA_MAX_THREADS		16
+
+/* 
+ * convert prefix information to ascii string with length
+ * thread safe and (almost) re-entrant implementation
+ */
+char *
+prefix_toa2x (prefix_t *prefix, char *buff, int with_len)
+{
+    if (prefix == NULL)
+	return ("(Null)");
+    assert(prefix->ref_count >= 0);
+    if (buff == NULL) {
+
+        struct buffer {
+            char buffs[PATRICIA_MAX_THREADS][48+5];
+            u_int i;
+        } *buffp;
+
+#    if 0
+	THREAD_SPECIFIC_DATA (struct buffer, buffp, 1);
+#    else
+        { /* for scope only */
+	   static struct buffer local_buff;
+           buffp = &local_buff;
+	}
+#    endif
+	if (buffp == NULL) {
+	    /* XXX should we report an error? */
+	    return (NULL);
+	}
+
+	buff = buffp->buffs[buffp->i++%PATRICIA_MAX_THREADS];
+    }
+    if (prefix->family == AF_INET) {
+	u_char *a;
+	assert(prefix->bitlen <= sizeof(struct in_addr) * 8);
+	a = prefix_touchar (prefix);
+	if (with_len) {
+	    sprintf (buff, "%d.%d.%d.%d/%d", a[0], a[1], a[2], a[3],
+		     prefix->bitlen);
+	}
+	else {
+	    sprintf (buff, "%d.%d.%d.%d", a[0], a[1], a[2], a[3]);
+	}
+	return (buff);
+    }
+    else
+	return (NULL);
+}
+
+/* prefix_toa2
+ * convert prefix information to ascii string
+ */
+char *
+prefix_toa2 (prefix_t *prefix, char *buff)
+{
+    return (prefix_toa2x (prefix, buff, 0));
+}
+
+/* prefix_toa
+ */
+char *
+prefix_toa (prefix_t * prefix)
+{
+    return (prefix_toa2 (prefix, (char *) NULL));
+}
+
+prefix_t *
+New_Prefix2 (int family, void *dest, int bitlen, prefix_t *prefix)
+{
+    int dynamic_allocated = 0;
+    int default_bitlen = sizeof(struct in_addr) * 8;
+    
+    printk(KERN_INFO " ... In New_Prefix2()");
+    if (family == AF_INET6) {
+        default_bitlen = sizeof(struct in6_addr) * 8;
+	if (prefix == NULL) {
+          prefix = kmem_cache_alloc(prefix_cache, GFP_ATOMIC);
+	  dynamic_allocated++;
+	}
+	memcpy (&prefix->add.sin6, dest, sizeof(struct in6_addr));
+    }
+    else
+    if (family == AF_INET) {
+	if (prefix == NULL) {
+          prefix = kmem_cache_alloc(prefix_cache, GFP_ATOMIC);
+	  dynamic_allocated++;
+	}
+	memcpy (&prefix->add.sin, dest, sizeof(struct in_addr));
+    }
+    else {
+        return (NULL);
+    }
+
+    prefix->bitlen = (bitlen >= 0)? bitlen: default_bitlen;
+    prefix->family = family;
+    prefix->ref_count = 0;
+    if (dynamic_allocated) {
+        prefix->ref_count++;
+   }
+    return (prefix);
+}
+
+prefix_t *
+New_Prefix (int family, void *dest, int bitlen)
+{
+    return (New_Prefix2 (family, dest, bitlen, NULL));
+}
+
+#ifndef __KERNEL__
+/* ascii2prefix
+ */
+prefix_t *
+ascii2prefix (int family, char *string)
+{
+    u_long bitlen, maxbitlen = 0;
+    char *cp;
+    struct in_addr sin;
+#ifdef HAVE_IPV6
+    struct in6_addr sin6;
+#endif /* HAVE_IPV6 */
+    int result;
+    char save[MAXLINE];
+
+    if (string == NULL)
+	return (NULL);
+
+    /* easy way to handle both families */
+    if (family == 0) {
+       family = AF_INET;
+#ifdef HAVE_IPV6
+       if (strchr (string, ':')) family = AF_INET6;
+#endif /* HAVE_IPV6 */
+    }
+
+    if (family == AF_INET) {
+	maxbitlen = sizeof(struct in_addr) * 8;
+    }
+#ifdef HAVE_IPV6
+    else if (family == AF_INET6) {
+	maxbitlen = sizeof(struct in6_addr) * 8;
+    }
+#endif /* HAVE_IPV6 */
+
+    if ((cp = strchr (string, '/')) != NULL) {
+	bitlen = atol (cp + 1);
+	/* *cp = '\0'; */
+	/* copy the string to save. Avoid destroying the string */
+	assert(cp - string < MAXLINE);
+	memcpy (save, string, cp - string);
+	save[cp - string] = '\0';
+	string = save;
+	if (bitlen < 0 || bitlen > maxbitlen)
+	    bitlen = maxbitlen;
+	}
+	else {
+	    bitlen = maxbitlen;
+	}
+
+	if (family == AF_INET) {
+	    if ((result = my_inet_pton (AF_INET, string, &sin)) <= 0)
+		return (NULL);
+	    return (New_Prefix (AF_INET, &sin, bitlen));
+	}
+}
+#endif
+
+prefix_t *
+Ref_Prefix (prefix_t * prefix)
+{
+    if (prefix == NULL)
+	return (NULL);
+    if (prefix->ref_count == 0) {
+	/* make a copy in case of a static prefix */
+        return (New_Prefix2 (prefix->family, &prefix->add, prefix->bitlen, NULL));
+    }
+    prefix->ref_count++;
+/* fprintf(stderr, "[A %s, %d]\n", prefix_toa (prefix), prefix->ref_count); */
+    return (prefix);
+}
+
+void 
+Deref_Prefix (prefix_t * prefix)
+{
+    if (prefix == NULL)
+	return;
+    /* for secure programming, raise an assert. no static prefix can call this */
+    assert(prefix->ref_count > 0);
+    printk("  Prefix has ref_count %d\n", prefix->ref_count);
+    prefix->ref_count--;
+    assert(prefix->ref_count >= 0);
+    if (prefix->ref_count <= 0) {
+      kmem_cache_free(prefix_cache, prefix);
+      return;
+    }
+}
+
+/* } */
+
+/* #define PATRICIA_DEBUG 1 */
+
+static int num_active_patricia = 0;
+static int caches_inited = 0;
+
+/* these routines support continuous mask only */
+void Cleanup_Patricia(void)
+{
+    if (caches_inited) {
+        kmem_cache_destroy(prefix_cache);
+        kmem_cache_destroy(node_cache);
+    }
+}
+
+patricia_tree_t *
+New_Patricia (int maxbits)
+{
+  
+  patricia_tree_t *patricia;
+
+  if (sizeof(patricia_tree_t) <= PAGE_SIZE) { 
+    patricia = kzalloc(sizeof(patricia_tree_t), GFP_KERNEL);
+  } else {
+    patricia = __vmalloc(sizeof(patricia_tree_t), GFP_KERNEL | __GFP_ZERO, PAGE_KERNEL);
+  }
+  
+  if (!patricia) {
+    printk(KERN_WARNING "Unable to allocate memory for patricia trie");
+    return (NULL);
+  }
+  patricia->maxbits = maxbits;
+  patricia->head = NULL;
+  patricia->num_active_node = 0;
+  assert(maxbits <= PATRICIA_MAXBITS); /* XXX */
+  num_active_patricia++;
+
+  if (!caches_inited) {
+    prefix_cache = kmem_cache_create("prefix_cache",
+				     sizeof(prefix_t),
+				     0,
+				     SLAB_HWCACHE_ALIGN,
+				     NULL);
+    if (!prefix_cache) {
+      printk(KERN_INFO "Couldn't create prefix cache");
+      return(NULL);
+    }
+    
+    node_cache = kmem_cache_create("node_cache",
+				   sizeof(patricia_node_t),
+				   0,
+				   SLAB_HWCACHE_ALIGN,
+				   NULL);
+    
+    if (!node_cache) {
+      printk(KERN_INFO "Couldn't create node cache");
+      return(NULL);
+    }
+    caches_inited = 1;
+  }
+  return (patricia);
+}
+
+/*
+ * if func is supplied, it will be called as func(node->data)
+ * before deleting the node
+ */
+
+void
+Clear_Patricia (patricia_tree_t *patricia, void_fn_t func)
+{
+    assert(patricia);
+    if (patricia->head) {
+
+        patricia_node_t *Xstack[PATRICIA_MAXBITS+1];
+        patricia_node_t **Xsp = Xstack;
+        patricia_node_t *Xrn = patricia->head;
+
+        while (Xrn) {
+            patricia_node_t *l = Xrn->l;
+            patricia_node_t *r = Xrn->r;
+
+    	    if (Xrn->prefix) {
+		Deref_Prefix (Xrn->prefix);
+		if (Xrn->data && func)
+	    	    func (Xrn->data);
+    	    }
+    	    else {
+		assert(Xrn->data == NULL);
+    	    }
+	    kmem_cache_free(node_cache, Xrn);
+	    patricia->num_active_node--;
+
+            if (l) {
+                if (r) {
+                    *Xsp++ = r;
+                }
+                Xrn = l;
+            } else if (r) {
+                Xrn = r;
+            } else if (Xsp != Xstack) {
+                Xrn = *(--Xsp);
+            } else {
+                Xrn = NULL;
+            }
+        }
+    }
+    assert(patricia->num_active_node == 0);
+}
+
+
+void
+Destroy_Patricia (patricia_tree_t *patricia, void_fn_t func)
+{
+    Clear_Patricia (patricia, func);
+    if (sizeof(patricia_tree_t) <= PAGE_SIZE) {
+      kfree(patricia);
+    } else { 
+      vfree(patricia);
+    }
+    num_active_patricia--;
+}
+
+
+/*
+ * if func is supplied, it will be called as func(node->prefix, node->data)
+ */
+
+void
+patricia_process (patricia_tree_t *patricia, void_fn_t func)
+{
+    patricia_node_t *node;
+    assert(func);
+
+    PATRICIA_WALK (patricia->head, node) {
+	func (node->prefix, node->data);
+    } PATRICIA_WALK_END;
+}
+
+size_t
+patricia_walk_inorder(patricia_node_t *node, void_fn_t func)
+{
+    size_t n = 0;
+    assert(func);
+
+    if (node->l) {
+         n += patricia_walk_inorder(node->l, func);
+    }
+
+    if (node->prefix) {
+	func(node->prefix, node->data);
+	n++;
+    }
+	
+    if (node->r) {
+         n += patricia_walk_inorder(node->r, func);
+    }
+
+    return n;
+}
+
+
+patricia_node_t *
+patricia_search_exact (patricia_tree_t *patricia, prefix_t *prefix)
+{
+    patricia_node_t *node;
+    u_char *addr;
+    u_int bitlen;
+
+    assert(patricia);
+    assert(prefix);
+    assert(prefix->bitlen <= patricia->maxbits);
+
+    if (patricia->head == NULL)
+	return (NULL);
+
+    node = patricia->head;
+    addr = prefix_touchar (prefix);
+    bitlen = prefix->bitlen;
+
+    while (node->bit < bitlen) {
+
+	if (BIT_TEST (addr[node->bit >> 3], 0x80 >> (node->bit & 0x07))) {
+#ifdef PATRICIA_DEBUG
+	    if (node->prefix)
+    	        fprintf (stderr, "patricia_search_exact: take right %s/%d\n", 
+	                 prefix_toa (node->prefix), node->prefix->bitlen);
+	    else
+    	        fprintf (stderr, "patricia_search_exact: take right at %u\n", 
+			 node->bit);
+#endif /* PATRICIA_DEBUG */
+	    node = node->r;
+	}
+	else {
+#ifdef PATRICIA_DEBUG
+	    if (node->prefix)
+    	        fprintf (stderr, "patricia_search_exact: take left %s/%d\n", 
+	                 prefix_toa (node->prefix), node->prefix->bitlen);
+	    else
+    	        fprintf (stderr, "patricia_search_exact: take left at %u\n", 
+			 node->bit);
+#endif /* PATRICIA_DEBUG */
+	    node = node->l;
+	}
+
+	if (node == NULL)
+	    return (NULL);
+    }
+
+#ifdef PATRICIA_DEBUG
+    if (node->prefix)
+        fprintf (stderr, "patricia_search_exact: stop at %s/%d\n", 
+	         prefix_toa (node->prefix), node->prefix->bitlen);
+    else
+        fprintf (stderr, "patricia_search_exact: stop at %u\n", node->bit);
+#endif /* PATRICIA_DEBUG */
+    if (node->bit > bitlen || node->prefix == NULL)
+	return (NULL);
+    assert(node->bit == bitlen);
+    assert(node->bit == node->prefix->bitlen);
+    if (comp_with_mask (prefix_tochar (node->prefix), prefix_tochar (prefix),
+			bitlen)) {
+#ifdef PATRICIA_DEBUG
+        fprintf (stderr, "patricia_search_exact: found %s/%d\n", 
+	         prefix_toa (node->prefix), node->prefix->bitlen);
+#endif /* PATRICIA_DEBUG */
+	return (node);
+    }
+    return (NULL);
+}
+
+
+/* if inclusive != 0, "best" may be the given prefix itself */
+patricia_node_t *
+patricia_search_best2 (patricia_tree_t *patricia, prefix_t *prefix, int inclusive)
+{
+    patricia_node_t *node;
+    patricia_node_t *stack[PATRICIA_MAXBITS + 1];
+    u_char *addr;
+    u_int bitlen;
+    int cnt = 0;
+
+    assert(patricia);
+    assert(prefix);
+    assert(prefix->bitlen <= patricia->maxbits);
+
+    if (patricia->head == NULL)
+	return (NULL);
+
+    node = patricia->head;
+    addr = prefix_touchar (prefix);
+    bitlen = prefix->bitlen;
+
+    while (node->bit < bitlen) {
+
+	if (node->prefix) {
+#ifdef PATRICIA_DEBUG
+            fprintf (stderr, "patricia_search_best: push %s/%d\n", 
+	             prefix_toa (node->prefix), node->prefix->bitlen);
+#endif /* PATRICIA_DEBUG */
+	    stack[cnt++] = node;
+	}
+
+	if (BIT_TEST (addr[node->bit >> 3], 0x80 >> (node->bit & 0x07))) {
+#ifdef PATRICIA_DEBUG
+	    if (node->prefix)
+    	        fprintf (stderr, "patricia_search_best: take right %s/%d\n", 
+	                 prefix_toa (node->prefix), node->prefix->bitlen);
+	    else
+    	        fprintf (stderr, "patricia_search_best: take right at %u\n", 
+			 node->bit);
+#endif /* PATRICIA_DEBUG */
+	    node = node->r;
+	}
+	else {
+#ifdef PATRICIA_DEBUG
+	    if (node->prefix)
+    	        fprintf (stderr, "patricia_search_best: take left %s/%d\n", 
+	                 prefix_toa (node->prefix), node->prefix->bitlen);
+	    else
+    	        fprintf (stderr, "patricia_search_best: take left at %u\n", 
+			 node->bit);
+#endif /* PATRICIA_DEBUG */
+	    node = node->l;
+	}
+
+	if (node == NULL)
+	    break;
+    }
+
+    if (inclusive && node && node->prefix)
+	stack[cnt++] = node;
+
+#ifdef PATRICIA_DEBUG
+    if (node == NULL)
+        fprintf (stderr, "patricia_search_best: stop at null\n");
+    else if (node->prefix)
+        fprintf (stderr, "patricia_search_best: stop at %s/%d\n", 
+	         prefix_toa (node->prefix), node->prefix->bitlen);
+    else
+        fprintf (stderr, "patricia_search_best: stop at %u\n", node->bit);
+#endif /* PATRICIA_DEBUG */
+
+    if (cnt <= 0)
+	return (NULL);
+
+    while (--cnt >= 0) {
+	node = stack[cnt];
+#ifdef PATRICIA_DEBUG
+        fprintf (stderr, "patricia_search_best: pop %s/%d\n", 
+	         prefix_toa (node->prefix), node->prefix->bitlen);
+#endif /* PATRICIA_DEBUG */
+	if (comp_with_mask (prefix_tochar (node->prefix), 
+			    prefix_tochar (prefix),
+			    node->prefix->bitlen) && node->prefix->bitlen <= bitlen) {
+#ifdef PATRICIA_DEBUG
+            fprintf (stderr, "patricia_search_best: found %s/%d\n", 
+	             prefix_toa (node->prefix), node->prefix->bitlen);
+#endif /* PATRICIA_DEBUG */
+	    return (node);
+	}
+    }
+    return (NULL);
+}
+
+
+patricia_node_t *
+patricia_search_best (patricia_tree_t *patricia, prefix_t *prefix)
+{
+    return (patricia_search_best2 (patricia, prefix, 1));
+}
+
+
+patricia_node_t *
+patricia_lookup (patricia_tree_t *patricia, prefix_t *prefix)
+{
+    patricia_node_t *node, *new_node, *parent, *glue;
+    u_char *addr, *test_addr;
+    u_int bitlen, check_bit, differ_bit;
+    int i, j, r;
+
+    assert(patricia);
+    assert(prefix);
+    assert(prefix->bitlen <= patricia->maxbits);
+
+    if (patricia->head == NULL) {
+      node = kmem_cache_alloc(node_cache, GFP_ATOMIC);
+      if (!node) {
+	printk(KERN_INFO "Failed to allocate new pt node");
+	return(NULL);
+      }
+
+      node->bit = prefix->bitlen;
+      node->prefix = Ref_Prefix (prefix);
+      node->parent = NULL;
+      node->l = node->r = NULL;
+      node->data = NULL;
+      patricia->head = node;
+      patricia->num_active_node++;
+      return (node);
+    }
+
+    addr = prefix_touchar (prefix);
+    bitlen = prefix->bitlen;
+    node = patricia->head;
+
+    while (node->bit < bitlen || node->prefix == NULL) {
+
+	if (node->bit < patricia->maxbits &&
+	    BIT_TEST (addr[node->bit >> 3], 0x80 >> (node->bit & 0x07))) {
+	    if (node->r == NULL)
+		break;
+	    node = node->r;
+	}
+	else {
+	    if (node->l == NULL)
+		break;
+	    node = node->l;
+	}
+
+	assert(node);
+    }
+
+    assert(node->prefix);
+
+    test_addr = prefix_touchar (node->prefix);
+    /* find the first bit different */
+    check_bit = (node->bit < bitlen)? node->bit: bitlen;
+    differ_bit = 0;
+    for (i = 0; i*8 < check_bit; i++) {
+	if ((r = (addr[i] ^ test_addr[i])) == 0) {
+	    differ_bit = (i + 1) * 8;
+	    continue;
+	}
+	/* I know the better way, but for now */
+	for (j = 0; j < 8; j++) {
+	    if (BIT_TEST (r, (0x80 >> j)))
+		break;
+	}
+	/* must be found */
+	assert(j < 8);
+	differ_bit = i * 8 + j;
+	break;
+    }
+    if (differ_bit > check_bit)
+	differ_bit = check_bit;
+
+    parent = node->parent;
+    while (parent && parent->bit >= differ_bit) {
+	node = parent;
+	parent = node->parent;
+    }
+
+    if (differ_bit == bitlen && node->bit == bitlen) {
+	if (node->prefix) {
+	    return (node);
+	}
+	node->prefix = Ref_Prefix (prefix);
+	assert(node->data == NULL);
+	return (node);
+    }
+
+    new_node = kmem_cache_alloc(node_cache, GFP_ATOMIC);
+    if (!new_node) {
+      printk(KERN_INFO "Failed to allocate new pt node");
+      return(NULL);
+    }
+    new_node->bit = prefix->bitlen;
+    new_node->prefix = Ref_Prefix (prefix);
+    new_node->parent = NULL;
+    new_node->l = new_node->r = NULL;
+    new_node->data = NULL;
+    patricia->num_active_node++;
+
+    if (node->bit == differ_bit) {
+	new_node->parent = node;
+	if (node->bit < patricia->maxbits &&
+	    BIT_TEST (addr[node->bit >> 3], 0x80 >> (node->bit & 0x07))) {
+	    assert(node->r == NULL);
+	    node->r = new_node;
+	}
+	else {
+	    assert(node->l == NULL);
+	    node->l = new_node;
+	}
+	return (new_node);
+    }
+
+    if (bitlen == differ_bit) {
+	if (bitlen < patricia->maxbits &&
+	    BIT_TEST (test_addr[bitlen >> 3], 0x80 >> (bitlen & 0x07))) {
+	    new_node->r = node;
+	}
+	else {
+	    new_node->l = node;
+	}
+	new_node->parent = node->parent;
+	if (node->parent == NULL) {
+	    assert(patricia->head == node);
+	    patricia->head = new_node;
+	}
+	else if (node->parent->r == node) {
+	    node->parent->r = new_node;
+	}
+	else {
+	    node->parent->l = new_node;
+	}
+	node->parent = new_node;
+    }
+    else {
+      glue = kmem_cache_alloc(node_cache, GFP_ATOMIC);
+
+        glue->bit = differ_bit;
+        glue->prefix = NULL;
+        glue->parent = node->parent;
+        glue->data = NULL;
+        patricia->num_active_node++;
+	if (differ_bit < patricia->maxbits &&
+	    BIT_TEST (addr[differ_bit >> 3], 0x80 >> (differ_bit & 0x07))) {
+	    glue->r = new_node;
+	    glue->l = node;
+	}
+	else {
+	    glue->r = node;
+	    glue->l = new_node;
+	}
+	new_node->parent = glue;
+
+	if (node->parent == NULL) {
+	    assert(patricia->head == node);
+	    patricia->head = glue;
+	}
+	else if (node->parent->r == node) {
+	    node->parent->r = glue;
+	}
+	else {
+	    node->parent->l = glue;
+	}
+	node->parent = glue;
+    }
+    return (new_node);
+}
+
+
+void
+patricia_remove (patricia_tree_t *patricia, patricia_node_t *node)
+{
+    patricia_node_t *parent, *child;
+
+    assert(patricia);
+    assert(node);
+
+    if (node->r && node->l) {
+#ifdef PATRICIA_DEBUG
+	fprintf (stderr, "patricia_remove: #0 %s/%d (r & l)\n", 
+		 prefix_toa (node->prefix), node->prefix->bitlen);
+#endif /* PATRICIA_DEBUG */
+	
+	/* this might be a placeholder node -- have to check and make sure
+	 * there is a prefix aossciated with it ! */
+	if (node->prefix != NULL) 
+	  Deref_Prefix (node->prefix);
+	node->prefix = NULL;
+	/* Also I needed to clear data pointer -- masaki */
+	node->data = NULL;
+	return;
+    }
+ 
+    if (node->r == NULL && node->l == NULL) {
+#ifdef PATRICIA_DEBUG
+	fprintf (stderr, "patricia_remove: #1 %s/%d (!r & !l)\n", 
+		 prefix_toa (node->prefix), node->prefix->bitlen);
+#endif /* PATRICIA_DEBUG */
+	parent = node->parent;
+       	Deref_Prefix (node->prefix);
+	
+	kmem_cache_free(node_cache, node);
+	patricia->num_active_node--;
+
+	if (parent == NULL) {
+	    assert(patricia->head == node);
+	    patricia->head = NULL;
+	    return;
+	}
+
+	if (parent->r == node) {
+	    parent->r = NULL;
+	    child = parent->l;
+	}
+	else {
+	    assert(parent->l == node);
+	    parent->l = NULL;
+	    child = parent->r;
+	}
+
+	if (parent->prefix)
+	    return;
+
+	/* we need to remove parent too */
+
+	if (parent->parent == NULL) {
+	    assert(patricia->head == parent);
+	    patricia->head = child;
+	}
+	else if (parent->parent->r == parent) {
+	    parent->parent->r = child;
+	}
+	else {
+	    assert(parent->parent->l == parent);
+	    parent->parent->l = child;
+	}
+	child->parent = parent->parent;
+	kmem_cache_free(node_cache, parent);
+        patricia->num_active_node--;
+	return;
+    }
+
+#ifdef PATRICIA_DEBUG
+    fprintf (stderr, "patricia_remove: #2 %s/%d (r ^ l)\n", 
+	     prefix_toa (node->prefix), node->prefix->bitlen);
+#endif /* PATRICIA_DEBUG */
+    if (node->r) {
+	child = node->r;
+    }
+    else {
+	assert(node->l);
+	child = node->l;
+    }
+    parent = node->parent;
+    child->parent = parent;
+
+    Deref_Prefix (node->prefix);
+    kmem_cache_free(node_cache, node);
+    patricia->num_active_node--;
+
+    if (parent == NULL) {
+	assert (patricia->head == node);
+	patricia->head = child;
+	return;
+    }
+
+    if (parent->r == node) {
+	parent->r = child;
+    }
+    else {
+        assert(parent->l == node);
+	parent->l = child;
+    }
+}
+
+/* { from demo.c */
+
+patricia_node_t *
+make_and_lookup_v4 (patricia_tree_t *tree, ulong prefixkey, int prefixlen)
+{
+    prefix_t *prefix;
+    patricia_node_t *node;
+    u_long bitlen, maxbitlen = 0;
+    struct in_addr sin;
+    
+    memcpy(&sin, &prefixkey, sizeof(struct in_addr));
+    maxbitlen = sizeof(struct in_addr) * 8;
+    bitlen = prefixlen;
+    prefix = New_Prefix(AF_INET, &sin, bitlen);
+
+    printk ("make_and_lookup: %s/%d\n", prefix_toa (prefix), prefix->bitlen);
+    node = patricia_lookup (tree, prefix);
+    Deref_Prefix (prefix);
+    printk (" New prefix has %d references, tree has %d active nodes\n",
+            prefix->ref_count, tree->num_active_node);
+    return (node);
+}
+
+patricia_node_t *
+make_and_lookup_v6 (patricia_tree_t *tree, struct in6_addr prefixkey, 
+		 int prefixlen)
+{
+    prefix_t *prefix;
+    patricia_node_t *node;
+    u_long bitlen, maxbitlen = 0;
+    struct in6_addr sin;
+    
+    memcpy(&sin, &prefixkey, sizeof(struct in6_addr));
+    maxbitlen = sizeof(struct in6_addr) * 8;
+    bitlen = prefixlen;
+    prefix = New_Prefix(AF_INET6, &sin, bitlen);
+
+    printk ("make_and_lookup: %pI6/%d\n", prefixkey.s6_addr, prefix->bitlen);
+    node = patricia_lookup (tree, prefix);
+    Deref_Prefix (prefix);
+    return (node);
+}
+
+/* } */
Index: package/lisp_mod/src/lisp_input.c
===================================================================
--- package/lisp_mod/src/lisp_input.c	(revision 0)
+++ package/lisp_mod/src/lisp_input.c	(revision 0)
@@ -0,0 +1,285 @@
+/*
+ * lisp_input.c
+ *
+ * Packet input path for LISP module.
+ *
+ * Copyright 2010, Cisco Systems
+ * Author: Chris White
+ */
+
+#include "lisp_mod.h"
+#include "linux/ip.h"
+#include "linux/udp.h"
+#include "linux/in_route.h"
+#include "linux/if_arp.h"
+#include "net/route.h"
+#include "net/ip.h"
+#include "net/ipv6.h"
+#include "net/ip6_route.h"
+#include "linux/ipv6.h"
+#include "net/icmp.h"
+#include "net/inet_ecn.h"
+#include "lisp_input.h"
+#include "packettypes.h"
+
+extern lisp_globals globals;
+const char echo_signature = 0x78; // First byte past udp header if lisp echo reply
+
+//vlakafos
+//#define DEBUG
+//#define DEBUG_PACKETS
+
+/*
+ * PN: LISP EID Interface
+ * Currently supports 1 interface, name hard-coded
+ */
+#define LISP_EID_INTERFACE    "lmn0"
+
+/*
+ * check_locator_bits()
+ *
+ * Verify that the locator status bits in the data packet
+ * match our view. If not update it. We have to do a cache
+ * lookup for every input packet to do this.
+ */
+void check_locator_bits(struct lisphdr *lisp_hdr,
+                        struct iphdr *iph, int source)
+{
+    int i, bitval, retval;
+    lisp_map_cache_t *eid_entry;
+    int packet_lsbs;
+
+    // Lookup the source in the map cache
+    retval = lookup_eid_cache_v4(iph->saddr, &eid_entry);
+
+    // No entry, what to do?? XXX
+    if (retval == 0) {
+        printk(KERN_INFO "   Odd, no cache entry for incoming packet.");
+        return;
+    }
+
+    // Source must be using LSB's for us to care...
+    if (lisp_hdr->lsb) {
+
+        /*
+         * Check our lsb's against theirs, first extract them from packet
+         */
+        if (lisp_hdr->instance_id) {
+            packet_lsbs = ntohl(lisp_hdr->lsb_bits) & 0x000000FF;
+        } else {
+            packet_lsbs = ntohl(lisp_hdr->lsb_bits);
+        }
+
+        // Go through our list and mark the entries
+        // with their current status.
+        if (packet_lsbs != eid_entry->lsb) {
+            printk(KERN_INFO "     LSB change, was 0x%x, now 0x%x",
+                   eid_entry->lsb, packet_lsbs);
+            eid_entry->lsb = packet_lsbs;
+            bitval = 1;
+            for (i = 0; i < eid_entry->count; i++) {
+                eid_entry->locator_list[i]->state = !!(bitval & packet_lsbs);
+                bitval = bitval << 1;
+            }
+            // Update the hash table
+            update_locator_hash_table(eid_entry);
+        }
+    }
+
+    // Update the input stats
+    eid_entry->active_within_period = 1;
+    for (i = 0; i < MAX_LOCATORS; i++) {
+        if (!eid_entry->locator_list[i]) {
+            break;
+        }
+        if (source == eid_entry->locator_list[i]->locator.address.ip.s_addr) {
+            eid_entry->locator_list[i]->data_packets_in++;
+            break;
+        }
+    }
+}
+
+/*
+ * lisp_input()
+ *
+ * Packet entry point into LISP processing. Since all packets
+ * will come here, we must be efficient at disposing of non-LISP
+ * destined datagrams.
+ */
+unsigned int lisp_input(unsigned int hooknum, struct sk_buff *packet_buf,
+			const struct net_device *input_dev,
+			const struct net_device *output_dev,
+			int (*okfunc)(struct sk_buff*))
+{
+    struct iphdr *iph;
+    struct ipv6hdr *ip6;
+    struct udphdr *udh;
+    struct lisphdr *lisp_hdr;
+    char   first_byte;
+    int source_locator;
+
+  /*
+   * PN: net_device corresponding to LISP_EID_INTERFACE
+   */
+  struct net_device *eid_int = NULL;
+  
+    /*
+     * Get the IP header
+     */
+    iph = ip_hdr(packet_buf);
+
+    if (!iph) {
+        printk(KERN_INFO "Odd, no IP header\n");
+        return NF_ACCEPT;
+    }
+
+    source_locator = iph->saddr;
+
+#ifdef DEBUG_PACKETS
+    if (!((packet_buf->pkt_type == PACKET_LOOPBACK) || ipv4_is_multicast(iph->daddr) ||
+            ipv4_is_lbcast(iph->daddr))) {
+    	printk(KERN_INFO "In LISP Input with packet from %pI4 for %pI4\n",
+           &(source_locator), &(iph->daddr));
+    }
+#endif
+
+    /*
+     * Certain things should never be LISP examined:
+     * locally loopback sourced, and for now, multicast.
+     */
+    if ((packet_buf->pkt_type == PACKET_LOOPBACK) || ipv4_is_multicast(iph->daddr) ||
+            ipv4_is_lbcast(iph->daddr)) {
+        return NF_ACCEPT;
+    }
+
+    /*
+     * Check for UDP LISP packets
+     */
+    if (iph->protocol == IPPROTO_UDP) {
+
+        // Move past the ip header
+        skb_pull(packet_buf, sizeof(struct iphdr));
+        skb_reset_transport_header(packet_buf);
+
+        udh = udp_hdr(packet_buf);
+        first_byte= *((char *)udh + sizeof(struct udphdr));
+
+#ifdef DEBUG_PACKETS
+        printk(KERN_INFO "  Proto is UDP, src port: %d dest port: %d\n",
+               ntohs(udh->source), ntohs(udh->dest));
+        printk(KERN_INFO "  First byte: 0x%x", first_byte);
+#endif
+
+        // Detect non-encapsulated lisp control messages
+        if (ntohs(udh->dest) == globals.udp_encap_port &&
+                ntohs(udh->source) != LISP_CONTROL_PORT &&
+                (first_byte != echo_signature)) {
+
+            // LISP header
+            lisp_hdr = (struct lisphdr *)skb_pull(packet_buf, sizeof(struct udphdr));
+            skb_reset_transport_header(packet_buf);
+
+#ifdef DEBUG_PACKETS
+            printk(KERN_INFO "   LISP packet received: dest %d, len: %d\n", ntohs(udh->dest),
+                   ntohs(udh->len));
+            printk(KERN_INFO "       rflags: %d, e: %d, l: %d, n: %d, lsb: 0x%x",
+                   lisp_hdr->rflags, lisp_hdr->echo_nonce, lisp_hdr->lsb,
+                   lisp_hdr->nonce_present, lisp_hdr->lsb_bits);
+#endif
+
+            // XXX TBD: Check if the inner destination is within our database
+            // before decapsulating and accepting.
+
+            // Decapsulate
+            skb_pull(packet_buf, sizeof(struct lisphdr));
+            skb_reset_transport_header(packet_buf);
+            skb_reset_network_header(packet_buf);
+            iph = ip_hdr(packet_buf);
+
+            if (iph->version == 4) {
+#ifdef DEBUG_PACKETS
+                printk(KERN_INFO "   Inner packet src:%pI4 dst:%pI4, type: %d\n", &(iph->saddr),
+                       &(iph->daddr), iph->protocol);
+#endif
+
+                // Check the LSB's.
+                check_locator_bits(lisp_hdr, iph, source_locator);
+                
+                eid_int = dev_get_by_name (&init_net, LISP_EID_INTERFACE);
+           		if (eid_int) {
+               		dev_put (eid_int);
+               		packet_buf->dev = eid_int;
+               		skb_dst_drop (packet_buf);
+               		nf_reset(packet_buf);
+           		}
+           		else {
+               		printk (KERN_INFO "Couldn't get input interface %s\n",
+                       LISP_EID_INTERFACE);
+           		}
+           		
+                return NF_ACCEPT;
+            } else if (iph->version == 6) {
+                ip6 = ipv6_hdr(packet_buf);
+                printk(KERN_INFO "   Inner packet src:%pI6 dst:%pI6, nexthdr: 0x%x\n",
+                       ip6->saddr.s6_addr, ip6->daddr.s6_addr, ip6->nexthdr);
+
+                IPCB(packet_buf)->flags = 0;
+                packet_buf->protocol = htons(ETH_P_IPV6);
+                packet_buf->pkt_type = PACKET_HOST;
+
+                packet_buf->dev = input_dev;
+                nf_reset(packet_buf);
+                netif_rx(packet_buf);
+
+                eid_int = dev_get_by_name (&init_net, LISP_EID_INTERFACE);
+           		if (eid_int) {
+               		dev_put (eid_int);
+               		packet_buf->dev = eid_int;
+               		skb_dst_drop (packet_buf);
+               		nf_reset(packet_buf);
+           		}
+           		else {
+               		printk (KERN_INFO "Couldn't get input interface %s\n",
+                       LISP_EID_INTERFACE);
+           		}
+
+                return NF_STOLEN;
+            } else {
+                return NF_ACCEPT; // Don't know what it is, let ip deal with it.
+            }
+        }
+
+#ifdef DEBUG_PACKETS
+        printk(KERN_INFO "  Non-LISP UDP Packet received\n");
+
+        if (first_byte == echo_signature) {
+            printk(KERN_INFO "    LISP-echo reply to data port");
+        }
+#endif
+
+        // Undo the pull, the next layer expects a pristine skb
+        skb_push(packet_buf, sizeof(struct iphdr));
+        skb_reset_transport_header(packet_buf);
+    }
+
+    /*
+     * The packet is normal traffic. If it's not destined for a local
+     * address on this box, we need to encapsulate and route it. XXX v4 ONLY
+     */
+    if (!is_v4addr_local(iph)) {
+
+#ifdef DEBUG_PACKETS
+        printk(KERN_INFO "  Packet is non-local, sending on to lisp_output() for encap and routing");
+#endif
+        return(lisp_output4(0, packet_buf, NULL, NULL, NULL));
+    }
+
+    /*
+     * Otherwise let IP handle this
+     */
+#ifdef DEBUG_PACKETS
+    printk(KERN_INFO "  Punting to IP\n");
+#endif
+    return NF_ACCEPT;
+}
+
Index: package/lisp_mod/src/lisp_output.c
===================================================================
--- package/lisp_mod/src/lisp_output.c	(revision 0)
+++ package/lisp_mod/src/lisp_output.c	(revision 0)
@@ -0,0 +1,734 @@
+/*
+ * lispoutput.c
+ *
+ * Handler routines for locally sourced packets destined
+ * for LISP encapsulation.
+ * 
+ * Copyright 2010, cisco Systems.
+ */
+
+#include "linux/version.h"
+#include "linux/ip.h"
+#include "linux/udp.h"
+#include "linux/in_route.h"
+#include "net/route.h"
+#include "net/ip.h"
+#include "net/ipv6.h"
+#include "net/ip6_route.h"
+#include "net/inet_ecn.h"
+#include "net/dst.h"
+#include "lisp_mod.h"
+#include "lisp_output.h"
+#include "packettypes.h"
+
+//vlakafos
+//#define DEBUG 
+//#define DEBUG_PACKETS
+
+/* PN 
+ * define NEW_KERNEL to handle differences in struct sk_buff
+ * between android and newer kernels
+ */
+//vlakafos
+#define NEW_KERNEL
+
+extern lisp_globals globals;
+
+static inline uint16_t src_port_hash(struct iphdr *iph)
+{
+  uint16_t result = 0;
+  
+  // Simple rotated XOR hash of src and dst
+  result = (iph->saddr << 4) ^ (iph->saddr >> 28) ^ iph->saddr ^ iph->daddr;
+  return result;
+}
+
+static inline unsigned char output_hash_v4(unsigned int src_eid, unsigned int dst_eid)
+{
+    int hash;
+
+    hash = src_eid ^ dst_eid;
+    return ((((hash & 0xFFFF0000) << 16) ^ (hash & 0xFFFF)) % LOC_HASH_SIZE);
+}
+
+void lisp_encap4(struct sk_buff *skb, int locator_addr,
+		 ushort inner_afi)
+{
+  struct udphdr *udh;
+  struct iphdr *iph;
+  struct iphdr *old_iph = ip_hdr(skb);
+  struct lisphdr *lisph;
+  struct sk_buff *new_skb = NULL;
+  uint32_t orig_length = skb->len;
+  uint32_t pkt_len, err;
+  uint32_t max_headroom;
+  struct net_device *tdev; // Output device
+  struct rtable *rt; // route to RLOC
+
+  /*
+   * Painful: we have to do a routing check on our
+   * proposed RLOC dstadr to determine the output
+   * device. This is so that we can be assured
+   * of having the proper space available in the 
+   * skb to add our headers. This is modelled after
+   * the ipip.c code.
+   */
+   //PN: Set correct saddr for route lookup
+#ifdef DEBUG_PACKETS
+   printk(KERN_INFO "lisp_encap4: saddr for route lookup: %pI4\n",
+                      &globals.my_rloc.address.ip.s_addr);
+#endif
+  {
+    struct flowi fl = { .oif = 0,
+			.nl_u = { .ip4_u = 
+				  { .daddr = locator_addr,
+				    .saddr = globals.my_rloc.address.ip.s_addr,
+				    .tos = RT_TOS(old_iph->tos) } },
+			.proto = IPPROTO_UDP };
+    if (ip_route_output_key(&init_net, &rt, &fl)) {
+      printk(KERN_INFO "Route lookup for locator %pI4 failed\n", &locator_addr);
+      //PN: Fix skb memory leaks
+      dev_kfree_skb(skb);
+      return;
+    }
+  }
+  
+  /*
+   * Get the output device 
+   */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35)
+  tdev = rt->dst.dev;
+#else
+  tdev = rt->u.dst.dev;
+#endif
+  
+  //PN: What did route lookup return?
+#ifdef DEBUG_PACKETS
+  printk(KERN_INFO "   Got route for RLOC; tdev: %s\n", tdev->name);
+#endif
+
+  /*
+   * Handle fragmentation XXX 
+   */
+  
+  /* 
+   * Determine if we have enough space.
+   */
+  max_headroom = (LL_RESERVED_SPACE(tdev) + sizeof(struct iphdr) +
+		  sizeof(struct udphdr) + sizeof(struct lisphdr));
+#ifdef DEBUG_PACKETS
+  printk(KERN_INFO "    Max headroom is %d\n", max_headroom);
+#endif
+
+  /*
+   * If not, gotta make some more.
+   */
+  if (skb_headroom(skb) < max_headroom || skb_shared(skb) ||
+      (skb_cloned(skb) && !skb_clone_writable(skb, 0))) {
+#ifdef DEBUG_PACKETS
+    printk(KERN_INFO "    Forced to allocate new sk_buff\n");
+#endif
+    new_skb = skb_realloc_headroom(skb, max_headroom);
+    if (!new_skb) {
+      ip_rt_put(rt);
+      printk(KERN_INFO "Failed to allocate new skb for packet encap\n");
+      //PN: Fix skb memory leaks
+      dev_kfree_skb(skb);
+      return;
+    }
+
+    /*
+     * Repoint socket if necessary
+     */
+    if (skb->sk) 
+      skb_set_owner_w(new_skb, skb->sk);
+
+    dev_kfree_skb(skb);
+    skb = new_skb;
+    old_iph = ip_hdr(skb);
+  }
+
+  /* 
+   * Construct and add the LISP header
+   */
+  skb->transport_header = skb->network_header;
+  lisph = (struct lisphdr *)(skb_push(skb, sizeof(struct lisphdr)));
+  skb_reset_transport_header(skb);
+
+  memset((char *)lisph, 0, sizeof(struct lisphdr));
+
+  // Single LSB for now, and set it to ON
+  lisph->lsb = 1;
+  lisph->lsb_bits = htonl(0x1);
+  lisph->nonce_present = 1;
+  lisph->nonce[0] = net_random() & 0xFF;
+  lisph->nonce[1] = net_random() & 0xFF;
+  lisph->nonce[2] = net_random() & 0xFF;
+
+#ifdef DEBUG_PACKETS
+  printk(KERN_INFO "          rflags: %d, e: %d, l: %d, n: %d, lsb: 0x%x",
+             lisph->rflags, lisph->echo_nonce, lisph->lsb,
+             lisph->nonce_present, lisph->lsb_bits);
+#endif
+
+  /* 
+   * Construct and add the udp header
+   */ 
+  skb->transport_header = skb->network_header;
+  udh = (struct udphdr *)(skb_push(skb, sizeof(struct udphdr)));
+  skb_reset_transport_header(skb);
+
+  /*
+   * Hash of inner header source/dest addr. This needs thought.
+   */
+  udh->source = htons(globals.udp_encap_port);
+  udh->dest =  htons(LISP_ENCAP_PORT);
+  udh->len = htons(sizeof(struct udphdr) + orig_length +
+		   sizeof(struct lisphdr));
+  udh->check = 0; // SHOULD be 0 as in LISP ID
+
+  /*
+   * Construct and add the outer ip header
+   */
+  iph = (struct iphdr *)skb_push(skb, sizeof(struct iphdr));
+  skb_reset_network_header(skb);
+  memset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35)
+  skb_dst_drop(skb);
+  skb_dst_set(skb, &rt->dst);
+#elif defined NEW_KERNEL
+  skb_dst_drop(skb);
+  skb_dst_set(skb, &rt->u.dst);
+#else
+  dst_release(skb->dst);
+  skb->dst = &rt->u.dst;
+#endif
+  iph           = ip_hdr(skb);
+  iph->version  =    4;
+  iph->ihl      =     sizeof(struct iphdr)>>2;
+  iph->frag_off = 0;   // XXX recompute above, use method in 5.4.1 of draft
+  iph->protocol = IPPROTO_UDP;
+  iph->tos      = old_iph->tos; // Need something else too? XXX
+  iph->daddr    = rt->rt_dst;
+  iph->saddr    = globals.my_rloc.address.ip.s_addr;
+  iph->ttl      = old_iph->ttl;
+
+#ifdef DEBUG_PACKETS
+  printk(KERN_INFO "     Packet encapsulated to %pI4 from %pI4\n",
+	 &(iph->daddr), &(iph->saddr));
+#endif
+  nf_reset(skb);
+  
+  /* 
+   * We must transmit the packet ourselves:
+   * the skb has probably changed out from under
+   * the upper layers that have a reference to it.
+   * 
+   * This is the same work that the tunnel code does
+   */
+  pkt_len = skb->len - skb_transport_offset(skb);
+  
+  skb->ip_summed = CHECKSUM_NONE;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35)
+  ip_select_ident(iph, &rt->dst, NULL);
+#else
+  ip_select_ident(iph, &rt->u.dst, NULL);
+#endif
+
+  /*
+   * We want the equivalent of ip_local_output, but
+   * without taking a pass through the NF_HOOK again.
+   * We'd just come right back here. May be wary of
+   * all this does too: fragmentation, etc.... XXX
+   */
+  iph->tot_len = htons(skb->len);
+  ip_send_check(iph);
+
+  err = dst_output(skb);
+  if (net_xmit_eval(err) != 0) {
+    printk(KERN_INFO "     ip_local_out() reported an error: %d\n", err);
+    //PN: Fix skb memory leaks
+    dev_kfree_skb(skb);
+  }
+
+  return;
+}
+
+void lisp_encap6(struct sk_buff *skb, lisp_addr_t locator_addr,
+		 ushort inner_afi)
+{
+  struct udphdr *udh;
+  struct ipv6hdr *iph;
+  struct ipv6hdr *old_iph = ipv6_hdr(skb);
+  struct lisphdr *lisph;
+  struct sk_buff *new_skb = NULL;
+  uint32_t orig_length = skb->len;
+  uint32_t pkt_len, err;
+  uint32_t max_headroom;
+  struct net_device *tdev; // Output device
+  struct dst_entry *dst;
+  int    mtu;
+  uint8_t dsfield;
+  struct flowi fl;
+  
+  /*
+   * We have to do a routing check on our
+   * proposed RLOC dstadr to determine the output
+   * device. This is so that we can be assured
+   * of having the proper space available in the 
+   * skb to add our headers. This is modelled after
+   * the iptunnel6.c code.
+   */
+  {
+    ipv6_addr_copy(&fl.fl6_dst, &locator_addr.address.ipv6);
+    if (globals.my_rloc_af != AF_INET6) {
+      printk(KERN_INFO "No AF_INET6 source rloc available\n");
+      return;
+    }
+    ipv6_addr_copy(&fl.fl6_src, &globals.my_rloc.address.ipv6);
+    fl.oif = 0;
+
+    fl.fl6_flowlabel = 0;
+    fl.proto = IPPROTO_UDP;
+  }
+
+  dst = ip6_route_output(&init_net, NULL, &fl);
+
+  if (dst->error) {
+    printk(KERN_INFO "  Failed v6 route lookup for RLOC\n");
+    
+    // Error fail cleanup XXX
+    return;
+  }
+     
+  /*
+   * Get the output device 
+   */
+  tdev = dst->dev;
+  
+  printk(KERN_INFO "   Got route for RLOC\n");
+
+  /*
+   * Handle fragmentation XXX 
+   */
+  mtu = dst_mtu(dst) - (sizeof(*iph) + sizeof(*lisph));
+  if (mtu < IPV6_MIN_MTU) {
+    mtu = IPV6_MIN_MTU;
+  };
+
+#ifdef NEW_KERNEL
+  /*
+   * Do we really want to do this? XXX
+   */
+  if (skb_dst(skb))
+    skb_dst(skb)->ops->update_pmtu(skb_dst(skb), mtu);
+  if (skb->len > mtu) {
+    printk(KERN_INFO "   skb does not fit in MTU");
+    return; // Cleanup XXX
+  }
+#else
+  if (skb->dst)
+      skb->dst->ops->update_pmtu(skb->dst, mtu);
+  if (skb->len > mtu) {
+      printk(KERN_INFO "   skb does not fit in MTU\n");
+      return; // Cleanup XXX
+  }
+#endif
+  
+  /* 
+   * Determine if we have enough space.
+   */
+  max_headroom = (LL_RESERVED_SPACE(tdev) + sizeof(struct ipv6hdr) +
+		  sizeof(struct udphdr) + sizeof(struct lisphdr));
+  printk(KERN_INFO "  Max headroom is %d\n", max_headroom);
+
+  /*
+   * If not, gotta make some more.
+   */
+  if (skb_headroom(skb) < max_headroom || skb_shared(skb) ||
+      (skb_cloned(skb) && !skb_clone_writable(skb, 0))) {
+      printk(KERN_INFO "  Forced to allocate new sk_buff\n");
+      new_skb = skb_realloc_headroom(skb, max_headroom);
+      if (!new_skb) {
+          printk(KERN_INFO "Failed to allocate new skb for packet encap\n");
+          return;
+      }
+
+      /*
+     * Repoint socket if necessary
+     */
+      if (skb->sk)
+          skb_set_owner_w(new_skb, skb->sk);
+
+      dev_kfree_skb(skb);
+      skb = new_skb;
+      old_iph = ipv6_hdr(skb); // Err.. what if its v6 encaped v4? XXX
+  }
+
+#ifdef NEW_KERNEL
+  skb_dst_drop(skb);
+  skb_dst_set(skb, dst);
+#else
+  dst_release(skb->dst);
+  skb->dst = dst_clone(dst);
+#endif
+
+  /* 
+   * Construct and add the LISP header
+   */
+  skb->transport_header = skb->network_header;
+  lisph = (struct lisphdr *)(skb_push(skb, sizeof(struct lisphdr)));
+  skb_reset_transport_header(skb);
+
+  // no flags XXX
+  memset((char *)lisph, 0, sizeof(struct lisphdr));
+
+   /* 
+   * Construct and add the udp header
+   */ 
+  skb->transport_header = skb->network_header;
+  udh = (struct udphdr *)(skb_push(skb, sizeof(struct udphdr)));
+  skb_reset_transport_header(skb);
+  
+  /*
+   * Hash of inner header source/dest addr. This needs thought.
+   */
+  udh->source = htons(globals.udp_encap_port);
+  udh->dest =  LISP_ENCAP_PORT;
+  udh->len = htons(sizeof(struct udphdr) + orig_length +
+		   sizeof(struct lisphdr));
+  udh->check = 0; // SHOULD be 0 as in LISP ID
+
+  /*
+   * Construct and add the outer ipv6 header
+   */
+  skb_push(skb, sizeof(struct ipv6hdr));
+  skb_reset_network_header(skb);
+  iph = ipv6_hdr(skb);
+  *(__be32*)iph = htonl(0x60000000); // Flowlabel? XXX
+  dsfield = INET_ECN_encapsulate(0, dsfield);
+  ipv6_change_dsfield(iph, ~INET_ECN_MASK, dsfield);
+  iph->hop_limit = 10; // XXX grab from inner header.
+  iph->nexthdr = IPPROTO_UDP;
+  ipv6_addr_copy(&iph->saddr, &fl.fl6_src);
+  ipv6_addr_copy(&iph->daddr, &fl.fl6_dst);
+  nf_reset(skb);
+
+#ifdef DEBUG_PACKETS
+  printk(KERN_INFO "  Packet encapsulated to %pI6\n", iph->daddr.s6_addr);
+#endif
+
+  /* 
+   * We must transmit the packet ourselves:
+   * the skb has probably changed out from under
+   * the upper layers that have a reference to it.
+   * 
+   * This is the same work that the tunnel code does
+   */
+  pkt_len = skb->len;
+  err = ip6_local_out(skb);
+  if (net_xmit_eval(err) != 0) {
+    printk(KERN_INFO "ip_local_out() reported an error: %d\n", err);
+  }
+
+  return;
+}
+
+unsigned int lisp_output6(unsigned int hooknum,
+			  struct sk_buff *packet_buf,
+			  const struct net_device *input_dev,
+			  const struct net_device *output_dev,
+			  int (*okfunc)(struct sk_buff*))
+{
+  struct ipv6hdr *iph;
+  lisp_map_cache_t *eid_entry;
+  int retval;
+  lisp_addr_t locator_addr;
+  ushort      loc_afi;
+  lisp_addr_t dst_addr;
+
+  /* 
+   * Extract the ip header
+   */
+  iph = ipv6_hdr(packet_buf);
+  
+#ifdef DEBUG
+  printk(KERN_INFO "   Output packet originally destined for %pI6 from %pI6\n", iph->daddr.s6_addr,
+         iph->saddr.s6_addr);
+#endif
+
+  /*
+   * Sanity check the inner packet XXX
+   */
+
+  /*
+   * Eventually, when supporting ipv6/ipv6 or v4 or v6, we
+   * will need to escape LISP control messages, like in lisp_output4.
+   * XXX
+   */
+
+  /*
+   * Lookup the destination in the map-cache, this will
+   * need to return the full entry in the future for all
+   * the flags to be processed. TDB: Check for concurrency
+   * issues with directly using the entry pointer here. May
+   * need to lock it or make a copy (ick)
+   */
+  memcpy(dst_addr.address.ipv6.s6_addr, iph->daddr.s6_addr, sizeof(lisp_addr_t));
+  retval = lookup_eid_cache_v6(dst_addr, &eid_entry);
+  
+  /*
+   * Check status of returned entry XXX (requires extension
+   * of above function).
+   */
+  if (retval == 0 || !eid_entry->count) {
+
+    printk(KERN_INFO "No EID mapping found, notifying lispd...\n");
+    /* PN testing
+     * cacheMiss crashes lispd
+     */
+    //send_cache_miss_notification(dst_addr, AF_INET6);
+    return NF_ACCEPT;  // What's the right thing to do here? XXX
+  }
+
+  /*
+   * Mark that traffic has been received.
+   */
+  eid_entry->active_within_period = 1;
+
+  /*
+   * Get the first locator for now... sync up with output4 to use hash XXX
+   */
+  if (!eid_entry->locator_list[0]) {
+    printk(KERN_INFO " No suitable locators.\n");
+    return(NF_DROP);
+  } else {
+      loc_afi = eid_entry->locator_list[0]->locator.afi;
+      memcpy(&locator_addr, &eid_entry->locator_list[0]->locator, sizeof(lisp_addr_t));
+    printk(KERN_INFO " Locator found.\n");
+  }
+  
+  /* 
+   * Prepend UDP, LISP, outer IP header
+   */
+  if (loc_afi == AF_INET) {
+      lisp_encap4(packet_buf, locator_addr.address.ip.s_addr,
+                  AF_INET6);
+      printk(KERN_INFO "   Using locator address: %pI4\n", &locator_addr);
+  } else {
+      if (loc_afi == AF_INET6) {
+          lisp_encap6(packet_buf, locator_addr, AF_INET6);
+          printk(KERN_INFO "   Using locator address: %pI6\n", locator_addr.address.ipv6.s6_addr);
+      }
+  }
+
+  eid_entry->locator_list[0]->data_packets_out++;
+
+  /* 
+   * In all liklihood we've disposed of the orignal skb
+   * for size reasons. We must transmit it ourselves, and
+   * force the upper-layers to conside it gone.
+   */
+  return NF_STOLEN;
+}
+
+/*
+ * is_v4addr_local
+ *
+ * Perform a route lookup to determine if this address
+ * belongs to us. See arp.c for comparable check.
+ */
+//vlakafos
+//bool is_v4addr_local(struct iphdr *iph, const struct net_device *dev)
+bool is_v4addr_local(struct iphdr *iph) 
+{
+    struct flowi fl;
+    struct rtable *rt;
+    struct net_device *dev;
+
+    /*
+     * XXX (LJ): Non-Android kernels seem to pass an sk_buff with a NULL dev member
+     *           Return false for now if that happens to avoid oops
+     */
+/* #ifdef NEW_KERNEL
+    if(dev == NULL) {
+          printk(KERN_INFO "packet_buf->dev is null pointer!");
+          return 0;
+    }
+#endif */
+
+    memset(&fl, 0, sizeof(fl));
+    fl.fl4_dst = iph->daddr;
+    fl.fl4_tos = RTO_ONLINK;
+    if (ip_route_output_key(&init_net, &rt, &fl))
+        return 0;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35)
+    dev = rt->dst.dev;
+#else
+    dev = rt->u.dst.dev;
+#endif
+    ip_rt_put(rt);
+    if (!dev)
+        return 0;
+
+    // If we got anything, it's local
+    return 1;
+}
+
+/*
+ * do_not_encap()
+ *
+ * Check if the outgoing packet matches classes of
+ * addresses that should not be encapsulated (broadcast,
+ * multicast, local, etc.).
+ */
+static inline bool do_not_encap(struct iphdr *iph)
+{
+    unsigned int addrtype = inet_addr_type(&init_net, iph->daddr);
+
+    if (ipv4_is_multicast(iph->daddr) ||
+            ipv4_is_loopback(iph->daddr) ||
+            ipv4_is_zeronet(iph->daddr) ||
+            ipv4_is_lbcast(iph->daddr) ||
+        (addrtype != RTN_UNICAST))
+    {
+        return 1;
+    }
+    return 0;
+}
+
+unsigned int lisp_output4(unsigned int hooknum,
+			  struct sk_buff *packet_buf,
+			  const struct net_device *input_dev,
+			  const struct net_device *output_dev,
+			  int (*okfunc)(struct sk_buff*))
+{
+  struct iphdr *iph;
+  struct udphdr *udh;
+  lisp_map_cache_t *eid_entry;
+  int retval;
+  int locator_addr;
+  unsigned char loc_index;
+  lisp_addr_t miss_addr;
+
+  /* 
+   * Extract the ip header
+   */
+  iph = ip_hdr(packet_buf);
+  
+#ifdef DEBUG_PACKETS
+  printk(KERN_INFO "   Output packet destined for %pI4 from %pI4, proto: %d\n", &(iph->daddr),
+         &(iph->saddr), iph->protocol);
+#endif
+
+  /*
+   * Check for local destination, punt if so.
+   */
+  if (is_v4addr_local(iph)) {
+#ifdef DEBUG_PACKETS
+      printk(KERN_INFO "       Packet is locally destined.\n");
+#endif
+      return NF_ACCEPT;
+  }
+
+  if (do_not_encap(iph)) {
+      printk(KERN_INFO "     Packet address class not encapsulated.\n");
+      return NF_ACCEPT;
+  }
+
+  /*
+   * Don't encapsulate LISP control messages
+   */
+  if (iph->protocol == IPPROTO_UDP) {
+      skb_pull(packet_buf, sizeof(struct iphdr));
+      skb_reset_transport_header(packet_buf);
+      udh = udp_hdr(packet_buf);
+
+      /*
+       * If either of the udp ports are the control port or data, allow
+       * to go out natively. This is a quick way around the
+       * route filter which rewrites the EID as the source address.
+       */
+      if ( (ntohs(udh->dest) == LISP_CONTROL_PORT) ||
+          (ntohs(udh->source) == LISP_CONTROL_PORT) ||
+          (ntohs(udh->source) == LISP_ENCAP_PORT) ||
+          (ntohs(udh->dest) == LISP_ENCAP_PORT) ) {
+
+          // Undo the pull
+#ifdef DEBUG_PACKETS
+          printk(KERN_INFO "      Packet looks like lisp control: dstprt %d, srcprt %d\n",
+                 ntohs(udh->dest), ntohs(udh->source));
+#endif
+          skb_push(packet_buf, sizeof(struct iphdr));
+          skb_reset_transport_header(packet_buf);
+          return NF_ACCEPT;
+      } else {
+#ifdef DEBUG_PACKETS
+          printk(KERN_INFO "       Packet not lisp control: dstprt %d, srcprt %d\n", ntohs(udh->dest),
+                 ntohs(udh->source));
+#endif
+      }
+       // Undo the pull
+      skb_push(packet_buf, sizeof(struct iphdr));
+      skb_reset_transport_header(packet_buf);
+    }
+
+  /*
+   * Sanity check the inner packet XXX
+   */
+
+  /*
+   * Lookup the destination in the map-cache, this will
+   * need to return the full entry in the future for all
+   * the flags to be processed. TDB: Check for concurrency
+   * issues with directly using the entry pointer here. May
+   * need to lock it or make a copy (ick)
+   */
+  retval = lookup_eid_cache_v4(iph->daddr, &eid_entry);
+  
+  /*
+   * Check status of returned entry XXX (requires extension
+   * of above function).
+   */
+  if (retval == 0 || !eid_entry->count) {
+
+    printk(KERN_INFO "        No EID mapping found, notifying lispd...\n");
+    miss_addr.address.ip.s_addr = iph->daddr;
+    send_cache_miss_notification(miss_addr, AF_INET);
+    return NF_ACCEPT;  // What's the right thing to do here? XXX
+  }
+
+  /*
+   * Mark that traffic has been received.
+   */
+  eid_entry->active_within_period = 1;
+
+  /*
+   * Hash to find the correct locator based on weight, priority, etc.
+   */
+  loc_index = eid_entry->locator_hash_table[output_hash_v4(iph->saddr, iph->daddr)];
+  if (eid_entry->locator_list[loc_index]) {
+      locator_addr = eid_entry->locator_list[loc_index]->locator.address.ip.s_addr;
+  } else {
+      printk(KERN_INFO "    Invalid locator list!\n");
+      return NF_ACCEPT;
+  }
+
+  /* 
+   * Prepend UDP, LISP, outer IP header
+   */
+  lisp_encap4(packet_buf, locator_addr, AF_INET);
+
+  eid_entry->locator_list[loc_index]->data_packets_out++;
+
+#ifdef DEBUG_PACKETS
+  printk(KERN_INFO "       Using locator address: %pI4\n", &locator_addr);
+#endif
+
+  /* 
+   * In all liklihood we've disposed of the orignal skb
+   * for size reasons. We must transmit it ourselves, and
+   * force the upper-layers to conside it gone.
+   */
+  return NF_STOLEN;
+}
Index: package/lisp_mod/src/version.h
===================================================================
--- package/lisp_mod/src/version.h	(revision 0)
+++ package/lisp_mod/src/version.h	(revision 0)
@@ -0,0 +1,3 @@
+#define MAJOR_VERSION 0
+#define MINOR_VERSION 0
+#define PATCH_VERSION 1
Index: package/lisp_mod/src/lisp_input.h
===================================================================
--- package/lisp_mod/src/lisp_input.h	(revision 0)
+++ package/lisp_mod/src/lisp_input.h	(revision 0)
@@ -0,0 +1,37 @@
+/*
+ * lisp_input.h
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Packet input path declarations for LISP module.
+ *
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    Chris White       <chris@logicalelegance.com>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+#pragma once
+
+unsigned int lisp_input(unsigned int hooknum,  struct sk_buff *packet_buf,
+			const struct net_device *input_dev,
+			const struct net_device *output_dev,
+			int (*okfunc)(struct sk_buff*));
Index: package/lisp_mod/src/lisp_output.h
===================================================================
--- package/lisp_mod/src/lisp_output.h	(revision 0)
+++ package/lisp_mod/src/lisp_output.h	(revision 0)
@@ -0,0 +1,45 @@
+/*
+ * lisp_output.h
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Packet output path declarations for LISP module.
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    Chris White       <chris@logicalelegance.com>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+#pragma once
+
+unsigned int lisp_output4(unsigned int hooknum, struct sk_buff *packet_buf,
+			 const struct net_device *input_dev,
+			 const struct net_device *output_dev,
+			  int (*okfunc)(struct sk_buff*));
+
+unsigned int lisp_output6(unsigned int hooknum, struct sk_buff *packet_buf,
+			 const struct net_device *input_dev,
+			 const struct net_device *output_dev,
+			 int (*okfunc)(struct sk_buff*));
+
+bool is_v4addr_local(struct iphdr *iph);
+
Index: package/lisp_mod/src/Makefile
===================================================================
--- package/lisp_mod/src/Makefile	(revision 0)
+++ package/lisp_mod/src/Makefile	(revision 0)
@@ -0,0 +1,3 @@
+EXTRA_CFLAGS += -Wno-strict-prototypes
+obj-m += lisp.o 
+lisp-objs += ./lib/patricia/patricia.o lisp_mod.o tables.o lisp_input.o lisp_ipc.o lisp_output.o lisp_slab.o
Index: package/lisp_mod/Makefile
===================================================================
--- package/lisp_mod/Makefile	(revision 0)
+++ package/lisp_mod/Makefile	(revision 0)
@@ -0,0 +1,48 @@
+#
+# OpenWrt LISP_mod Package
+# Vasileios Lakafosis (vasileios@gatech.edu)
+#
+
+include $(TOPDIR)/rules.mk
+include $(INCLUDE_DIR)/kernel.mk
+
+PKG_NAME:=lisp_mod
+PKG_RELEASE:=1
+PKG_VERSION:=0.1
+
+PKG_BUILD_DIR:=$(KERNEL_BUILD_DIR)/$(PKG_NAME)
+include $(INCLUDE_DIR)/package.mk
+
+define KernelPackage/$(PKG_NAME)
+  SUBMENU:=Network Support
+  TITLE:=LISP en/decapsulation support
+  URL:=http://lisp.cisco.com/
+  FILES:=$(PKG_BUILD_DIR)/lisp.$(LINUX_KMOD_SUFFIX)
+  AUTOLOAD:=$(call AutoLoad,50,$(PKG_NAME))
+endef
+
+define KernelPackage/$(PKG_NAME)/description
+ This package contains an en/decapsulation interface driver by Vasileios.
+endef
+
+define Build/Prepare
+	mkdir -p $(PKG_BUILD_DIR)
+	$(CP) -r ./src/* $(PKG_BUILD_DIR)/
+endef
+
+define Build/Compile
+	$(MAKE) -C "$(LINUX_DIR)" \
+		ARCH="$(LINUX_KARCH)" \
+		CROSS_COMPILE="$(TARGET_CROSS)" \
+		SUBDIRS="$(PKG_BUILD_DIR)" \
+		M="$(PKG_BUILD_DIR)" \
+		V="$(V)" \
+		modules
+endef
+
+define KernelPackage/$(PKG_NAME)/install
+	$(INSTALL_DIR) $(1)/usr/sbin
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/*.ko $(1)/usr/sbin
+endef
+
+$(eval $(call KernelPackage,$(PKG_NAME)))
Index: package/lisp/files/lispd.conf
===================================================================
--- package/lisp/files/lispd.conf	(revision 0)
+++ package/lisp/files/lispd.conf	(revision 0)
@@ -0,0 +1,43 @@
+#
+#       lispd config
+#
+debug	= on
+map-request-retries	= 3	# send 3 before giving up
+
+map-resolver	= 172.27.248.238
+proxy-etr	= 149.20.48.60
+
+map-server {
+	address		= 172.27.248.238
+	key-type	= 0		        # cleartext
+	key		= lisppass		# available keys
+	verify		= off	                # on --> lig(self)
+	proxy-reply	= on	                # ask ms to proxy reply
+}
+
+database-mapping {
+	eid-prefix 	= 192.168.250.16/28
+	interface 	= eth1 
+	priority 	= 1  
+	weight 		= 100
+}
+#
+#database-mapping {
+#        eid-prefix = 192.168.250.11/32 
+#	interface  = eth1
+#        priority   = 1
+#        weight     = 50
+#}
+# database-mapping {
+#          eid-prefix = 2610:00d0:120A::153:16:254:1/128
+#          rloc       = eth0
+#          priority   = 1 
+#          weight     = 50
+#}
+#
+#static-map-cache {
+#	eid-prefix	= 153.16.17.9
+#	rloc		= 172.16.206.129
+#	priority	= 1
+#	weight		= 100
+#}
Index: package/lisp/files/stop-LISP.sh
===================================================================
--- package/lisp/files/stop-LISP.sh	(revision 0)
+++ package/lisp/files/stop-LISP.sh	(revision 0)
@@ -0,0 +1,10 @@
+#!/bin/sh
+# Stop LISP-MN on OpenWrt
+# Vasileios Lakafosis (vlakafos@cisco.com)
+#
+
+killall -9 lispd
+
+rmmod lisp.ko;
+rmmod lisp_int.ko;
+#cp out /home/logs/out-$(date -u +%d%b%Y)-$(date +%H-%M-%S)

Property changes on: package/lisp/files/stop-LISP.sh
___________________________________________________________________
Added: svn:executable
   + *

Index: package/lisp/files/start-LISP.sh
===================================================================
--- package/lisp/files/start-LISP.sh	(revision 0)
+++ package/lisp/files/start-LISP.sh	(revision 0)
@@ -0,0 +1,39 @@
+#!/bin/sh
+# start LISP-MN on OpenWrt
+# Vasileios Lakafosis (vlakafos@cisco.com)
+#
+
+echo +++++++++++++++++++++++++++ 
+echo Starting LISP-MN on OpenWrt
+echo +++++++++++++++++++++++++++ 
+
+US_PATH="/usr/sbin/lisp"
+KMOD_PATH="/usr/sbin"
+CONF_PATH="/lib/network/lisp"
+IF_NAME="eth1"
+
+# RLOC used in ip rules for source routing
+#RLOC="128.107.165.94"
+RLOC=`/sbin/ifconfig eth1 | sed '/inet\ /!d;s/.*r://g;s/\ .*//g'`
+
+#ip addr flush dev $IF_NAME
+ip rule del from $RLOC table 5 		#repeat if needed for every rule that was added
+ip rule del from $RLOC table 5 		#repeat if needed for every rule that was added
+ip rule del from $RLOC table 5 		#repeat if needed for every rule that was added
+#rmmod lisp.ko;
+#rmmod lisp_int.ko;
+sleep 2
+insmod ${KMOD_PATH}/lisp_int.ko
+sleep 3 
+insmod ${KMOD_PATH}/lisp.ko
+sleep 3 
+
+echo +++++++++ Calling lispd +++++++++++++++++++++
+#${US_PATH}/lispd --config-file ${CONF_PATH}/lispd_BETA.conf -d 2>&1 | tee out &
+${US_PATH}/lispd --config-file ${CONF_PATH}/lispd_BETA.conf &
+#${US_PATH}/lispd --config-file ${CONF_PATH}/lispd_Bld24.conf &
+
+sleep 7 
+EID=`/sbin/ifconfig lmn0 | sed '/inet\ /!d;s/.*r://g;s/\ .*//g'`
+echo +++++++++  DHCP  ++++++++++++++++++++++++++++
+/sbin/udhcpc -i $IF_NAME 

Property changes on: package/lisp/files/start-LISP.sh
___________________________________________________________________
Added: svn:executable
   + *

Index: package/lisp/src/timerfd.h
===================================================================
--- package/lisp/src/timerfd.h	(revision 0)
+++ package/lisp/src/timerfd.h	(revision 0)
@@ -0,0 +1,60 @@
+/* Copyright (C) 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_TIMERFD_H
+#define	_SYS_TIMERFD_H	1
+
+#include <time.h>
+
+
+/* Bits to be set in the FLAGS parameter of `timerfd_create'.  */
+enum
+  {
+    TFD_CLOEXEC = 02000000,
+#define TFD_CLOEXEC TFD_CLOEXEC
+    TFD_NONBLOCK = 04000
+#define TFD_NONBLOCK TFD_NONBLOCK
+  };
+
+
+/* Bits to be set in the FLAGS parameter of `timerfd_settime'.  */
+enum
+  {
+    TFD_TIMER_ABSTIME = 1 << 0
+#define TFD_TIMER_ABSTIME TFD_TIMER_ABSTIME
+  };
+
+
+__BEGIN_DECLS
+
+/* Return file descriptor for new interval timer source.  */
+extern int timerfd_create (clockid_t __clock_id, int __flags) __THROW;
+
+/* Set next expiration time of interval timer source UFD to UTMR.  If
+   FLAGS has the TFD_TIMER_ABSTIME flag set the timeout value is
+   absolute.  Optionally return the old expiration time in OTMR.  */
+extern int timerfd_settime (int __ufd, int __flags,
+			    __const struct itimerspec *__utmr,
+			    struct itimerspec *__otmr) __THROW;
+
+/* Return the next expiration time of UFD.  */
+extern int timerfd_gettime (int __ufd, struct itimerspec *__otmr) __THROW;
+
+__END_DECLS
+
+#endif /* sys/timerfd.h */
Index: package/lisp/src/lispd_config.c
===================================================================
--- package/lisp/src/lispd_config.c	(revision 0)
+++ package/lisp/src/lispd_config.c	(revision 0)
@@ -0,0 +1,717 @@
+/*
+ * lispd_config.c
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Handle lispd command line and config file
+ * Parse command line args using gengetopt.
+ * Handle config file with libconfuse.
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    David Meyer		<dmm@cisco.com>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+#include "cmdline.h"
+#include "confuse.h"
+#include "lispd_external.h"
+
+
+/*
+ *	handle_lispd_command_line --
+ *
+ *	Get command line args and set up whatever is needed
+ *
+ *	David Meyer
+ *	dmm@1-4-5.net
+ *	Wed Apr 21 13:31:00 2010
+ *
+ *	$Header: /usr/local/src/lispd/RCS/lispd_config.c,v 1.16 2010/04/21 23:32:08 root Exp $
+ *
+ */
+
+handle_lispd_command_line(int argc, char **argv) 
+{
+    struct gengetopt_args_info args_info;
+
+    if (cmdline_parser(argc, argv, &args_info) != 0) 
+	exit(0);
+
+    if (args_info.nodaemonize_given) {
+	daemonize = 0;
+    }
+    if (args_info.config_file_given) {
+	config_file = strdup(args_info.config_file_arg);
+    }
+    if (args_info.map_request_retries_given) {
+        map_request_retries = args_info.map_request_retries_arg;
+    }
+
+    return(0);
+}
+
+/*
+ *	handle_lispd_config_file --
+ *
+ *	Parse config file and set up whatever is needed
+ *
+ *	David Meyer
+ *	dmm@1-4-5.net
+ *	Wed Apr 21 13:31:00 2010
+ *
+ *	$Header: /usr/local/src/lispd/RCS/lispd_config.c,v 1.16 2010/04/21 23:32:08 root Exp $
+ *
+ */
+
+handle_lispd_config_file() 
+{
+    cfg_t		*cfg   = 0;
+    unsigned int	i      = 0;
+    unsigned		n      = 0;
+    int			ret    = 0;
+
+    static cfg_opt_t map_server_opts[] = {
+	CFG_STR("address",		0, CFGF_NONE),
+	CFG_INT("key-type",		0, CFGF_NONE),
+	CFG_STR("key",			0, CFGF_NONE),
+	CFG_BOOL("proxy-reply",		cfg_false, CFGF_NONE),
+	CFG_BOOL("verify",		cfg_false, CFGF_NONE),
+	CFG_END()
+    };
+
+    static cfg_opt_t db_mapping_opts[] = {
+        CFG_STR("eid-prefix",           0, CFGF_NONE),
+        CFG_STR("interface",            0, CFGF_NONE),
+        CFG_INT("priority",             0, CFGF_NONE),
+        CFG_INT("weight",               0, CFGF_NONE),
+        CFG_END()
+    };
+
+    static cfg_opt_t mc_mapping_opts[] = {
+        CFG_STR("eid-prefix",           0, CFGF_NONE),
+        CFG_STR("rloc",                 0, CFGF_NONE),
+        CFG_INT("priority",             0, CFGF_NONE),
+        CFG_INT("weight",               0, CFGF_NONE),
+        CFG_END()
+    };
+
+    cfg_opt_t opts[] = {
+        CFG_SEC("database-mapping",     db_mapping_opts, CFGF_MULTI),
+        CFG_SEC("static-map-cache",     mc_mapping_opts, CFGF_MULTI),
+	CFG_SEC("map-server",		map_server_opts, CFGF_MULTI),
+	CFG_INT("map-request-retries",	0, CFGF_NONE),
+	CFG_INT("control-port",		0, CFGF_NONE),
+	CFG_BOOL("debug",		cfg_false, CFGF_NONE),
+	CFG_STR("map-resolver",		0, CFGF_NONE),
+	CFG_STR("proxy-etr",		0, CFGF_NONE),
+	CFG_END()
+    };
+
+    /*
+     *	parse config_file
+     */
+
+    cfg = cfg_init(opts, CFGF_NOCASE);
+    ret = cfg_parse(cfg, config_file);
+
+    if (ret == CFG_FILE_ERROR) {
+        syslog(LOG_DAEMON, "Couldn't find config file (%s)", config_file);
+        return 1;
+    } else if(ret == CFG_PARSE_ERROR) {
+        syslog(LOG_DAEMON, "Parse error (%s)", config_file);
+        return 2;
+    }
+
+    
+    /*
+     *	lispd config options
+     */
+
+    if (ret = cfg_getint(cfg, "map-request-retries"))
+	map_request_retries = ret;
+
+    cfg_getbool(cfg, "debug") ? (debug = 1) : (debug = 0); 
+
+    /*
+     *	LISP config options
+     */
+
+    /*
+     *	handle map-resolver config
+     */
+
+    map_resolver = cfg_getstr(cfg, "map-resolver");
+    if (!add_server(map_resolver, &map_resolvers))
+	return(0); 
+#ifdef DEBUG
+    syslog(LOG_DAEMON, "Added %s to map-resolver list", map_resolver);
+#endif
+
+    /*
+     *	handle proxy-etr config
+     */
+
+    if (proxy_etr = cfg_getstr(cfg, "proxy-etr")) {
+        if (!add_server(proxy_etr, &proxy_etrs))
+            return(0); 
+#ifdef DEBUG
+        syslog(LOG_DAEMON, "Added %s to proxy-etr list", proxy_etr);
+#endif
+    }
+
+    /*
+     *	handle database-mapping config
+     */
+
+    if (n = cfg_size(cfg, "database-mapping")) {
+	for(i = 0; i < n; i++) {
+	    cfg_t *dm = cfg_getnsec(cfg, "database-mapping", i);
+            if (!add_database_mapping(dm)) {
+		syslog(LOG_DAEMON, "Can't add database-mapping %d (%s->%s)",
+		       i,
+		       cfg_getstr(dm, "eid-prefix"),
+		       cfg_getstr(dm, "interface"));
+	    }
+	}
+    }
+
+    /*
+     *	handle map-server config
+     */
+
+    if (n = cfg_size(cfg, "map-server")) {
+	for(i = 0; i < n; i++) {
+	    cfg_t *ms = cfg_getnsec(cfg, "map-server", i);
+            if (!add_map_server(cfg_getstr(ms, "address"),
+                                cfg_getint(ms, "key-type"),
+				cfg_getstr(ms, "key"),
+				(cfg_getbool(ms, "proxy-reply") ? 1:0),
+				(cfg_getbool(ms, "verify")      ? 1:0)))
+
+		return(0);
+#ifdef DEBUG
+	    syslog(LOG_DAEMON, "Added %s to map-server list",
+		    cfg_getstr(ms, "address"));
+#endif
+	}
+    }
+
+    /*
+     *	handle static-map-cache config
+     */
+
+    if (n = cfg_size(cfg, "static-map-cache")) {
+	for(i = 0; i < n; i++) {
+	    cfg_t *smc = cfg_getnsec(cfg, "static-map-cache", i);
+            if (!add_static_map_cache_entry(smc)) {
+		syslog(LOG_DAEMON,"Can't add static-map-cache %d (%s->%s)",
+		       i,
+		       cfg_getstr(smc, "eid-prefix"),
+		       cfg_getstr(smc, "rloc"));
+	    }
+	}
+    }
+
+
+#if (DEBUG > 3)
+    syslog(LOG_DAEMON,"vlakafos: dump from lispd_config.c");
+    dump_tree(AF_INET,AF4_database);
+    dump_tree(AF_INET6,AF6_database);
+    dump_database(AF4_database,AF_INET);
+    dump_database(AF6_database,AF_INET6);
+    dump_map_servers();
+    dump_servers(map_resolvers, "map-resolvers");
+    dump_servers(proxy_etrs, "proxy-etrs");
+    dump_map_cache();
+#endif
+
+    return(0);
+}
+
+/*
+ *	add_database_mapping
+ *
+ *	Get a single database mapping 
+ *
+ *	David Meyer <dmm@1-4-5.net>
+ *      Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+add_database_mapping(dm)
+     cfg_t      *dm;
+{
+
+    lispd_addr_t                *rloc_ptr;
+    char                        *token;
+    char                        *eid;           /* save the eid_prefix here */
+    int                         afi;
+    patricia_node_t             *node;
+    lispd_db_entry_t            *db_entry;
+    lispd_locator_chain_t       *locator_chain;
+    lispd_locator_chain_elt_t   *locator_chain_elt;
+
+    char   *eid_prefix        = cfg_getstr(dm, "eid-prefix");
+    char   *iface_name        = cfg_getstr(dm, "interface");
+    int    priority           = cfg_getint(dm, "priority");
+    int    weight             = cfg_getint(dm, "weight");
+    eid = eid_prefix;           /* save this for later */
+
+    char *eid_pref_for_add_iface = strdup (eid_prefix);
+    lispd_addr_t eid_addr;
+    memset(&eid_addr, 0, sizeof(lispd_addr_t));
+    afi = get_afi(eid_prefix);  
+    eid_addr.afi = afi;
+
+    /*
+     *  find or make the node correspoding to the eid_prefix/length 
+     */
+
+    switch(afi) {
+    case        AF_INET:
+        node = make_and_lookup(AF4_database, AF_INET, eid);
+        break;
+    case        AF_INET6:
+        node = make_and_lookup(AF6_database, AF_INET6, eid);
+        break;
+    default:
+        syslog(LOG_DAEMON, "Unknown AFI (%d) for %s", afi, eid);
+    }
+
+    if (node == NULL) {
+        syslog(LOG_DAEMON, "Couldn't allocate patricia node");
+        return(0);
+    }
+
+    if (if_nametoindex(iface_name) == 0) {
+        syslog(LOG_DAEMON, "Invalid interface: %s\n", iface_name);
+        return (0);
+    }
+
+    /* 
+     * PN: Add this physical interface to the list of tracked
+     * interfaces (for iface management purposes).
+     * In case of multiple physical interfaces per EID,
+     * each physical interface must be added via update_iface_list()
+     */
+    if (!update_iface_list (iface_name, eid, NULL, 
+                1, priority, weight)) {
+        syslog(LOG_DAEMON, "add_iface (%s) failed\b", iface_name);
+        return(0);
+    } 
+
+    if ((token = strtok(eid_prefix, "/")) == NULL) {
+        syslog(LOG_DAEMON,"eid prefix not of the form prefix/length");
+        return(0);
+    }
+
+    /* 
+     *  get the EID prefix into the right place/format
+     */
+
+    if (inet_pton(afi, token, &eid_addr.address) != 1) {
+        syslog(LOG_DAEMON, "inet_pton: %s", strerror(errno));
+        return(0);
+    }
+
+    /*
+     *  get the prefix length into token
+     */
+
+    if ((token = strtok(NULL,"/")) == NULL) {
+        syslog(LOG_DAEMON, "strtok: %s", strerror(errno));
+        return(0);
+    }
+
+    /* 
+     * PN: Setup the LISP-MN interface (ex: lmn0) for this EID.
+     * Assume single EID/LISP-MN interface per MN for now.
+     * Multiple EIDs per MN is a possibility in the future; then
+     * each EID requires its own LISP-MN interface and 
+     * one of the interfaces will be the default one.
+     */
+    if (!setup_lisp_eid_iface(LISP_MN_EID_IFACE_NAME, 
+                &eid_addr,
+                atoi (token))) {
+        syslog(LOG_DAEMON, "setup_lisp_eid_iface (%s) failed\b", iface_name);
+    } 
+
+    if ((rloc_ptr = (lispd_addr_t *) malloc(sizeof(lispd_addr_t))) == NULL) {
+        syslog(LOG_DAEMON,"malloc(sizeof(lispd_addr_t)): %s", strerror(errno));
+        return(0);
+    }
+    memset(rloc_ptr,0,sizeof(lispd_addr_t));
+
+    if (!lispd_get_iface_address(iface_name,rloc_ptr)) {
+        syslog(LOG_DAEMON, "Can't get address for %s", iface_name);
+        free(rloc_ptr);
+        return(0);
+    }
+
+    if ((db_entry = (lispd_db_entry_t *)
+         malloc(sizeof(lispd_db_entry_t))) == NULL) {
+        syslog(LOG_DAEMON,"malloc(sizeof(lispd_database_t)): %s", strerror(errno));
+        return(0);
+    }
+
+    memset(db_entry,0,sizeof(lispd_db_entry_t));
+
+    db_entry->locator_name = strdup(iface_name);        /* save the name */
+
+    /*
+     *  store the locator address and afi
+     */
+
+    memcpy((void *) &(db_entry->locator.address),
+           (void *) &(rloc_ptr->address),
+           sizeof(lisp_addr_t));
+    db_entry->locator_afi = rloc_ptr->afi;
+
+    memcpy((void *) &(db_entry->eid_prefix.address),
+           (void *) &(eid_addr.address),
+           sizeof(lisp_addr_t));
+    db_entry->eid_prefix_length = atoi(token);
+    db_entry->eid_prefix_afi    = afi;
+
+    db_entry->priority          = priority;
+    db_entry->weight            = weight;
+    db_entry->mpriority         = 255;
+    db_entry->mweight           = 0;
+
+    if (node->data == NULL) {           /* its a new node */
+        if ((locator_chain = malloc(sizeof(lispd_locator_chain_t))) == NULL) {
+            syslog(LOG_DAEMON, "Can't malloc(sizeof(lispd_locator_chain_t))");
+            free(rloc_ptr);
+            free(db_entry);
+            free(eid);
+            return(0);
+        }
+        memset(locator_chain,0,sizeof(lispd_locator_chain_t));
+
+        node->data = (lispd_locator_chain_t *) locator_chain;   /* set up chain */
+
+        /*
+         *      put the eid_prefix information into the locator_chain
+         */
+
+        copy_lisp_addr_t(&(locator_chain->eid_prefix),
+                         &(db_entry->eid_prefix),
+                         db_entry->eid_prefix_afi,
+                         0);            
+        locator_chain->eid_prefix_length    = db_entry->eid_prefix_length;
+        locator_chain->eid_prefix_afi       = db_entry->eid_prefix_afi;
+        locator_chain->eid_name             = strdup(eid);
+        locator_chain->has_dynamic_locators = DYNAMIC_LOCATOR;
+        locator_chain->timer                = DEFAULT_MAP_REGISTER_TIMEOUT;
+    } else {                            /* there's an existing locator_chain */
+        locator_chain = (lispd_locator_chain_t *) node->data;   /* have one */
+    }
+
+    if ((locator_chain_elt = malloc(sizeof(lispd_locator_chain_elt_t))) == NULL) {
+        syslog(LOG_DAEMON, "Can't malloc(sizeof(lispd_locator_chain_elt_t))");
+        free(rloc_ptr);
+        free(db_entry);
+        free(eid);
+        return(0);
+    }
+
+#if (DEBUG > 3)
+    char x[128];
+    memset(x,0,128);
+    inet_ntop(locator_chain->eid_prefix_afi,
+              &(locator_chain->eid_prefix),
+              x, 128);
+    printf("add_database_mapping: locator_chain->eid_prefix = %s (0x%x)\n" ,x, locator_chain);
+#endif
+
+    memset(locator_chain_elt, 0, sizeof(lispd_locator_chain_elt_t));
+
+    /*
+     *  link up db_entry
+     */
+
+    locator_chain_elt->db_entry      = db_entry;  
+    locator_chain_elt->locator_name  = db_entry->locator_name;
+
+    /*
+     *  connect up the locator_chain and locator_chain_elt
+     */
+    if (locator_chain->head == NULL) {
+        locator_chain->head = locator_chain_elt;
+        locator_chain->tail = locator_chain_elt;
+    } else {
+        locator_chain->tail->next = locator_chain_elt;
+        locator_chain->tail       = locator_chain_elt;
+    }
+
+    locator_chain->locator_count ++;
+       
+    /* 
+     * PN: Update interface information with the new rloc 
+     * information
+     */
+    if (!update_iface_list (iface_name, eid_pref_for_add_iface, 
+                db_entry, 1, priority, weight)) {
+        syslog(LOG_DAEMON, "update_iface_list: (%s) failed\b", iface_name);
+    }
+
+    /* 
+     * PN: Find an active interface for lispd control messages
+     */
+    if (ctrl_iface == NULL)
+        ctrl_iface = find_active_ctrl_iface();
+
+    free(rloc_ptr);
+    return(1);
+}
+
+/*
+ *	add_static_map_cache_entry --
+ *
+ *	Get a single static mapping
+ *
+ *	David Meyer
+ *	dmm@1-4-5.net
+ *	Wed Apr 21 13:31:00 2010
+ *
+ *	$Header: /usr/local/src/lispd/RCS/lispd_config.c,v 1.16 2010/04/21 23:32:08 root Exp $
+ *
+ */
+
+add_static_map_cache_entry(smc)
+     cfg_t	*smc;
+{
+
+    lispd_addr_t	        *rloc_ptr;
+    lispd_map_cache_t		*map_cache;
+    lispd_map_cache_entry_t     *map_cache_entry;
+    
+    char			*token;
+    int				afi;
+    uint32_t			flags = 0;
+
+    char   *eid_prefix  = cfg_getstr(smc, "eid-prefix");
+    char   *rloc        = cfg_getstr(smc, "rloc");
+    int    priority     = cfg_getint(smc, "priority");
+    int    weight       = cfg_getint(smc, "weight");
+
+    if ((rloc_ptr = (lispd_addr_t *) malloc(sizeof(lispd_addr_t))) == NULL) {
+	syslog(LOG_DAEMON, "malloc(sizeof(lispd_addr_t)): %s", strerror(errno));
+	return(0);
+    }
+    if ((map_cache = (lispd_map_cache_t *)
+	 malloc(sizeof(lispd_map_cache_t))) == NULL) {
+	syslog(LOG_DAEMON, "malloc(sizeof(lispd_map_cache_t)): %s", strerror(errno));
+	return(0);
+    }
+    memset(rloc_ptr, 0,sizeof(lispd_addr_t));
+    memset(map_cache,0,sizeof(lispd_map_cache_t));
+
+    map_cache_entry = &(map_cache->map_cache_entry);
+
+    if (!lispd_get_address(rloc,rloc_ptr,&flags)) {
+        free(rloc_ptr);
+        free(map_cache);
+	return(0);
+    }
+
+    /*
+     *	store the locator address and afi
+     */
+
+    memcpy((void *) &(map_cache_entry->locator.address),
+	   (void *) &(rloc_ptr->address),
+	   sizeof(lisp_addr_t));
+    map_cache_entry->locator_afi  = rloc_ptr->afi;
+    map_cache_entry->ttl          = 255;	/*shouldn't matter */
+    map_cache_entry->locator_name = strdup(rloc);
+    map_cache_entry->locator_type = flags;
+
+    map_cache_entry->how_learned  = STATIC_MAP_CACHE_ENTRY;
+
+    afi = get_afi(eid_prefix);
+
+    if ((token = strtok(eid_prefix, "/")) == NULL) {
+	sprintf(msg,"eid prefix not of the form prefix/length ");
+	syslog(LOG_DAEMON, "%s", msg);
+        free(rloc_ptr);
+        free(map_cache);
+	return(0);
+    }
+
+    /* 
+     *	get the EID prefix into the right place/format
+     */
+
+    if (inet_pton(afi, token, &(map_cache_entry->eid_prefix.address)) != 1) {
+	syslog(LOG_DAEMON, "inet_pton: %s (%s)", strerror(errno), token);
+        free(rloc_ptr);
+        free(map_cache);
+	return(0);
+    }
+
+    /*
+     *	get the prefix length into token
+     */
+
+    if ((token = strtok(NULL,"/")) == NULL) {
+	syslog(LOG_DAEMON,"strtok: %s", strerror(errno));
+        free(rloc_ptr);
+        free(map_cache);
+	return(0);
+    }
+
+    map_cache_entry->eid_prefix_length = atoi(token);
+    map_cache_entry->eid_prefix_afi    = afi;
+    map_cache_entry->priority          = priority;
+    map_cache_entry->weight            = weight;
+
+    if (lispd_database) 
+	map_cache->next = lispd_map_cache;
+    else
+	map_cache->next = NULL;
+    lispd_map_cache = map_cache;
+
+    free(rloc_ptr);
+    return(1);
+}
+
+/*
+ *	add a map-resolver to the list
+ */
+
+add_server(server, list)
+     char		*server;
+     lispd_addr_list_t	**list;
+{
+
+    uint		afi;
+    lispd_addr_t	*addr;
+    lispd_addr_list_t  *list_elt;
+ 
+    if ((addr = (lispd_addr_t *) malloc(sizeof(lispd_addr_t))) == NULL) {
+	syslog(LOG_DAEMON, "malloc(sizeof(lispd_addr_t)): %s", strerror(errno));
+	return(0);
+    }
+    memset(addr,0,sizeof(lispd_addr_t));
+
+    afi = get_afi(server);
+    addr->afi = afi;
+
+    if (inet_pton(afi, server, &(addr->address.address)) != 1) {
+	syslog(LOG_DAEMON, "inet_pton: %s", strerror(errno));
+        free(addr);
+	return(0);
+    }
+
+    if ((list_elt =
+	 (lispd_addr_list_t *) malloc(sizeof(lispd_addr_list_t))) == NULL) {
+	syslog(LOG_DAEMON, "malloc(sizeof(lispd_addr_list_t)): %s", strerror(errno));
+	free(addr);
+	return(0);
+    }
+    memset(list_elt,0,sizeof(lispd_addr_list_t));
+
+    list_elt->address = addr;
+
+    /*
+     * hook this one to the front of the list
+     */
+
+    if (*list) {
+	list_elt->next = *list;
+	*list = list_elt;
+    } else 
+	*list = list_elt;
+
+    return(1);
+}
+
+/*
+ *	add_map_server to map_servers
+ */
+
+add_map_server(map_server, key_type, key, proxy_reply,verify)
+     char	*map_server;
+     int	key_type;
+     char	*key;
+     uint8_t	proxy_reply;
+     uint8_t	verify;
+{
+    int			     flags;
+    lispd_addr_t	    *addr;
+    lispd_map_server_list_t *list_elt;
+    struct hostent	    *hptr;
+
+    if ((addr = (lispd_addr_t *) malloc(sizeof(lispd_addr_t))) == NULL) {
+	syslog(LOG_DAEMON, "malloc(sizeof(lispd_addr_t)): %s", strerror(errno));
+	return(0);
+    }
+
+    /*
+     *	make sure this is clean
+     */
+
+    memset(addr,0,sizeof(lispd_addr_t));
+
+    if (((hptr = gethostbyname2(map_server,AF_INET))  == NULL) &&
+	((hptr = gethostbyname2(map_server,AF_INET6)) == NULL)) {
+	syslog(LOG_DAEMON,
+	       "can gethostbyname2 for map_server (%s)", map_server);
+        free(addr);
+	return(0);
+    }
+
+    memcpy((void *) &(addr->address.address),
+	   (void *) *(hptr->h_addr_list), sizeof(lisp_addr_t));
+    addr->afi = hptr->h_addrtype;
+
+    if ((list_elt = (lispd_map_server_list_t *)
+	 malloc(sizeof(lispd_map_server_list_t))) == NULL) {
+	sprintf(msg,"malloc(sizeof(lispd_map_server_list_t)) failed");
+	syslog(LOG_DAEMON, "%s", msg);
+	free(addr);
+	return(0);
+    }
+
+    memset(list_elt,0,sizeof(lispd_map_server_list_t));
+
+    list_elt->address     = addr;
+    list_elt->key_type    = key_type;
+    list_elt->key	  = strdup(key);
+    list_elt->verify      = verify;
+    list_elt->proxy_reply = proxy_reply;
+
+    /*
+     * hook this one to the front of the list
+     */
+
+    if (map_servers) {
+	list_elt->next = map_servers;
+	map_servers = list_elt;
+    } else 
+	map_servers = list_elt;
+
+    return(1);
+}
+
+
Index: package/lisp/src/lispd_lib.c
===================================================================
--- package/lisp/src/lispd_lib.c	(revision 0)
+++ package/lisp/src/lispd_lib.c	(revision 0)
@@ -0,0 +1,1468 @@
+/*
+ * lispd_lib.c
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Various library routines.
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    David Meyer		<dmm@cisco.com>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+#include <arpa/inet.h>
+#include <ctype.h>
+#include <errno.h>
+#include <ifaddrs.h>
+#include <inttypes.h>
+#include <netdb.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <netinet/in_systm.h>
+#include <netinet/ip6.h>
+#include <netinet/ip.h>
+#include <netinet/udp.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <strings.h>
+#include <sys/ioctl.h>
+#include <syslog.h>
+#include <sys/param.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include "linux/netlink.h"
+#include "lispd_external.h"
+
+/*
+ *      build_receive_sockets
+ *
+ *      Set up the receive sockets. Note that if you use a 
+ *      a random port, which is used as  the source port used 
+ *      in the inner UDP header of the encapsulated 
+ *      map-request. If proxy-reply on, you will receive map-replies
+ *      destined to this port (i.e., the destination port). e.g.,
+ *
+ *      No. Time     Source         Destination     Protocol Info
+ *      97  5.704114 128.223.156.23 128.223.156.117 LISP     Map-Reply
+ *      ...
+ *      Internet Protocol, Src: 128.223.156.23 (128.223.156.23), Dst: 128.223.156.117 (128.223.156.117)
+ *      User Datagram Protocol, Src Port: lisp-control (4342), Dst Port: 48849 (48849)
+ *      Locator/ID Separation Protocol
+ *
+ *      In this case, 48849 was the random source port I put in the 
+ *      inner UDP header source port in the encapsulated map-request 
+ *      which was sent to to the map-server at 128.223.156.23. 
+ *
+ *      So we'll just use src port == dest port == 4342. Note that you
+ *      need to setsockopt SO_REUSEADDR or you'll get bind: address in use. 
+ *
+ */
+
+build_receive_sockets()
+{
+
+    struct protoent     *proto;
+    struct sockaddr_in  v4;
+    struct sockaddr_in6 v6;
+    int                 tr = 1;
+    
+    if ((proto = getprotobyname("UDP")) == NULL) {
+        syslog(LOG_DAEMON, "getprotobyname: %s", strerror(errno));
+        return(0);
+    }
+
+    /*
+     *  build the v4_receive_fd, and make the port reusable
+     */
+
+    if ((v4_receive_fd = socket(AF_INET,SOCK_DGRAM,proto->p_proto)) < 0) {
+        syslog(LOG_DAEMON, "socket (v4): %s", strerror(errno));
+        return(0);
+    }
+
+    if (setsockopt(v4_receive_fd,
+                   SOL_SOCKET,
+                   SO_REUSEADDR,
+                   &tr,
+                   sizeof(int)) == -1) {
+        syslog(LOG_DAEMON, "setsockopt SO_REUSEADDR (v4): %s", strerror(errno));
+        return(0);
+    }
+
+/*
+    if (setsockopt(v4_receive_fd,
+                   SOL_SOCKET,
+                   SO_BINDTODEVICE,
+                   &(ctrl_iface->iface_name),
+                   sizeof(int)) == -1) {
+        syslog(LOG_DAEMON, "setsockopt SO_BINDTODEVICE (v4): %s", strerror(errno));
+    }
+*/
+    memset(&v4,0,sizeof(v4));           /* be sure */
+    v4.sin_port        = htons(LISP_CONTROL_PORT);
+    v4.sin_family      = AF_INET;
+    v4.sin_addr.s_addr = INADDR_ANY;
+
+    if (bind(v4_receive_fd,(struct sockaddr *) &v4, sizeof(v4)) == -1) {
+        syslog(LOG_DAEMON, "bind (v4): %s", strerror(errno));
+        return(0);
+    }
+
+    /*
+     *  build the v6_receive_fd, and make the port reusable
+     */
+
+    if ((v6_receive_fd = socket(AF_INET6,SOCK_DGRAM,proto->p_proto)) < 0) {
+        syslog(LOG_DAEMON, "socket (v6): %s", strerror(errno));
+        return(0);
+    }
+
+    if (setsockopt(v6_receive_fd,
+                   SOL_SOCKET,
+                   SO_REUSEADDR,
+                   &tr,
+                   sizeof(int)) == -1) {
+        syslog(LOG_DAEMON, "setsockopt SO_REUSEADDR (v6): %s", strerror(errno));
+        return(0);
+    }
+
+/*
+    if (setsockopt(v6_receive_fd,
+                   SOL_SOCKET,
+                   SO_BINDTODEVICE,
+                   &(ctrl_iface->iface_name),
+                   sizeof(int)) == -1) {
+        syslog(LOG_DAEMON, "setsockopt SO_BINDTODEVICE (v6): %s", strerror(errno));
+    }
+*/
+
+    memset(&v6,0,sizeof(v6));                   /* be sure */
+    v6.sin6_family   = AF_INET6;
+    v6.sin6_port     = htons(LISP_CONTROL_PORT);
+    v6.sin6_addr     = in6addr_any;
+
+    if (bind(v6_receive_fd,(struct sockaddr *) &v6, sizeof(v6)) == -1) {
+        syslog(LOG_DAEMON, "bind (v6): %s", strerror(errno));
+        return(0);
+    }
+ 
+    return(1);
+}
+  
+
+/*
+ *      get_afi
+ *
+ *      Assume if there's a colon in str that its an IPv6 
+ *      address. Otherwise its v4.
+ *
+ *      David Meyer
+ *      dmm@1-4-5.net
+ *      Wed Apr 21 16:31:34 2010
+ *
+ *      $Header: /usr/local/src/lispd/RCS/lispd_config.c,v 1.16 2010/04/21 23:32:08 root Exp $
+ *
+ */
+
+int get_afi(str)
+     char *str;
+{ 
+    if (strchr(str,':'))                /* poor-man's afi discriminator */
+        return(AF_INET6);
+    else        
+        return(AF_INET);
+}
+
+/*
+ *      copy_lisp_addr_t
+ *
+ *      Copy a lisp_addr_t, converting it using convert
+ *      if supplied
+ */
+
+copy_lisp_addr_t(a1,a2,afi,convert)
+     lisp_addr_t *a1;
+     lisp_addr_t *a2;
+     uint16_t     afi;
+     int          convert;
+{
+    switch(afi) {
+    case AF_INET:
+        if (convert)
+            a1->address.ip.s_addr = htonl(a2->address.ip.s_addr);
+        else 
+            a1->address.ip.s_addr = a2->address.ip.s_addr;
+        break;
+    case AF_INET6:
+            memcpy(a1->address.ipv6.s6_addr,
+                   a2->address.ipv6.s6_addr,
+                   sizeof(struct in6_addr));
+            break;
+        default:
+            syslog(LOG_DAEMON, "copy_lisp_addr_t: Unknown AFI (%d)", afi);
+            return(0);
+    }
+    return(1);
+}
+
+
+
+/*
+ *      copy_addr
+ *
+ *      Copy a lisp_addr_t to a memory location, htonl'ing it
+ *      it convert != 0. Return the length or 0;
+ */
+
+copy_addr(a1,a2,afi,convert)
+     void *a1;
+     lisp_addr_t *a2;
+     int  afi;
+     int convert;
+{
+
+    switch(afi) {
+    case AF_INET:
+        if (convert)
+            ((struct in_addr *) a1)->s_addr = htonl(a2->address.ip.s_addr);
+        else 
+            ((struct in_addr *) a1)->s_addr = a2->address.ip.s_addr;
+        return(sizeof(struct in_addr));
+    case AF_INET6:
+        memcpy(((struct in6_addr *) a1)->s6_addr,
+               a2->address.ipv6.s6_addr,
+               sizeof(struct in6_addr));
+        return(sizeof(struct in6_addr));
+    default:
+        syslog(LOG_DAEMON, "copy_addr: Unknown AFI (%d)", afi);
+        return(0);
+    }
+}
+
+
+/*
+ *      find a useable source address with AFI = afi
+ */
+ 
+/* TODO (LJ): To avoid memory leaks, the lispd_addr_t should be allocated
+ *            by caller and a pointer passed as parameter. Update calls! */
+lispd_addr_t *get_my_addr(if_name, afi)
+     char       *if_name;
+     int        afi;
+{
+    lispd_addr_t        *addr;    
+    struct ifaddrs      *ifaddr;
+    struct ifaddrs      *ifa;
+    struct sockaddr_in  *s4;
+    struct sockaddr_in6 *s6;
+
+    if ((addr = malloc(sizeof(lispd_addr_t))) == NULL) {
+        syslog(LOG_DAEMON, "malloc (get_my_addr): %s", strerror(errno));
+        return(0);
+    }
+
+    memset(addr,0,sizeof(lispd_addr_t));
+
+    if (getifaddrs(&ifaddr) !=0) {
+        syslog(LOG_DAEMON, "getifaddrs(get_my_addr): %s", strerror(errno));
+        free(addr);
+        return(0);
+    }
+
+    for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
+        if ((ifa->ifa_addr             == NULL) ||
+            ((ifa->ifa_flags & IFF_UP) == 0)    ||
+            (ifa->ifa_addr->sa_family  != afi)  ||
+            strcmp(ifa->ifa_name, if_name))
+            continue;
+        switch(ifa->ifa_addr->sa_family) {
+        case AF_INET:
+            s4 = (struct sockaddr_in *)(ifa->ifa_addr);
+            memcpy((void *) &(addr->address.address),
+                   (void *)&(s4->sin_addr), sizeof(struct sockaddr_in));
+            addr->afi = (ifa->ifa_addr)->sa_family;
+            freeifaddrs(ifaddr);
+            return(addr);
+        case AF_INET6:
+            s6 = (struct sockaddr_in6 *)(ifa->ifa_addr);
+            memcpy((void *) &(addr->address.address),
+                   (void *)&(s6->sin6_addr),
+
+                   sizeof(struct sockaddr_in6));
+            addr->afi = (ifa->ifa_addr)->sa_family;
+            freeifaddrs(ifaddr);
+            return(addr);
+        default:
+            continue;                   /* keep looking */
+        }
+    }
+    free(addr);
+    freeifaddrs(ifaddr);
+    return(0);                          /* no luck */
+}
+
+/*
+ *      lispd_get_address
+ *
+ *      return lispd_addr_t for host/FQDN or 0 if none
+ */
+
+lispd_addr_t *lispd_get_address(host, addr, flags)
+    char             *host;
+    lispd_addr_t     *addr;
+    unsigned int     *flags;
+{
+    struct hostent      *hptr;
+    struct ifaddrs      *ifaddr;
+    struct ifaddrs      *ifa;
+    struct sockaddr_in  *s4;
+    struct sockaddr_in6 *s6;
+
+    /* 
+     * make sure this is clean
+     */
+
+    memset((void *) &(addr->address), 0, sizeof(lisp_addr_t));
+
+    /*
+     *  check to see if hhost is either a FQDN of IPvX address.
+     */
+
+    if (((hptr = gethostbyname2(host,AF_INET))  != NULL) ||
+        ((hptr = gethostbyname2(host,AF_INET6)) != NULL)) {
+        memcpy((void *) &(addr->address.address),
+               (void *) *(hptr->h_addr_list), sizeof(lisp_addr_t));
+        addr->afi = hptr->h_addrtype;
+        if (isfqdn(host))
+            *flags = FQDN_LOCATOR;      
+        else 
+            *flags = STATIC_LOCATOR;
+        return(addr);
+    } 
+}
+
+/*
+ *  lispd_get_iface_address
+ *
+ *  return lispd_addr_t for the interface, 0 if none
+ */
+
+lispd_addr_t *lispd_get_iface_address(ifacename, addr)
+        char             *ifacename;
+        lispd_addr_t     *addr;
+{
+    struct hostent      *hptr;
+    struct ifaddrs      *ifaddr;
+    struct ifaddrs      *ifa;
+    struct sockaddr_in  *s4;
+    struct sockaddr_in6 *s6;
+    char addr_str[MAX_INET_ADDRSTRLEN];
+
+    /* 
+     * make sure this is clean
+     */
+
+    memset((void *) &(addr->address), 0, sizeof(lisp_addr_t));
+
+    /*
+     *  go search for the interface
+     */
+
+    if (getifaddrs(&ifaddr) !=0) {
+        syslog(LOG_DAEMON,
+               "getifaddrs(get_interface_addr): %s", strerror(errno));
+        return(0);
+    }
+
+    for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
+        if ((ifa->ifa_addr == NULL) || ((ifa->ifa_flags & IFF_UP) == 0))
+            continue;
+        switch(ifa->ifa_addr->sa_family) {
+        case AF_INET:
+            s4 = (struct sockaddr_in *)(ifa->ifa_addr);
+            if (!strcmp(ifa->ifa_name, ifacename)) {
+                memcpy((void *) &(addr->address.address),
+                       (void *)&(s4->sin_addr), sizeof(struct in_addr));
+                addr->afi = AF_INET;
+                syslog(LOG_DAEMON, "MN's IPv4 RLOC from interface (%s): %s \n",
+                        ifacename, 
+                        inet_ntop(AF_INET, &(s4->sin_addr), 
+                            addr_str, MAX_INET_ADDRSTRLEN));
+                return(addr);
+            } else {
+                continue;
+            }
+        case AF_INET6:
+            s6 = (struct sockaddr_in6 *)(ifa->ifa_addr);
+            if (!strcmp(ifa->ifa_name, ifacename)) {
+                memcpy((void *) &(addr->address.address),
+                       (void *)&(s6->sin6_addr),
+                       sizeof(struct in6_addr));
+                addr->afi = AF_INET6;
+                syslog(LOG_DAEMON, "MN's IPv6 RLOC from interface (%s): %s\n",
+                        ifacename, 
+                        inet_ntop(AF_INET6, &(s6->sin6_addr), 
+                            addr_str, MAX_INET_ADDRSTRLEN));
+                return(addr);
+            } else {
+                continue;
+            }
+        default:
+            continue;                   /* XXX */
+        }
+    }
+}
+
+/*
+ *      dump_X
+ *
+ *      walk the lispd X data structures 
+ *
+ *      David Meyer
+ *      dmm@1-4-5.net
+ *      Wed Apr 21 14:08:42 2010
+ *
+ *      $Header: /usr/local/src/lispd/RCS/lispd_config.c,v 1.16 2010/04/21 23:32:08 root Exp $
+ *
+ */
+
+dump_database(tree, afi)
+        patricia_tree_t *tree;
+        int             afi;
+{
+    patricia_node_t             *node;
+    lispd_locator_chain_t       *locator_chain;
+    lispd_locator_chain_elt_t   *locator_chain_elt;
+    lispd_db_entry_t            *db_entry;
+
+    if (!tree) {
+        switch(afi) {
+        case AF_INET:
+            syslog(LOG_DAEMON, "No database for AF_INET");
+            return(0);
+        case AF_INET6:
+            syslog(LOG_DAEMON, "No database for AF_INET6");
+            return(0);
+        default:        
+            syslog(LOG_DAEMON, "Unknown database AFI (%d)", afi);
+            return(0);
+        }
+    }
+    syslog(LOG_DAEMON, "database:");
+    PATRICIA_WALK(tree->head, node) {
+        locator_chain     = ((lispd_locator_chain_t *)(node->data));
+        locator_chain_elt = locator_chain->head;
+        while (locator_chain_elt) {
+            db_entry = locator_chain_elt->db_entry;
+            dump_database_entry(db_entry);
+            locator_chain_elt = locator_chain_elt->next;
+        }
+    } PATRICIA_WALK_END;
+    return(1);
+}
+
+
+dump_database_entry(db_entry)
+        lispd_db_entry_t *db_entry;
+{
+    int              afi; 
+    char             eid[128];
+    char             rloc[128];
+    char             buf[128];
+
+    afi = db_entry->eid_prefix_afi;
+    inet_ntop(afi,
+              &(db_entry->eid_prefix.address),
+              eid,
+              128);
+    inet_ntop(db_entry->locator_afi,
+              &(db_entry->locator.address),
+              rloc, 128);
+    sprintf(buf, "%s (%s)", db_entry->locator_name, rloc);
+    syslog(LOG_DAEMON, " %s lisp %s/%d %s p %d w %d",
+           (afi == AF_INET) ? "ip":"ipv6",
+           eid,
+           db_entry->eid_prefix_length, 
+           buf,
+           db_entry->priority,
+           db_entry->weight);
+}
+
+dump_servers(list, list_name)
+    lispd_addr_list_t   *list;
+    const char          *list_name;
+{ 
+    lispd_addr_t        *addr     = 0;
+    lispd_addr_list_t   *iterator = 0;
+    int                 afi; 
+    char                buf[128];
+
+    if (!list)
+        return(1);
+
+    syslog(LOG_DAEMON, "%s:", list_name);
+
+    iterator = list;
+    while (iterator) {
+        addr = iterator->address;
+        afi = addr->afi;
+        inet_ntop(afi, &(addr->address.address), buf, sizeof(buf));
+        syslog(LOG_DAEMON," %s", buf);
+        iterator = iterator->next;
+    }
+}
+
+dump_map_servers()
+{ 
+    int                     afi;
+    lispd_addr_t            *addr;
+    lispd_map_server_list_t *ms;
+    char                    buf[128];
+
+    if (!map_servers)
+        return(1);
+
+    syslog(LOG_DAEMON, "map-servers:");
+    ms = map_servers;
+
+    while (ms) {
+        dump_map_server(ms);
+        ms = ms->next;
+    }
+}
+
+dump_map_server(ms)
+    lispd_map_server_list_t *ms;
+{
+    int                     afi;
+    lispd_addr_t            *addr;
+    char                    buf[128];
+
+    addr = ms->address;
+    afi = addr->afi;
+    inet_ntop(afi, &(addr->address.address), buf, sizeof(buf));
+    syslog(LOG_DAEMON, " %s key-type: %d key: %s",
+	   buf,
+	   ms->key_type,
+	   ms->key);
+}
+
+dump_map_cache()
+{
+    lispd_map_cache_t       *map_cache;
+    lispd_map_cache_entry_t *map_cache_entry;
+    int              afi; 
+    unsigned int     ttl; 
+    char             eid[128];
+    char             rloc[128];
+
+    if (!lispd_map_cache)
+        return(1);
+
+    syslog(LOG_DAEMON, "map-cache:");
+    map_cache = lispd_map_cache;
+
+    while (map_cache) {
+        map_cache_entry = &(map_cache->map_cache_entry);
+        afi = map_cache_entry->eid_prefix_afi;
+        ttl = map_cache_entry->ttl;
+        inet_ntop(afi,
+                  &(map_cache_entry->eid_prefix.address),
+                  eid,
+                  128);
+        inet_ntop(map_cache_entry->locator_afi,
+                  &(map_cache_entry->locator.address),
+                  rloc, 128);
+        syslog(LOG_DAEMON," %s lisp %s/%d %s p %d w %d ttl %d (%s)",
+	       (afi == AF_INET) ? "ip":"ipv6",
+	       eid,
+	       map_cache_entry->eid_prefix_length, 
+	       rloc,
+	       map_cache_entry->priority,
+	       map_cache_entry->weight,
+	       ttl,
+	       (map_cache_entry->how_learned == STATIC_MAP_CACHE_ENTRY)
+	       ? "static" : "dynamic");
+        map_cache = map_cache->next;
+    }
+}
+
+
+/* 
+ *      isfqdn(char *s)
+ *
+ *      See if a string qualifies as an FQDN. To qualifiy, s must
+ *      contain one or more dots. The dots may not be the first
+ *      or the last character. Two dots may not immidiately follow
+ *      each other. It must consist of the characters a..z, A..Z,,
+ *      0..9, '.', '-'. The first character must be a letter or a digit.
+ */
+
+int isfqdn(char *s)
+{
+    int         i = 1;
+    uint8_t     dot = 0;
+    char        c;
+
+    if ((!isalnum(s[0])) || (!strchr(s,':')))
+        return(0);
+
+    while (((c = s[i]) != 0) && (c != ',') && (c != ':')) {
+        if (c == '.') {
+            dot = 1;
+            if (s[i-1] == '.')
+                return(0);
+        }
+        if (!(isalnum(c) || c=='-' || c=='.'))
+            return(0);
+        i++;
+    }
+
+    if (s[0] == '.' || s[i-1] == '.')
+        return(0);
+
+    return(dot);
+}
+
+dump_tree_elt(locator_chain)
+    lispd_locator_chain_t *locator_chain;
+{
+    syslog(LOG_DAEMON, " locator_chain->eid_name = %s",
+           locator_chain->eid_name);
+}
+
+dump_tree(afi,tree)
+     int afi;
+     patricia_tree_t *tree;
+
+{
+    patricia_node_t *node;
+   
+    switch(afi) {
+    case AF_INET:
+        printf("dump_tree for AF_INET\n");
+        break;
+    case AF_INET6:
+        printf("dump_tree for AF_INET6\n");
+        break;
+    }
+
+    PATRICIA_WALK(tree->head, node) {
+        printf("node: %s/%d\n", 
+               prefix_toa(node->prefix), node->prefix->bitlen);
+        printf("dump_tree:\t%s (%d)\n",
+               ((lispd_locator_chain_t *)(node->data))->eid_name,
+               ((lispd_locator_chain_t *)(node->data))->locator_count);
+        dump_tree_elt((lispd_locator_chain_t *)(node->data));
+
+    } PATRICIA_WALK_END;
+}
+
+debug_installed_database_entry(db_entry, locator_chain)
+    lispd_db_entry_t            *db_entry;
+    lispd_locator_chain_t       *locator_chain;
+{
+    char        buf[128];
+    char        rloc[128];
+
+    inet_ntop(db_entry->locator_afi,
+              &(db_entry->locator.address),
+              rloc, 128);
+
+    if (db_entry->locator_type == STATIC_LOCATOR)
+        sprintf(buf, "%s", rloc);
+    else
+        sprintf(buf, "%s (%s)", db_entry->locator_name, rloc);
+    syslog(LOG_DAEMON, "  Installed %s lisp %s %s p %d w %d",
+	   (locator_chain->eid_prefix_afi == AF_INET) ? "ip":"ipv6",
+	   locator_chain->eid_name,
+	   buf,
+	   db_entry->priority,
+	   db_entry->weight);
+}
+
+print_hmac(hmac,len)
+     uchar *hmac;
+     int len;
+{
+
+    int i;
+
+    for (i = 0; i < len; i += 4) {
+        printf("i = %d\t(0x%04x)\n", i, (unsigned int) hmac[i]);
+    }
+    printf("\n");
+}
+     
+     
+/*
+ *      get_lisp_afi
+ *
+ *      Map from Internet AFI -> LISP_AFI
+ *
+ *      Get the length while your at it
+ */         
+
+get_lisp_afi(afi, len)
+     int        afi;
+     int        *len;
+{
+
+    switch(afi) {
+    case AF_INET:
+        if (len)
+            *len = sizeof(struct in_addr);
+        return(LISP_AFI_IP);
+    case AF_INET6:
+        if (len)
+            *len = sizeof(struct in6_addr);
+        return(LISP_AFI_IPV6);
+    default:
+        syslog(LOG_DAEMON, "get_lisp_afi: unknown AFI (%d)", afi);
+        return(0);
+    }
+}
+
+/*
+ *      lisp2inetafi
+ *
+ *      Map from Internet LISP AFI -> INET AFI
+ *
+ */         
+
+lisp2inetafi(afi)
+     int        afi;
+{
+    switch(afi) {
+    case 0:
+        return(0);
+    case LISP_AFI_IP:
+        return(AF_INET);
+    case LISP_AFI_IPV6:
+        return(AF_INET6);
+    default:
+        syslog(LOG_DAEMON, "lisp2inetafi: unknown AFI (%d)", afi);
+        return(0);
+    }
+}
+
+
+/*
+ *      given afi, get the IP header length
+ */
+
+get_ip_header_len(afi)  
+        int afi;
+{
+    switch (afi) {                      /* == eid_afi */
+    case AF_INET:
+        return(sizeof(struct ip));
+    case AF_INET6:
+        return(sizeof(struct ip6_hdr));
+    default:
+        syslog(LOG_DAEMON, "get_ip_header_len: unknown AFI (%d)", afi);
+        return(0);
+    }
+}
+
+
+/*
+ *      given afi, get addr len
+ */
+
+get_addr_len(afi)       
+        int afi;
+{
+    switch (afi) {                      /* == eid_afi */
+    case AF_INET:
+        return(sizeof(struct in_addr));
+    case AF_INET6:
+        return(sizeof(struct in6_addr));
+    default:
+        syslog(LOG_DAEMON, "get_addr_len: unknown AFI (%d)", afi);
+        return(0);
+    }
+}
+
+
+/*
+ *      given afi, get prefix len
+ */
+
+get_prefix_len(afi)
+        int afi;
+{
+    return(get_addr_len(afi) * 8);
+}
+
+struct udphdr *build_ip_header(cur_ptr,my_addr,eid_prefix, ip_len)
+        void                  *cur_ptr;
+        lispd_addr_t          *my_addr;
+        lisp_addr_t           *eid_prefix;
+        int                   ip_len;
+{
+    struct ip      *iph;
+    struct ip6_hdr *ip6h;
+    struct udphdr  *udph;
+
+    switch (my_addr->afi) {
+    case AF_INET:
+        iph                = (struct ip *) cur_ptr;
+        iph->ip_hl         = 5;
+        iph->ip_v          = IPVERSION;
+        iph->ip_tos        = 0;
+        iph->ip_len        = htons(ip_len);
+        iph->ip_id         = htons(54321);
+        iph->ip_off        = 0;
+        iph->ip_ttl        = 255;
+        iph->ip_p          = IPPROTO_UDP;
+        iph->ip_sum        = 0;         
+        iph->ip_src.s_addr = my_addr->address.address.ip.s_addr;
+        iph->ip_dst.s_addr = eid_prefix->address.ip.s_addr; 
+        udph              = (struct udphdr *) CO(iph,sizeof(struct ip));
+        break;
+    case AF_INET6:
+        ip6h           = (struct ip6_hdr *) cur_ptr;
+        ip6h->ip6_hops = 255;
+        ip6h->ip6_vfc  = (IP6VERSION << 4);
+        ip6h->ip6_nxt  = IPPROTO_UDP;
+        ip6h->ip6_plen = htons(ip_len);
+        memcpy(ip6h->ip6_src.s6_addr,
+               my_addr->address.address.ipv6.s6_addr,
+               sizeof(struct in6_addr));
+        memcpy(ip6h->ip6_dst.s6_addr,
+               eid_prefix->address.ipv6.s6_addr,
+               sizeof(struct in6_addr));
+        udph = (struct udphdr *) CO(ip6h,sizeof(struct ip6_hdr));
+        break;
+    default:
+        return(0);
+    }
+    return(udph);
+}
+
+/*
+ *      requires librt
+ */
+
+uint64_t build_nonce(seed)
+     int        seed;
+{
+
+    uint64_t            nonce; 
+    uint32_t            nonce_lower;
+    uint32_t            nonce_upper; 
+    struct timespec     ts; 
+ 
+    /* 
+     * Put nanosecond clock in lower 32-bits and put an XOR of the nanosecond 
+     * clock with the seond clock in the upper 32-bits. 
+     */ 
+
+    clock_gettime(CLOCK_MONOTONIC,&ts); 
+    nonce_lower = ts.tv_nsec; 
+    nonce_upper = ts.tv_sec ^ htonl(nonce_lower); 
+ 
+    /* 
+     * OR in a caller provided seed to the low-order 32-bits. 
+     */ 
+    nonce_lower |= seed; 
+ 
+    /* 
+     * Return 64-bit nonce. 
+     */ 
+    nonce = nonce_upper; 
+    nonce = (nonce << 32) | nonce_lower; 
+    return(nonce); 
+} 
+ 
+/* 
+ * lisp_print_nonce 
+ * 
+ * Print 64-bit nonce in 0x%08x-0x%08x format. 
+ */ 
+lispd_print_nonce (nonce)
+     uint64_t nonce;
+{ 
+    uint32_t lower; 
+    uint32_t upper; 
+ 
+    lower = nonce & 0xffffffff; 
+    upper = (nonce >> 32) & 0xffffffff; 
+    syslog(LOG_DAEMON,"nonce: 0x%08x-0x%08x\n", htonl(upper), htonl(lower)); 
+} 
+ 
+/*
+ *      API functions of datacache entries (updated acabello)
+ */
+
+// Build new datacache entry and insert timer into ordered list of timers
+
+
+int build_datacache_entry(dest,
+						eid_prefix,
+                       eid_prefix_afi,
+                       eid_prefix_length,
+                       nonce,
+                       islocal,
+                       smr,
+                       retries,
+                       timeout,
+                       encap)
+	 lispd_addr_t *dest;
+     lisp_addr_t *eid_prefix;
+     uint16_t     eid_prefix_afi;
+     uint8_t      eid_prefix_length;
+     uint64_t     nonce;
+     uint8_t      islocal;
+     uint8_t	  smr;
+     uint8_t	  retries;
+     uint16_t	  timeout;
+     uint8_t      encap;
+{
+
+    datacache_elt_t *elt;
+    timer_rec_t *timer_rec;
+    timer_rec_t *temp_rec;
+    timer_rec_t *prev_rec;
+
+    if ((elt = malloc(sizeof(datacache_elt_t))) == NULL) {
+        syslog(LOG_DAEMON,
+	       "malloc (build_datacache_entry): %s", strerror(errno));
+        return(0);
+    }
+    memset(elt, 0, sizeof(datacache_elt_t));
+
+    elt->nonce             = nonce;
+    elt->local             = islocal;
+    elt->ttl               = DEFAULT_DATA_CACHE_TTL;
+    if (eid_prefix_afi == AF_INET) {
+	memcpy((void*)&(elt->eid_prefix.address.ip),(void*)&(eid_prefix->address.ip),sizeof(struct sockaddr_in));
+    }
+    else if (eid_prefix_afi == AF_INET6) {
+	memcpy((void*)&(elt->eid_prefix.address.ipv6),(void*)&(eid_prefix->address.ipv6),sizeof(struct sockaddr_in6));
+    }
+    elt->dest.afi		   = dest->afi;
+    if (elt->dest.afi==AF_INET) {
+	memcpy((void*)&(elt->dest.address.address),(void*) &(dest->address.address),sizeof(struct sockaddr_in));
+    }
+    else if (elt->dest.afi==AF_INET6) {
+	memcpy((void*)&(elt->dest.address.address),(void*) &(dest->address.address),sizeof(struct sockaddr_in6));
+    }
+    else {
+	syslog(LOG_DAEMON,"Unknown AFI (build_datacache_entry): %d", elt->dest.afi);
+	return 0;
+    }
+
+    elt->eid_prefix_length = eid_prefix_length;
+    elt->eid_prefix_afi    = eid_prefix_afi;
+    elt->smr			   = smr;
+    elt->retries		   = retries;
+    elt->encap			   = encap;
+    elt->timeout		   = timeout;
+    elt->next              = NULL;
+    elt->prev    		   = datacache->tail;
+
+    /* link up the entry */
+
+    if (datacache->tail)
+        (datacache->tail)->next = elt;
+    else 
+        datacache->head = elt;
+    datacache->tail = elt;
+
+    /* insert new nonce into ordered list of timers */
+
+    if ((timer_rec = malloc(sizeof(timer_rec_t))) == NULL) {
+        syslog(LOG_DAEMON,
+	       "malloc (build_datacache_entry): %s", strerror(errno));
+        return(0);
+    }
+
+    memset(timer_rec,0,sizeof(timer_rec_t));
+
+    timer_rec->elt=elt;
+    elt->timer=timer_rec;
+    time(&(timer_rec->timer));
+    timer_rec->timer=(timer_rec->timer) + timeout;
+    // if (smr) timer_rec->timer=(timer_rec->timer)+(datacache->timer_datacache->smr_timeout);
+    // else timer_rec->timer=(timer_rec->timer)+(datacache->timer_datacache->mrq_timeout);
+    temp_rec = datacache->timer_datacache->head;
+
+    if (temp_rec==NULL) { //timer_datacache is empty
+	timer_rec->next=NULL;
+	timer_rec->prev=NULL;
+	datacache->timer_datacache->head=timer_rec;
+	datacache->timer_datacache->tail=timer_rec;
+	return (1);
+    }
+
+    prev_rec=NULL;
+    while(temp_rec!=NULL) {
+	if (temp_rec->timer>timer_rec->timer) {
+		if (prev_rec==NULL) {// New record is the first one
+			timer_rec->next=temp_rec;
+			timer_rec->prev=NULL;
+			datacache->timer_datacache->head=timer_rec;
+		temp_rec->prev=timer_rec;
+		return (1);
+		}
+		else { // This is not the first record
+			timer_rec->next=temp_rec;
+			timer_rec->prev=prev_rec;
+			temp_rec->prev=timer_rec;
+			prev_rec->next=timer_rec;
+			return (1);
+		}
+	}
+	prev_rec=temp_rec;
+	temp_rec=temp_rec->next;
+    }
+
+    // New record is the last one
+    timer_rec->next=NULL;
+    timer_rec->prev=prev_rec;
+    prev_rec->next=timer_rec;
+    datacache->timer_datacache->tail=timer_rec;
+
+    return(1);
+}
+    
+// Modified by acabello
+// Timeout expired entries and trigger appropriate actions
+void expire_datacache() {
+	time_t current_t;
+    timer_rec_t *temp_rec;
+    timer_rec_t *next_rec;
+
+	if (datacache->timer_datacache->head==NULL) return;
+	current_t=time(NULL);
+
+	temp_rec=datacache->timer_datacache->head;
+	while(temp_rec!=NULL) {
+		if (temp_rec->timer>current_t) return;
+		next_rec=temp_rec->next;
+		(*datacache->timer_datacache->callback)(temp_rec->elt);
+		temp_rec=next_rec;
+	}
+}
+
+// Modified by acabello
+// Deletes a datacache entry
+void delete_datacache_entry(elt)
+	datacache_elt_t *elt;
+{
+	timer_rec_t *temp_rec;
+
+	// Resetting ELT list
+	if (elt->next==NULL){ // This is the last entry
+		datacache->tail=elt->prev;
+		if (elt->prev==NULL){ // This is the only entry
+			datacache->head=NULL;
+		}
+		else {
+			(elt->prev)->next=NULL;
+		}
+	}
+	else if (elt->prev==NULL){ // This is the first entry
+		datacache->head=elt->next;
+		if (elt->next==NULL){ // This is the only entry
+			datacache->tail=NULL;
+		}
+		else {
+			(elt->next)->prev=NULL;
+		}
+	}
+	else { // This entry is at the middle of the list
+		(elt->next)->prev=elt->prev;
+		(elt->prev)->next=elt->next;
+	}
+
+	// Resetting timer list
+	temp_rec=(timer_rec_t*) elt->timer;
+
+	if (temp_rec->next==NULL){ // This is the last entry
+		datacache->timer_datacache->tail=temp_rec->prev;
+		if (temp_rec->prev==NULL){ // This is the only entry
+			datacache->timer_datacache->head=NULL;
+		}
+		else {
+			(temp_rec->prev)->next=NULL;
+		}
+	}
+	else if (temp_rec->prev==NULL){ // This is the first entry
+		datacache->timer_datacache->head=temp_rec->next;
+		if (temp_rec->next==NULL){ // This is the only entry
+			datacache->timer_datacache->tail=NULL;
+		}
+		else {
+			(temp_rec->next)->prev=NULL;
+		}
+	}
+	else { // This entry is at the middle of the list
+		(temp_rec->next)->prev=temp_rec->prev;
+		(temp_rec->prev)->next=temp_rec->next;
+	}
+
+	// Ready to free
+	free((void*)elt);
+	free((void*)temp_rec);
+}
+
+// Modified by acabello
+// Check if address is included into another address
+int is_eid_included(elt,eid_afi,eid_prefix_mask_length,eid)
+	datacache_elt_t* elt;
+	int eid_afi;
+	int eid_prefix_mask_length;
+	lisp_addr_t	*eid;
+{
+	// ToDo: acabello
+	return 1;
+}
+
+// Modified by acabello
+// Search a datacache entry based on EID prefix and returns it in res_elt
+int search_datacache_entry_eid (eid_afi,eid_prefix,res_elt)
+	uint16_t eid_afi;
+	lisp_addr_t* eid_prefix;
+	datacache_elt_t **res_elt;
+{
+
+        /* PN, DM:
+         * Note: Code here checks for an exact eid match.
+         * Checking for exact match will work only when map reply is
+         * for a MN (/32 or /128). Will not work for lisp sites with
+         * eid prefixes.
+         * Accomplishing the latter involves more work in terms of
+         * suitable datacache structure to search/delete eid prefixes
+         *
+         */
+	datacache_elt_t *elt;
+
+	elt=datacache->head;
+	while(elt!=NULL) {
+		int res;
+		if ((eid_afi == AF_INET) && (eid_afi==elt->eid_prefix_afi)) {
+			if ((eid_prefix->address).ip.s_addr==(elt->eid_prefix).address.ip.s_addr) {
+				return 1;
+			//res=memcmp((void*)&((eid_prefix->address).ip.s_addr),(void*)&((elt->eid_prefix).address.ip.s_addr),sizeof(struct sockaddr_in));
+			//if (res==0) {
+			//	*res_elt=elt;
+			//	return 1;
+			}
+
+		}
+		if ((eid_afi == AF_INET6) && (eid_afi==elt->eid_prefix_afi)) {
+			res=memcmp((void*)&((eid_prefix->address).ipv6),(void*)&((elt->eid_prefix).address.ipv6),sizeof(struct sockaddr_in6));
+			if (res==0) {
+				*res_elt=elt;
+				return 1;
+			}
+		}
+		elt=elt->next;
+	}
+
+	// EID not found
+	#ifdef DEBUG
+	syslog(LOG_INFO, "Entry not found in datacache- EID don't match");
+	#endif
+	return 0;
+}
+
+// Modified by acabello
+// Search a datacache entry based on nonce and returns it in res_elt
+int search_datacache_entry_nonce (nonce,res_elt)
+	uint64_t nonce;
+	datacache_elt_t **res_elt;
+{
+
+
+	datacache_elt_t *elt;
+
+	elt=datacache->head;
+	while(elt!=NULL) {
+		if (elt->nonce==nonce) {
+			// Nonce match
+			*res_elt=elt;
+			return 1;
+		}
+		elt=elt->next;
+	}
+
+	// Nonce not found
+	#ifdef DEBUG
+	syslog(LOG_INFO, "Entry not found in datacache- nonce don't match");
+	#endif
+	return 0;
+}
+
+// Modified by acabello
+// Deletes a datacache entry
+int init_datacache(cbk)
+	void (*cbk)(datacache_elt_t*);
+{
+
+
+	if ((datacache = malloc(sizeof(datacache_t))) == NULL){
+		syslog(LOG_DAEMON, "malloc (datacache): %s", strerror(errno));
+		return(1);
+	}
+        memset (datacache, 0, sizeof(datacache_t));
+
+	datacache->head=NULL;
+	datacache->tail=NULL;
+
+	if ((datacache->timer_datacache = malloc(sizeof(timer_datacache_t))) == NULL){
+		syslog(LOG_DAEMON, "malloc (timer_datacache): %s", strerror(errno));
+		return(1);
+	}
+
+	datacache->timer_datacache->callback=cbk;
+	datacache->timer_datacache->head=NULL;
+	datacache->timer_datacache->tail=NULL;
+
+	return(1);
+}
+
+/*
+ *	Auxiliary definitions
+ *
+ */
+uint16_t min_timeout(uint16_t a,uint16_t b) {
+	if (a<b) return a;
+	else return b;
+}
+
+/*
+ *	select from among readfds, the largest of which 
+ *	is max_fd.
+ */
+
+have_input(max_fd,readfds)
+  int     max_fd;
+  fd_set *readfds;
+{
+
+    struct timeval tv;
+
+    tv.tv_sec  = 0;
+    tv.tv_usec = DEFAULT_SELECT_TIMEOUT;
+
+    if (select(max_fd+1,readfds,NULL,NULL,&tv) == -1) {
+	syslog(LOG_DAEMON, "select: %s", strerror(errno));
+	return(0);
+    } 
+    return(1);
+}
+
+/*
+ *	Process a LISP protocol message sitting on 
+ *	socket s with address family afi
+ */
+
+process_lisp_msg(s, afi)
+     int	s;
+     int	afi;
+{
+
+    uint8_t	        packet[MAX_IP_PACKET];
+    struct sockaddr_in  s4;
+    struct sockaddr_in6 s6;
+
+    switch(afi) {
+    case AF_INET:
+	memset(&s4,0,sizeof(struct sockaddr_in));
+        if (!retrieve_lisp_msg(s, packet, &s4, afi))
+	    return(0);
+	/* process it here */
+	break;
+    case AF_INET6:
+	memset(&s6,0,sizeof(struct sockaddr_in6));
+        if (!retrieve_lisp_msg(s, packet, &s6, afi))
+	    return(0);
+	/* process it here */
+	break;
+    default:
+	return(0);
+    }
+}
+
+
+
+/*
+ *	Retrieve a mesage from socket s
+ */
+
+retrieve_lisp_msg(s, packet, from, afi)
+     int	s;
+     uint8_t	*packet;
+     void	*from;
+     int	afi;
+	
+{
+
+    struct sockaddr_in  *s4;
+    struct sockaddr_in6 *s6;
+    int			fromlen4 = sizeof(struct sockaddr_in);
+    int			fromlen6 = sizeof(struct sockaddr_in6);
+
+    switch(afi) {
+    case AF_INET:
+	s4 = (struct sockaddr_in *) from;
+	if (recvfrom(s,
+		     packet,
+		     MAX_IP_PACKET,
+		     0,
+		     (struct sockaddr *) s4,
+		     &fromlen4) < 0) {
+	    syslog(LOG_DAEMON, "recvfrom (v4): %s", strerror(errno));
+	    return(0);
+	}
+	break;
+    case AF_INET6:
+	s6 = (struct sockaddr_in6 *) from;
+	if (recvfrom(s,
+		     packet,
+		     MAX_IP_PACKET,
+		     0,
+		     (struct sockaddr *) s6,
+		     &fromlen6) < 0) {
+	    syslog(LOG_DAEMON, "recvfrom (v6): %s", strerror(errno));
+	    return(0);
+	}
+	break;
+    default:
+	syslog(LOG_DAEMON, "retrieve_msg: Unknown afi %d", afi);
+	return(0);
+    }
+#ifdef DEBUG
+    syslog(LOG_DAEMON, "Received a LISP control message");
+#endif
+
+    switch (((lispd_pkt_encapsulated_control_t *) packet)->type) {
+    case LISP_MAP_REPLY:    //Got Map Reply
+#ifdef DEBUG
+    syslog(LOG_DAEMON, "Received a LISP Map-Reply message");
+#endif
+        process_map_reply(packet);
+        break;
+    case LISP_ENCAP_CONTROL_TYPE:   //Got Encapsulated Control Message
+#ifdef DEBUG
+    syslog(LOG_DAEMON, "Received a LISP Encapsulated Map-Request message");
+#endif
+	if(!process_map_request_msg(packet, s, from, afi))
+		return (0);
+        break;
+    case LISP_MAP_REQUEST:      //Got Map-Request
+#ifdef DEBUG
+    syslog(LOG_DAEMON, "Received a LISP Map-Request message");
+#endif
+	if(!process_map_request_msg(packet, s, from, afi))
+		return (0);
+        break;
+    case LISP_MAP_REGISTER:     //Got Map-Register, silently ignore
+        break;
+    case LISP_MAP_NOTIFY:       //Got Map-Notify, silently ignore
+        break;
+    }
+#ifdef DEBUG
+    syslog(LOG_DAEMON, "Completed processing a LISP control message");
+#endif
+
+
+#if (DEBUG > 3)
+    switch (((lispd_pkt_encapsulated_control_t *) packet)->type) {
+    case LISP_MAP_REPLY:
+	printf("Got Map-Reply (%d)\n", afi);
+	break;
+    case LISP_MAP_REQUEST:
+	printf("Got Map-Request: Silently ignoring it (%d)\n", afi);
+	break;
+    case LISP_MAP_REGISTER:
+	printf("Got Map-Register: Silently ignoring it (%d)\n", afi);
+	break;
+    case LISP_MAP_NOTIFY:
+	printf("Got Map-Notify: Silently ignoring it (%d)\n", afi);
+	break;
+    case LISP_ENCAP_CONTROL_TYPE:
+	printf("Got Encapsulated Control Message (%d)\n", afi);
+	break;
+    }
+#endif
+}
+
+    
+int inaddr2sockaddr(lisp_addr_t *inaddr, struct sockaddr_storage *sockaddr, uint16_t port) {
+    struct sockaddr_in  *ipv4;
+    struct sockaddr_in6 *ipv6;
+
+    memset(sockaddr, 0, sizeof(struct sockaddr_storage));
+
+    ipv4 = (struct sockaddr_in *) sockaddr;
+    ipv6 = (struct sockaddr_in6 *) sockaddr;
+
+    switch(inaddr->afi) {
+        case AF_INET:
+            ipv4->sin_family      = AF_INET;
+            ipv4->sin_port        = htons(port);
+            ipv4->sin_addr.s_addr = inaddr->address.ip.s_addr;
+            return(1);
+            break;
+        case AF_INET6:
+            ipv6->sin6_family      = AF_INET6;
+            ipv6->sin6_port        = htons(port);
+            memcpy(&(ipv6->sin6_addr), &(inaddr->address.ipv6), sizeof(struct in6_addr));
+            return(1);
+            break;
+        default:
+            syslog(LOG_DAEMON, "inaddr2sockaddr: unknown AFI %d", inaddr->afi);
+            return(0);
+    }
+}
+
+int sockaddr2lisp(struct sockaddr *src, lisp_addr_t *dst) {
+    if (src == NULL) syslog(LOG_DAEMON, "sockaddr NULL");
+    if (src == NULL) return(-1);
+    if (dst == NULL) syslog(LOG_DAEMON, "lisp NULL");
+    if (dst == NULL) return(-1);
+
+    memset(dst, 0, sizeof(lisp_addr_t));
+
+    dst->afi = src->sa_family;
+
+    switch(src->sa_family) {
+    case AF_INET:
+        dst->address.ip.s_addr = ((struct sockaddr_in *)src)->sin_addr.s_addr;
+        break;
+    case AF_INET6:
+        memcpy(&(dst->address.ipv6), &(((struct sockaddr_in6 *)src)->sin6_addr),
+                sizeof(struct in6_addr));
+        break;
+    default:
+        syslog(LOG_DAEMON, "sockaddr2lisp: unknown AFI (%d)", src->sa_family);
+        return(-1);
+    }
+    return(0);
+}
Index: package/lisp/src/LICENSE
===================================================================
--- package/lisp/src/LICENSE	(revision 0)
+++ package/lisp/src/LICENSE	(revision 0)
@@ -0,0 +1,341 @@
+  GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+               51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) 19yy  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) 19yy name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
Index: package/lisp/src/lispd.ggo
===================================================================
--- package/lisp/src/lispd.ggo	(revision 0)
+++ package/lisp/src/lispd.ggo	(revision 0)
@@ -0,0 +1,52 @@
+#
+#	gengetops for lispd
+#
+#
+#	David Meyer
+#	dmm@1-4-5.net
+#	Fri Apr 16 13:52:49 2010
+#
+#	$Header: /home/dmm/lisp/lispd/RCS/lispd.ggo,v 1.4 2010/04/19 23:00:06 dmm Exp $
+#
+
+
+package "lispd"
+version "0.1"
+
+defmode "lispdconfig"
+
+modeoption "debug" d "Debuging output" mode="lispdconfig" optional
+
+modeoption "nodaemonize" n "Don't daemonize" mode="lispdconfig" optional
+
+modeoption "config-file" f "Alternate config file" 
+	    string typestr="config-file" mode="lispdconfig" optional
+
+modeoption "map-resolver" m "MR is the IPv{4,6} address or FQDN of the Map Resolver to use" 
+	    string typestr="MR" mode="lispdconfig" optional
+
+modeoption "map-server" s "MS is the IPv{4,6} address or FQDN of the Map Server to use" 
+	    string typestr="MS" mode="lispdconfig" optional
+
+modeoption "proxy-etr" e "PETR is the IPv{4,6} address or FQDN of the Proxy-ETR to use" 
+	    string typestr="PETR" mode="lispdconfig" optional
+
+modeoption "control_port" p "CP is the LISP control port (default: 4342)" 
+	    string typestr="CP" mode="lispdconfig" optional
+
+modeoption "map-request-retries" r "R is number of map-requests to send"
+	int typestr="R" mode="lispdconfig" optional
+
+
+# modeoption "inner-source-port" r "P is the inner source port for EMRs" 
+# 	    string typestr="P" mode="lispdconfig" optional
+# 
+# modeoption "inner-source-address" s "S is the inner source address for EMRs" 
+# 	    string typestr="S" mode="lispdconfig" optional
+# 
+# modeoption "map-request-timeout" t "T is the time to wait for map request to timeout" 
+# 	    int typestr="T" mode="lispdconfig" optional
+# 
+# modeoption "source-rloc" u "SR is the source RLOC to use for Map Reqests" 
+# 	    int typestr="SR" mode="lispdconfig" optional
+
Index: package/lisp/src/lispd_ipc.c
===================================================================
--- package/lisp/src/lispd_ipc.c	(revision 0)
+++ package/lisp/src/lispd_ipc.c	(revision 0)
@@ -0,0 +1,639 @@
+/*
+ *      lispd_ipc.c 
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Kernel IPC suport for the lispd
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    David Meyer	<dmm@cisco.com>
+ *    Vina Ermagan	<vermagan@cisco.com>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *    Lorand Jakab      <ljakab@ac.upc.edu>
+ *
+ */
+
+#include "lispd_external.h"
+
+/*
+ *	install_database_mapping --
+ *
+ *	Install a single database mapping entry in the kernel
+ *
+ */
+
+/* TODO (LJ): lispd_db_entry_t should be updated to support multiple locators */
+install_database_mapping(db_entry)
+    lispd_db_entry_t   *db_entry;
+{
+
+    int                     cmd_length = 0;
+    int                     retval = 0;
+    lisp_cmd_t              *cmd;
+    lisp_db_add_msg_t       *map_msg;
+    lisp_db_add_msg_loc_t   *map_msg_loc;
+    uint16_t                loc_count  = 1; /* TODO: support for multiple locators */
+    int i;
+
+    cmd_length = sizeof(lisp_cmd_t) + sizeof(lisp_db_add_msg_t) +
+                 sizeof(lisp_db_add_msg_loc_t) * loc_count;
+
+    if ((cmd = (lisp_cmd_t *) malloc(cmd_length)) < 0) {
+        syslog (LOG_DAEMON, "install_database_mapping(): memory allocation error");
+        return(0);
+    }
+
+    memset((char *) cmd, 0, cmd_length);
+
+    map_msg     = (lisp_db_add_msg_t *) CO(cmd, sizeof(lisp_cmd_t));
+    map_msg_loc = (lisp_db_add_msg_loc_t *) CO(map_msg, sizeof(lisp_db_add_msg_t));
+
+    cmd->type   = LispDatabaseAdd;
+    cmd->length = cmd_length - sizeof(lisp_cmd_t);
+
+    memcpy(&(map_msg->eid_prefix), &(db_entry->eid_prefix), sizeof(lisp_addr_t));
+    map_msg->eid_prefix.afi    = db_entry->eid_prefix_afi;
+    map_msg->eid_prefix_length = db_entry->eid_prefix_length;
+    map_msg->count             = loc_count;
+
+    /* XXX: code needs to be updated when lispd_db_entry_t supports more locators */
+    for (i = 0; i < loc_count; i++) {
+        memcpy(map_msg_loc + i * sizeof(lisp_db_add_msg_loc_t),
+                &(db_entry->locator), sizeof(lisp_addr_t));
+
+        map_msg->locators[i].locator.afi = db_entry->locator_afi;
+        map_msg->locators[i].priority    = db_entry->priority;
+        map_msg->locators[i].weight      = db_entry->weight;
+        map_msg->locators[i].mpriority   = db_entry->mpriority;
+        map_msg->locators[i].mweight     = db_entry->mweight;
+    }
+
+    retval = send_command(cmd, cmd_length + sizeof(lisp_cmd_t));
+    free(cmd);
+    return(retval);
+}
+
+/*
+ *	install_database_mappings_afi --
+ *
+ *	Install per_afi database mappings into the kernel
+ *
+ */
+
+install_database_mappings_afi(tree)
+	patricia_tree_t *tree;
+{
+    patricia_node_t		*node;
+    lispd_locator_chain_t	*locator_chain      = NULL;
+    lispd_locator_chain_elt_t	*locator_chain_elt  = NULL;
+    lispd_db_entry_t		*db_entry           = NULL;
+    int			        retval = 1;
+   
+    if (!tree)
+	return(0);
+
+    PATRICIA_WALK(tree->head, node) {
+        locator_chain     = ((lispd_locator_chain_t *)(node->data));
+        if (locator_chain)
+            locator_chain_elt = locator_chain->head;
+	while (locator_chain_elt) {
+	    db_entry = locator_chain_elt->db_entry;
+	    if (install_database_mapping(db_entry) < 0) {
+		syslog(LOG_DAEMON,
+		       "  Could not install database mapping %s/%d->%s",
+		       locator_chain->eid_name,
+		       locator_chain->eid_prefix_length,
+		       locator_chain_elt->locator_name);
+		retval = 0;			/* something wrong */
+	    } 
+#ifdef	DEBUG
+            else {
+                debug_installed_database_entry(db_entry, locator_chain);
+	    }
+#endif
+	    locator_chain_elt = locator_chain_elt->next;
+	}
+    } PATRICIA_WALK_END;
+    return(retval);
+}
+
+/*
+ *	install_database_mappings --
+ *
+ *	Install database mappings into the kernel
+ *
+ */
+
+
+install_database_mappings ()
+{
+
+    syslog(LOG_DAEMON, "Installing database-mappings:");
+    if (!install_database_mappings_afi(AF4_database))
+	return(0);
+    if (!install_database_mappings_afi(AF6_database))
+	return(0);
+    return(1);
+}
+
+
+/*
+ *	install_map-cache_entries
+ *
+ *	Install static map-cache entries into the kernel
+ *
+ */
+
+install_map_cache_entries ()
+{
+    lispd_map_cache_t		*map_cache_entry;
+    lispd_map_cache_entry_t	*mc_entry;
+    int				afi; 
+    int				retval;
+    char			eid[128];
+    char			rloc[128];
+    char			buf[128];
+
+    if (!lispd_map_cache)
+	return(0);
+
+    syslog(LOG_DAEMON, "installing static map-cache entries:");
+
+    map_cache_entry = lispd_map_cache;
+    while (map_cache_entry) {
+	mc_entry = &(map_cache_entry->map_cache_entry);
+	afi      = mc_entry->eid_prefix_afi;
+	inet_ntop(afi,
+		  &(mc_entry->eid_prefix.address),
+		  eid,
+		  128);
+	if (install_map_cache_entry(mc_entry) < 0) {
+	    syslog(LOG_DAEMON, " Could not install map-cache entry %s/%d->%s",
+		    eid,
+		    mc_entry->eid_prefix_length,
+		    mc_entry->locator_name);
+	    retval = 0;
+	} else {
+	    inet_ntop(mc_entry->locator_afi,
+		      &(mc_entry->locator.address),
+		      rloc, 128);
+#ifdef DEBUG
+	    if (mc_entry->locator_type == STATIC_LOCATOR)
+		sprintf(buf, "%s", rloc);
+	    else
+		sprintf(buf, "%s (%s)", mc_entry->locator_name, rloc);
+	    syslog(LOG_DAEMON, " installed %s lisp %s/%d %s p %d w %d",
+		    (afi == AF_INET) ? "ip":"ipv6",
+		    eid,
+		    mc_entry->eid_prefix_length, 
+		    buf,
+		    mc_entry->priority,
+		    mc_entry->weight);
+#endif
+	    retval = 1;
+	}
+	map_cache_entry = map_cache_entry->next;
+    }
+    return(retval);
+}
+
+/*
+ *	install_map_cache_entry --
+ *
+ *	Install a single map_cache entry in the kernel
+ *
+ */
+ 
+/* TODO (LJ): lispd_db_entry_t should be updated to support multiple locators */
+install_map_cache_entry(map_cache_entry)
+    lispd_map_cache_entry_t   *map_cache_entry;
+{
+
+    int                     cmd_length = 0;
+    int                     retval     = 0;
+    lisp_cmd_t              *cmd;
+    lisp_eid_map_msg_t      *map_msg;
+    lisp_eid_map_msg_loc_t  *map_msg_loc;
+    uint16_t                loc_count  = 1; /* TODO: support for multiple locators */
+    int i;
+ 
+    /*
+     *  Handle Negative Map_Reply
+     */
+    /* XXX (LJ): locator_afi 0 is not the way to properly check for Neg. MRep */
+    if(map_cache_entry->locator_afi == 0)
+        loc_count = 0;
+    else
+        loc_count = 1;
+
+    cmd_length = sizeof(lisp_cmd_t) + sizeof(lisp_eid_map_msg_t) +
+                 sizeof(lisp_eid_map_msg_loc_t) * loc_count;
+
+    if ((cmd = (lisp_cmd_t *) malloc(cmd_length)) < 0){
+        syslog (LOG_DAEMON, "install_map_cache_entry(): memory allocation error");
+        return(0);
+    }
+
+    memset((char *) cmd, 0, cmd_length);
+
+    map_msg     = (lisp_eid_map_msg_t *) CO(cmd, sizeof(lisp_cmd_t));
+    map_msg_loc = (lisp_eid_map_msg_loc_t *) CO(map_msg, sizeof(lisp_eid_map_msg_t));
+
+    cmd->type   = LispMapCacheAdd;
+    cmd->length = cmd_length - sizeof(lisp_cmd_t);
+
+    memcpy(&(map_msg->eid_prefix), &(map_cache_entry->eid_prefix), sizeof(lisp_addr_t));
+    map_msg->eid_prefix.afi    = map_cache_entry->eid_prefix_afi;
+    map_msg->eid_prefix_length = map_cache_entry->eid_prefix_length;
+    map_msg->count             = loc_count;
+    map_msg->actions           = map_cache_entry->actions;
+    map_msg->how_learned       = map_cache_entry->how_learned;
+    map_msg->ttl               = map_cache_entry->ttl;
+    map_msg->sampling_interval = 0; /* TODO: check what this is */
+
+    /* XXX: code needs to be updated when lispd_db_entry_t supports more locators */
+    for (i = 0; i < loc_count; i++) {
+        memcpy(map_msg_loc + i * sizeof(lisp_eid_map_msg_loc_t),
+                &(map_cache_entry->locator), sizeof(lisp_addr_t));
+
+        map_msg->locators[i].locator.afi = map_cache_entry->locator_afi;
+        map_msg->locators[i].priority    = map_cache_entry->priority;
+        map_msg->locators[i].weight      = map_cache_entry->weight;
+        map_msg->locators[i].mpriority   = map_cache_entry->mpriority;
+        map_msg->locators[i].mweight     = map_cache_entry->mweight;
+    }
+
+    retval = send_command(cmd, cmd_length + sizeof(lisp_cmd_t));
+    free(cmd);
+    return(retval);
+}
+
+
+/*
+ *	set up the netlink socket and bind to it.
+ */
+
+setup_netlink()
+{
+    if ((netlink_fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_LISP)) <  0) 
+	return(0);
+
+    memset(&src_addr, 0, sizeof(src_addr));
+    src_addr.nl_family = AF_NETLINK;
+    src_addr.nl_pid    = getpid();       /* self pid */
+    src_addr.nl_groups = 0;              /* not in mcast groups */
+
+    if (bind(netlink_fd,
+	     (struct sockaddr *) &src_addr, sizeof(src_addr)) == -1) 
+	return(0);
+
+    memset(&dst_addr, 0, sizeof(dst_addr));
+    dst_addr.nl_family = AF_NETLINK;
+    dst_addr.nl_pid    = 0;              /* For Linux Kernel */
+    dst_addr.nl_groups = 0;              /* unicast */
+    return(1);
+}
+
+send_command(lisp_cmd_t *cmd, int length)
+{
+ 
+    struct nlmsghdr *nlh;
+    struct iovec    iov;
+    struct msghdr   kmsg;
+    int		    retval = 0;
+
+    if ((nlh = (struct nlmsghdr *) malloc(NLMSG_SPACE(MAX_MSG_LENGTH))) == 0) 
+	return (0);
+
+    /*
+     *	make sure these are clean
+     */
+
+    memset(&src_addr, 0, sizeof(src_addr));
+    memset(&iov,      0, sizeof(struct iovec));
+    memset(&kmsg,     0, sizeof(struct msghdr));
+    memset(nlh,       0, sizeof(struct nlmsghdr));
+    
+    /* Fill the netlink message header */
+
+    nlh->nlmsg_len   = length + sizeof(struct nlmsghdr);
+    nlh->nlmsg_pid   = 0;  /* To kernel */
+    nlh->nlmsg_flags = 0;
+
+    /* Fill in the netlink message payload */
+
+    memcpy(NLMSG_DATA(nlh), (char *)cmd, length);
+  
+    iov.iov_base     = (void *)nlh;
+    iov.iov_len      = nlh->nlmsg_len;
+    kmsg.msg_name    = (void *)&dst_addr;
+    kmsg.msg_namelen = sizeof(dst_addr);
+    kmsg.msg_iov     = &iov;
+    kmsg.msg_iovlen  = 1;
+
+    retval = sendmsg(netlink_fd, &kmsg, 0);
+    free(nlh);
+    return(retval);
+}
+
+/*
+ *	Receive netlink message from kernel module.
+ */
+
+
+process_netlink_msg(){
+
+    struct nlmsghdr *nlh;
+    struct iovec    iov;
+    struct msghdr   kmsg;
+    int		    len = 0;
+    lisp_cmd_t      *cmd;
+
+    if ((nlh = (struct nlmsghdr *) malloc(NLMSG_SPACE(MAX_MSG_LENGTH))) == 0)
+	return (0);
+
+    /*
+     *	make sure these are clean
+     */
+
+    memset(&iov,      0, sizeof(struct iovec));
+    memset(&kmsg,     0, sizeof(struct msghdr));
+    memset(nlh,       0, NLMSG_SPACE(MAX_MSG_LENGTH));
+    memset(&dst_addr, 0, sizeof(dst_addr));
+
+
+    /* Fill the netlink message header */
+
+    iov.iov_base     = (void *)nlh;
+    iov.iov_len		 = MAX_MSG_LENGTH;
+    kmsg.msg_name    = (void *)&dst_addr;
+    kmsg.msg_namelen = sizeof(dst_addr);
+    kmsg.msg_iov     = &iov;
+    kmsg.msg_iovlen  = 1;
+
+    /*
+     * Receive the message
+     */
+
+    if ( (len = recvmsg(netlink_fd, &kmsg, 0)) <=0 ){
+		syslog(LOG_DAEMON, " Could not receive netlink message , len is %d, NLMSG_OK is %d, flags = %d",len,NLMSG_OK(nlh,len),kmsg.msg_flags);
+		fflush(stderr);
+		return (0);
+    }
+
+    /*
+     * Point to command inside the netlink message
+     */
+
+    cmd = (lisp_cmd_t *)NLMSG_DATA(nlh);
+
+#ifndef DEBUG
+#define DEBUG
+#endif
+#ifdef DEBUG
+    syslog(LOG_DAEMON,"Received netlink message type %d",cmd->type);
+
+#endif
+
+    // process received command
+
+    switch (cmd->type) {
+        case LispOk:
+            break;
+        case LispMapCacheLookup:
+            break;
+        case LispMapCacheRLOCList:
+            if(!handle_LispMapCacheRLOCList(cmd))
+                return(0);
+            break;
+        case LispDatabaseLookup:
+            break;
+        case LispCacheSample:
+            if(!handle_LispCacheSample(cmd))
+                return(0);
+            break;
+    }
+
+    free(nlh);
+
+    return(1);
+}
+
+/*
+ * Process LispCacheSample command from the Lisp module
+ */
+
+int handle_LispCacheSample(lisp_cmd_t* cmd) {
+    lisp_cache_sample_msg_t *msg;
+    msg = (lisp_cache_sample_msg_t *) cmd->val;
+
+    switch (msg->reason) {
+        case ProbeSample:
+            break;
+        case SMRSample:
+            break;
+        case CacheMiss:
+            if(!handle_LispCacheMiss(msg))
+                return(0);
+            break;
+    }
+}
+
+/*
+ * Process LispCacheMiss command from the Lisp module
+ */
+
+int handle_LispCacheMiss(lisp_cache_sample_msg_t *msg) {
+
+
+    char eid_name [128];
+
+    inet_ntop(msg->eid.afi, &((msg->eid).address), eid_name, 128);
+
+#ifdef DEBUG
+    syslog(LOG_DAEMON,"Received netlink message LispCacheMiss,eid prefix = %s ", eid_name);
+#endif
+
+/*
+ * VE, DM:
+ * Note: we can check datacache if we have an outstanding Map_Request for this EID
+ */
+
+	if( !build_and_send_map_request_msg(map_resolvers->address,
+								&(msg->eid).address,
+								msg->eid.afi,
+								(get_addr_len(msg->eid.afi) * 8),
+								eid_name,
+								1,
+								0,
+								0,
+								0,
+								0,
+								LISPD_INITIAL_MRQ_TIMEOUT,
+								1) ){
+		syslog(LOG_DAEMON,"LispCacheMiss : couldn't build/send map_request");
+		return (0);
+
+	}
+#ifdef DEBUG
+        syslog(LOG_DAEMON, "Sent Map-Request for %s", eid_name);
+#endif
+	return (1);
+
+}
+
+
+int handle_LispMapCacheRLOCList(lisp_cmd_t *cmd) {
+    patricia_node_t *node;
+    lispd_locator_chain_t *locator_chain = NULL;
+    lisp_cache_address_list_t *addr_list;
+    lispd_addr_t rloc;
+    char rloc_name[128];
+    int i;
+
+    addr_list = (lisp_cache_address_list_t *) cmd->val;
+
+    PATRICIA_WALK(AF4_database->head, node) {
+        locator_chain = ((lispd_locator_chain_t *)(node->data));
+        if (locator_chain) {
+            for (i = 0; i < addr_list->count; i++) {
+                /* XXX LJ:
+                 * We send an SMR to each RLOC in the received list for our own
+                 * EID, since the below function fills the Source-EID field the
+                 * same as destination (the function should be extended).
+                 */
+                lisp2lispd(&(addr_list->addr_list[i]), &rloc);
+                inet_ntop(rloc.afi, &(rloc.address.address), rloc_name, 128);
+                if (build_and_send_map_request_msg(&rloc,
+                        &(locator_chain->eid_prefix),
+                        locator_chain->eid_prefix_afi,
+                        (get_addr_len(locator_chain->eid_prefix_afi) * 8),
+                        locator_chain->eid_name,
+                        0, 1, 0, 0, 0, LISPD_INITIAL_MRQ_TIMEOUT, 0))
+                    syslog(LOG_DAEMON, "SMR'ing %s", rloc_name);
+            }
+        }
+    } PATRICIA_WALK_END;
+}
+
+/*
+ *	register the lispd process with the kernel
+ */
+
+int register_lispd_process(void) {
+    int retval = 0;
+    lisp_cmd_t *cmd;
+
+    if ((cmd = malloc(sizeof(lisp_cmd_t))) == 0) {
+        syslog(LOG_DAEMON, "register_lispd_process: malloc failed");
+        return(0);
+    }
+
+    memset(cmd, 0, sizeof(lisp_cmd_t));
+
+    cmd->type   = LispDaemonRegister;
+    cmd->length = 0;
+
+    retval = send_command(cmd, sizeof(lisp_cmd_t));
+    free(cmd);
+    return(retval);
+} 
+
+
+/*
+ *	ask for the list of RLOCs in map cache (for SMR)
+ */
+
+int get_map_cache_list() {
+    int retval = 0;
+    lisp_cmd_t *cmd;
+
+    if ((cmd = malloc(sizeof(lisp_cmd_t))) == 0) {
+        syslog(LOG_DAEMON, "get_map_cache_list: malloc failed");
+        return(0);
+    }
+
+    memset(cmd, 0, sizeof(lisp_cmd_t));
+
+    cmd->type   = LispMapCacheRLOCList;
+    cmd->length = 0;
+
+    retval = send_command(cmd, sizeof(lisp_cmd_t));
+    syslog(LOG_DAEMON, "Asking for RLOC list to do SMR");
+    free(cmd);
+    return(retval);
+}
+
+
+/*
+ *	update source RLOC in kernel module
+ */
+
+int set_rloc(lispd_addr_t *my_addr) {
+    int                 retval = 0;
+    int                 cmd_length = 0;
+    lisp_cmd_t          *cmd;
+    lisp_set_rloc_msg_t *set_rloc_msg;
+
+    cmd_length = sizeof(lisp_cmd_t) + sizeof(lisp_set_rloc_msg_t);
+
+    if ((cmd = (lisp_cmd_t *) malloc(cmd_length)) == 0) {
+        syslog(LOG_DAEMON, "set_rloc: malloc failed");
+        return(0);
+    }
+
+    memset(cmd, 0, cmd_length);
+
+    set_rloc_msg = (lisp_set_rloc_msg_t *) CO(cmd, sizeof(lisp_cmd_t));
+
+    cmd->type   = LispSetRLOC;
+    cmd->length = sizeof(lisp_set_rloc_msg_t);
+
+    memcpy(&(set_rloc_msg->addr), &(my_addr->address), sizeof(lisp_addr_t));
+    set_rloc_msg->addr.afi = my_addr->afi;
+
+    retval = send_command(cmd,cmd_length);
+    syslog(LOG_DAEMON, "Updating RLOC in data plane");
+    free(cmd);
+    return(retval);
+} 
+
+/* Temporary function, until we remove lispd_addr_t */
+int lisp2lispd(lisp_addr_t *src, lispd_addr_t *dst) {
+    if (src == NULL) return(-1);
+    if (dst == NULL) return(-1);
+
+    memset(dst, 0, sizeof(lispd_addr_t));
+    memcpy(&(dst->address), src, sizeof(lisp_addr_t));
+    dst->afi = src->afi;
+    return(0);
+}
+
+/* Temporary function, until we remove lispd_addr_t */
+int lispd2lisp(lispd_addr_t *src, lisp_addr_t *dst) {
+    if (src == NULL) return(-1);
+    if (dst == NULL) return(-1);
+
+    memset(dst, 0, sizeof(lisp_addr_t));
+    memcpy(dst, &(src->address), sizeof(lisp_addr_t));
+    dst->afi = src->afi;
+    return(0);
+}
Index: package/lisp/src/lisp_ipc.h
===================================================================
--- package/lisp/src/lisp_ipc.h	(revision 0)
+++ package/lisp/src/lisp_ipc.h	(revision 0)
@@ -0,0 +1,267 @@
+/*
+ * lisp_ipc.h
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Defines the message structure for lisp ipc messages.
+ * These messages can be used to communicate between
+ * lisp user-level processes and the kernel, for example.
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    Chris White       <chris@logicalelegance.com>
+ *    David Meyer		<dmm@cisco.com>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+#pragma once
+
+#ifdef KERNEL
+#include <linux/in.h>
+#include <linux/inet.h>
+#include <linux/in6.h>
+#endif /* KERNEL */
+
+/*
+ * Constants
+ */
+#define MAX_MSG_LENGTH 1024  /* Max total message size. */
+
+/*
+ * XXX Temporary, needs to be in 
+ * /usr/include/linux/netlink.h
+ * formally.
+ */
+#define NETLINK_LISP 20 
+
+/*
+ * Lisp message types
+ */
+typedef enum {
+  LispOk = 0,
+  LispFailed = 1,
+  LispMapCacheLookup = 2,
+  LispMapCacheEIDList = 3,  // For ???
+  LispMapCacheRLOCList = 4, // For SMR's
+  LispDatabaseLookup = 5,
+  LispCacheSample = 6,      /* Kernel to process-level */
+  LispSetRLOC = 7,
+  LispMapCacheAdd = 8,
+  LispMapCacheDelete = 9,
+  LispMapCacheClear = 10,
+  LispDatabaseAdd = 11,
+  LispDatabaseDelete = 12,
+  LispDaemonRegister = 13,
+  LispTrafficMonStart = 14,
+  LispSetUDPPorts = 15,
+  LispMaxType = LispSetUDPPorts
+} lisp_msgtype_e;
+
+/* 
+ * Lisp address structure
+ */
+typedef struct {
+  union {
+    struct in_addr ip;
+    struct in6_addr ipv6;
+  } address;
+  int afi;
+} lisp_addr_t;
+
+/*
+ * Top level LISP message type, 
+ * all other messages are placed inside.
+ */
+typedef struct _lisp_cmd {
+  uint16_t type;
+  uint16_t length; // No message can exceed MAX_MSG_LENGTH - nlmsghdr length
+  char val[0];
+} lisp_cmd_t;
+
+/*
+ * Convey the UDP ports to use for encapsulation
+ * and controlto the kernel module. Sent by lispd.
+ */
+typedef struct {
+    uint16_t data_port;
+    uint16_t control_port;
+} lisp_set_ports_msg_t;
+
+typedef struct _lisp_lookup_msg {
+  lisp_addr_t prefix;
+  uint32_t    prefix_length;
+  int         exact_match;
+  int         all_entries;
+} lisp_lookup_msg_t;
+
+typedef struct _lisp_set_rloc_msg {
+  lisp_addr_t addr;
+} lisp_set_rloc_msg_t;
+
+#define ACTION_DROP         0
+#define ACTION_FORWARD      1
+#define ACTION_SEND_MAP_REQ 2
+
+/*
+ * Locator portion of eid map msg
+ */
+typedef struct {
+  lisp_addr_t locator;
+  uint8_t priority;
+  uint8_t weight;
+  uint8_t mpriority;
+  uint8_t mweight;
+} lisp_eid_map_msg_loc_t;
+
+/*
+ * Message structure for adding a cache entry,
+ * sent from user-space processes to the kernel.
+ */
+typedef struct {
+  lisp_addr_t   eid_prefix;
+  uint16_t      eid_prefix_length;
+  uint8_t       count;
+  uint8_t       actions; /* Defined above */
+  uint16_t      how_learned; /* 0: static or 1: map-reply */
+  uint32_t      ttl;
+  uint32_t      sampling_interval; /* In seconds, 0 never sample */
+  lisp_eid_map_msg_loc_t locators[0];
+} lisp_eid_map_msg_t;
+
+/*
+ * Compact response types for parties only
+ * interested in a list of RLOC's or EID's
+ * currently in use (for SMR, rloc probe purposes).
+ */
+typedef struct {
+    int cookie;               // opaque value passed back to lispd
+    int count;
+    lisp_addr_t addr_list[0];
+} lisp_cache_address_list_t;
+
+/*
+ * Response type for a cache entry lookup,
+ * sent from the kernel to user-space.
+ */
+typedef struct {
+  lisp_addr_t   locator;
+  uint8_t       priority;
+  uint8_t       weight;
+  uint8_t       mpriority;
+  uint8_t       mweight;
+  uint8_t       reachability_alg:2; /* rloc_prob | echo_none */
+  uint8_t       state:1;
+  uint8_t       reserved:5;
+  uint32_t      data_packets_in;
+  uint32_t      data_packets_out;
+} lisp_cache_response_loc_t;
+
+typedef struct {
+  lisp_addr_t eid_prefix;
+  uint8_t     eid_prefix_length;
+  uint8_t     how_learned:1;
+  uint8_t     complete:1;
+  uint8_t     actions:2;
+  uint8_t     locators_present:1;
+  uint8_t     reserved:3;
+  uint32_t    nonce0;
+  uint32_t    nonce1;
+  uint16_t    lsb;
+  uint16_t    ttl;
+  uint32_t    timestamp;
+  uint32_t    control_packets_in;
+  uint32_t    control_packets_out;
+  uint8_t     num_locators;
+  lisp_cache_response_loc_t locators[0];
+} lisp_cache_response_msg_t;
+
+/*
+ * Message structure for adding a database entry,
+ * sent from user-space to the kernel.
+ */
+typedef struct {
+    lisp_addr_t locator;
+    uint8_t     priority;
+    uint8_t     weight;
+    uint8_t     mpriority;
+    uint8_t     mweight;
+} lisp_db_add_msg_loc_t;
+
+typedef struct {
+  lisp_addr_t           eid_prefix;
+  uint16_t              eid_prefix_length;
+  uint16_t              count;
+  lisp_db_add_msg_loc_t locators[0];
+} lisp_db_add_msg_t;
+
+/* 
+ * Response type for a database entry lookup,
+ * sent from the kernel to user-space.
+ */
+typedef struct {
+  lisp_addr_t    locator;
+  uint8_t        priority;
+  uint8_t	 weight;
+  uint8_t        mpriority;
+  uint8_t	 mweight;
+  uint8_t	 reserved:4;		
+} lisp_db_response_loc_t;
+
+typedef struct {
+  lisp_addr_t    eid_prefix;
+  uint8_t        eid_prefix_length;
+  uint8_t        num_locators;
+  uint16_t         lsb;
+  lisp_db_response_loc_t locators[0];
+} lisp_db_response_msg_t;
+
+/* 
+ * Database deletion message type. Sent
+ * from user-space to the kernel.
+ */
+typedef struct {
+  lisp_addr_t eid_prefix;
+  uint8_t     eid_prefix_length;
+  lisp_addr_t     locator;
+} lisp_db_delete_msg_t;
+  
+/*
+ * Cache miss or sampling notification, sent from kernel
+ * to lispd. When sent with no locators, indicates cache
+ * miss. Also sent *back* from lispd to the kernel
+ * when an RLOC probe sequence is completed for an EID.
+ * In this case, the status bits indicate the reachability
+ * of the locators in the list.
+ */
+typedef enum {
+    ProbeSample,
+    SMRSample,
+    CacheMiss
+} sample_reason_e;
+
+typedef struct {
+  int         reason;
+  lisp_addr_t eid;
+  int         eid_prefix_length; /* Unused when cache miss */
+  int         num_locators;      /* zero when cache miss */
+  int         status_bits;       /* Bitfield filled by lispd when sending back to kernel */
+  lisp_addr_t locators[0];
+} lisp_cache_sample_msg_t;
Index: package/lisp/src/lispd.conf.example
===================================================================
--- package/lisp/src/lispd.conf.example	(revision 0)
+++ package/lisp/src/lispd.conf.example	(revision 0)
@@ -0,0 +1,49 @@
+#
+#
+#       lispd example config file
+#
+#
+
+
+#
+#       deamon config
+#
+
+debug                = on 
+map-request-retries  = 3			# send 3 before giving up
+
+
+#
+#       LISP Config
+#
+
+# Encapsulated Map-Requests are sent to this map resolver
+map-resolver        = 128.223.156.23
+
+# Register to this map server
+map-server {
+        address	    = uo-mr-ms-1.rloc.lisp4.net # 128.223.156.35
+        key-type    = 0		                # cleartext
+        key	    = foo%bar
+	verify	    = off	                # on --> lig(self)
+	proxy-reply = on	                # ask ms to proxy reply
+}
+
+# Encapsulate packets for non-LISP sites to this Proxy-ETR
+proxy-etr           = cisco-sjc-mr-ms-1.rloc.lisp4.net
+
+# EID of the mobile node
+database-mapping {
+         eid-prefix = 153.16.254.1/32
+         interface  = eth0
+         priority   = 1 
+         weight     = 100
+}
+
+# Static cache entries
+static-map-cache {
+        eid-prefix  = 153.16.10.0/24
+        rloc        = 128.223.156.134
+        priority    = 1 
+        weight      = 100
+}
Index: package/lisp/src/lispd.c
===================================================================
--- package/lisp/src/lispd.c	(revision 0)
+++ package/lisp/src/lispd.c	(revision 0)
@@ -0,0 +1,450 @@
+/*
+ * lispd.c 
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * lispd Implementation
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    David Meyer           <dmm@cisco.com>
+ *    Preethi Natarajan     <prenatar@cisco.com>
+ *    Albert Cabellos       <acabello@ac.upc.edu>
+ *    Lorand Jakab          <ljakab@ac.upc.edu>
+ *    Vasileios Lakafosis   <vasileios@gatech.edu>
+ *
+ */
+
+#include <stdlib.h>
+#include <signal.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <syslog.h>
+#include <inttypes.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include "timerfd.h"
+/*#include <sys/timerfd.h>*/
+#include <netinet/in.h>
+#include <net/if.h>
+#include "lispd.h"
+
+void signal_handler();
+void callback_elt(datacache_elt_t *elt);
+
+/*
+ *      global (more or less) vars
+ *
+ */
+
+/*
+ *      database and map cache
+ */
+
+lispd_database_t  *lispd_database       = NULL;
+lispd_map_cache_t *lispd_map_cache      = NULL;
+
+/*
+ *      next gen database
+ */
+
+patricia_tree_t *AF4_database           = NULL;
+patricia_tree_t *AF6_database           = NULL;
+
+/*
+ *      data cache
+ */
+
+datacache_t     *datacache;
+
+/*
+ *      config paramaters
+ */
+
+lispd_addr_list_t       *map_resolvers  = 0;
+lispd_addr_list_t       *proxy_etrs     = 0;
+lispd_map_server_list_t *map_servers    = 0;
+char    *config_file                    = "lispd.conf";
+char    *map_resolver                   = NULL;
+char    *map_server                     = NULL;
+char    *proxy_etr                      = NULL;
+int      debug                          = 0;
+int      daemonize                      = 0;
+int      map_request_retries            = DEFAULT_MAP_REQUEST_RETRIES;
+int      control_port                   = LISP_CONTROL_PORT;
+uint32_t iseed  = 0;            /* initial random number generator */
+/*
+ *      various globals
+ */
+
+char   msg[128];                                /* syslog msg buffer */
+pid_t  pid                              = 0;    /* child pid */
+pid_t  sid                              = 0;
+/*
+ *      sockets (fds)
+ */
+int     v6_receive_fd                   = 0;
+int     v4_receive_fd                   = 0;
+int     netlink_fd                      = 0;
+fd_set  readfds;
+struct  sockaddr_nl dst_addr;
+struct  sockaddr_nl src_addr;
+nlsock_handle nlh;
+/*
+ *      timers (fds)
+ */
+int     map_register_timer_fd           = 0;
+
+/* 
+ * Interface on which control messages
+ * are sent
+ */
+iface_list_elt *ctrl_iface              = NULL;
+lispd_addr_t source_rloc;
+
+int main(int argc, char **argv) 
+{
+
+    /*
+     *  Check for superuser privileges
+     */
+
+    if (geteuid()) {
+        printf("Running %s requires superuser privileges! Exiting...\n", LISPD);
+        exit(EXIT_FAILURE);
+    }
+
+    /*
+     *  Initialize the random number generator
+     */
+     
+    iseed = (unsigned int) time (NULL);
+    srandom(iseed);
+
+    /*
+     * Set up signal handlers
+     */
+
+    signal(SIGHUP,  signal_handler);
+    signal(SIGTERM, signal_handler);
+    signal(SIGINT,  signal_handler);
+    signal(SIGQUIT, signal_handler);
+
+    /*
+     *  set up syslog now, checking to see if we're daemonizing...
+     */
+
+    set_up_syslog();
+
+    /*
+     *  Unload/load LISP kernel modules
+     */
+
+/* vlakafos
+    system("/sbin/modprobe -r lisp lisp_int");
+
+    if (system("/sbin/modprobe lisp")) {
+        syslog(LOG_DAEMON, "Loading the 'lisp' kernel module failed! Exiting...");
+        exit(EXIT_FAILURE);
+    }
+    syslog(LOG_DAEMON, "Loaded the 'lisp' kernel module");
+    sleep(1);
+
+    if (system("/sbin/modprobe lisp_int")) {
+        syslog(LOG_DAEMON, "Loading the 'lisp_int' kernel module failed! Exiting...");
+        exit(EXIT_FAILURE);
+    }
+    syslog(LOG_DAEMON, "Loaded the 'lisp_int' kernel module");
+    sleep(1);
+*/
+
+    /*
+     *  Setup LISP and routing netlink sockets
+     */
+
+    if (!setup_netlink()) {
+        syslog(LOG_DAEMON, "Can't set up netlink socket for lisp_mod communication");
+        exit(EXIT_FAILURE);
+    }
+
+    if (!setup_netlink_iface()) {
+        syslog(LOG_DAEMON, "Can't set up netlink socket for interface events");
+        exit(EXIT_FAILURE);
+    }
+
+    syslog(LOG_DAEMON, "Netlink sockets created");
+
+    /*
+     *  set up databases
+     */
+
+    AF4_database  = New_Patricia(sizeof(struct in_addr)  * 8);
+    AF6_database  = New_Patricia(sizeof(struct in6_addr) * 8);
+
+    /*
+     *  Parse command line options
+     */
+
+    handle_lispd_command_line(argc, argv);
+
+    // Modified by acabello
+    // init_datacache has the following parameters:
+    // void (*cbk)(datacache_elt_t*); -> callback function (see example in lispd_lib.c)
+    if (!init_datacache(callback_elt)) {
+        syslog(LOG_DAEMON, "malloc (datacache): %s", strerror(errno));
+        exit(EXIT_FAILURE);
+    }
+
+    /*
+     *  Now do the config file
+     */
+
+    handle_lispd_config_file();
+
+    /*
+     * now build the v4/v6 receive sockets
+     */
+
+    if (build_receive_sockets() == 0) 
+        exit(EXIT_FAILURE);
+
+    /*
+     *  create timers
+     */
+
+    if ((map_register_timer_fd = timerfd_create(CLOCK_REALTIME, 0)) == -1)
+        syslog(LOG_INFO, "Could not create periodic map register timer");
+
+    /*
+     *  see if we need to daemonize, and if so, do it
+     */
+
+    if (daemonize) {
+        syslog(LOG_INFO, "Starting the daemonizing process");
+        if ((pid = fork()) < 0) {
+            exit(EXIT_FAILURE);
+        } 
+        umask(0);
+        if (pid > 0)
+            exit(EXIT_SUCCESS);
+        if ((sid = setsid()) < 0)
+            exit(EXIT_FAILURE);
+        if ((chdir("/")) < 0)
+            exit(EXIT_FAILURE);
+        close(STDIN_FILENO);
+        close(STDOUT_FILENO);
+        close(STDERR_FILENO);
+    }
+
+    /* PN XXX
+     * comment out test definition to avoid any
+     * interactions with the data plane
+     */
+
+
+
+#define test
+#ifdef test
+
+    int ret = register_lispd_process();
+    if (ret < 0) {
+        syslog(LOG_INFO, "Couldn't register lispd process, err: %d", ret);
+        exit(EXIT_FAILURE);
+    }
+    syslog(LOG_DAEMON, "Registered lispd with kernel module");
+
+    ret = install_database_mappings();
+    if (ret < 0) {
+        syslog(LOG_INFO, "Could not install database mappings, err: %d", ret);
+        exit(EXIT_FAILURE);
+    }
+    syslog(LOG_DAEMON, "Installed database mappings");
+
+    ret = install_map_cache_entries();
+    if (ret < 0) {
+        syslog(LOG_INFO, "Could not install static map-cache entries, err: %d", ret);
+    }
+
+#endif
+
+    /*
+     *  Register to the Map-Server(s)
+     */
+
+    //vlakafos
+    //if (!map_register(AF6_database))
+    //    syslog(LOG_INFO, "Could not map register AF_INET6 with Map Servers");
+
+    if (!map_register(AF4_database))
+        syslog(LOG_INFO, "Could not map register AF_INET with Map Servers");
+
+    event_loop();
+    syslog(LOG_INFO, "Exiting...");         /* event_loop returned bad */
+    closelog();
+}
+
+/*
+ *      main event loop
+ *
+ *      should never return (in theory)
+ */
+
+event_loop ()
+{
+    int    max_fd;
+    fd_set readfds;
+    time_t curr,prev; //Modified by acabello
+
+    /*
+     *  calculate the max_fd for select. Is there a better way
+     *  to do this?
+     */
+
+    max_fd = (v4_receive_fd > v6_receive_fd) ? v4_receive_fd : v6_receive_fd;
+    max_fd = (max_fd > netlink_fd)           ? max_fd : netlink_fd;
+    max_fd = (max_fd > nlh.fd)               ? max_fd : nlh.fd;
+    max_fd = (max_fd > map_register_timer_fd)? max_fd : map_register_timer_fd;
+
+    // Modified by acabello
+    prev=time(NULL);
+
+    for (EVER) {
+        FD_ZERO(&readfds);
+        FD_SET(v4_receive_fd,&readfds);
+        FD_SET(v6_receive_fd,&readfds);
+        FD_SET(netlink_fd,&readfds);
+        FD_SET(nlh.fd, &readfds);
+        FD_SET(map_register_timer_fd, &readfds);
+        if (have_input(max_fd,&readfds) == -1)
+            break;                              /* news is bad */
+        if (FD_ISSET(v4_receive_fd,&readfds))
+            process_lisp_msg(v4_receive_fd, AF_INET);
+        if (FD_ISSET(v6_receive_fd,&readfds))
+            process_lisp_msg(v6_receive_fd, AF_INET6);
+        if (FD_ISSET(netlink_fd,&readfds))
+            process_netlink_msg();
+        if (FD_ISSET(nlh.fd,&readfds)) 
+                process_netlink_iface();
+        if (FD_ISSET(map_register_timer_fd,&readfds))
+                periodic_map_register();
+        // Modified by acabello
+        // Each second expire_datacache
+        // This can be improved by using threading and timer_create()
+        curr=time(NULL);
+        if ((curr-prev)>LISPD_EXPIRE_TIMEOUT) {
+                expire_datacache();
+                prev=time(NULL);
+            }
+    }
+}
+
+/*
+ *      signal_handler --
+ *
+ */
+
+void signal_handler(int sig) {
+    switch(sig) {
+    case SIGHUP:
+        /* TODO: SIGHUP should trigger reloading the configuration file */
+        syslog(LOG_WARNING, "Received SIGHUP signal.", LISPD);
+        break;
+    case SIGTERM:
+        /* SIGTERM is the default signal sent by 'kill'. Exit cleanly */
+        syslog(LOG_WARNING, "Received SIGTERM signal. Cleaning up...");
+        exit_cleanup();
+        break;
+    case SIGINT:
+        /* SIGINT is sent by pressing Ctrl-C. Exit cleanly */
+        syslog(LOG_WARNING, "Terminal interrupt. Cleaning up...");
+        exit_cleanup();
+        break;
+    default:
+        syslog(LOG_WARNING,"Unhandled signal (%d)", sig);
+        exit(EXIT_FAILURE);
+    }
+}
+
+
+// Modified by acabello
+// Callback function triggered each time an elt record expires
+void callback_elt(elt)
+        datacache_elt_t *elt;
+{
+    char eid_name[128];
+    uint16_t timeout;
+
+    /*
+     * TODO: AC: Gather some statistics, pass to lisp virtual interface?
+     */
+
+    elt->retries++;
+    if (elt->smr) {
+        if (elt->retries>LISPD_MAX_SMR_RETRANSMIT) {
+#ifdef  DEBUG
+            syslog(LOG_INFO, "Expired MRq SMR, we didn't receive corresponding MRp\n");
+#endif
+            delete_datacache_entry(elt);
+            return;
+        }
+        timeout = min_timeout(((elt->retries+1)*(elt->timeout)),LISPD_MAX_MRQ_TIMEOUT);
+    }
+    else {
+        if (elt->retries>map_request_retries) {
+#ifdef  DEBUG
+            syslog(LOG_INFO, "Expired MRq, we didn't receive corresponding MRp\n");
+#endif
+            delete_datacache_entry(elt);
+            return;
+        }
+        timeout = min_timeout(((elt->retries+1)*(elt->timeout)),LISPD_MAX_MRQ_TIMEOUT);
+    }
+
+    inet_ntop(elt->eid_prefix_afi, &(elt->eid_prefix).address,eid_name,128);
+
+#ifdef DEBUG
+    syslog(LOG_INFO, "Retransmitting MRq (SMR: %d) to: %s, retries: %d, timeout: %d\n",elt->smr,eid_name,elt->retries,timeout);
+#endif
+
+    build_and_send_map_request_msg(&elt->dest,
+                                    &elt->eid_prefix,
+                                    elt->eid_prefix_afi,
+                                    elt->eid_prefix_length,
+                                    eid_name,
+                                    elt->encap,
+                                    elt->smr,
+                                    0,        // XXX Check elt for SMR-invoked support
+                                    elt->local,
+                                    elt->retries,
+                                    timeout,
+                                    0);
+    delete_datacache_entry(elt);
+    return;
+}
+
+
+/*
+ * Editor modelines
+ *
+ * vi: set shiftwidth=4 tabstop=4 expandtab:
+ * :indentSize=4:tabSize=4:noTabs=true:
+ */
Index: package/lisp/src/patricia/patricia.h
===================================================================
--- package/lisp/src/patricia/patricia.h	(revision 0)
+++ package/lisp/src/patricia/patricia.h	(revision 0)
@@ -0,0 +1,147 @@
+/*
+ * $Id: patricia.h,v 1.6 2005/12/07 20:53:01 dplonka Exp $
+ * Dave Plonka <plonka@doit.wisc.edu>
+ *
+ * This product includes software developed by the University of Michigan,
+ * Merit Network, Inc., and their contributors. 
+ *
+ * This file had been called "radix.h" in the MRT sources.
+ *
+ * I renamed it to "patricia.h" since it's not an implementation of a general
+ * radix trie.  Also, pulled in various requirements from "mrt.h" and added
+ * some other things it could be used as a standalone API.
+ */
+
+#ifndef _PATRICIA_H
+#define _PATRICIA_H
+
+#define HAVE_IPV6
+
+/* typedef unsigned int u_int; */
+typedef void (*void_fn_t)();
+/* { from defs.h */
+#define prefix_touchar(prefix) ((u_char *)&(prefix)->add.sin)
+#define MAXLINE 1024
+#define BIT_TEST(f, b)  ((f) & (b))
+/* } */
+
+#define addroute make_and_lookup
+
+#include <sys/types.h> /* for u_* definitions (on FreeBSD 5) */
+
+#include <errno.h> /* for EAFNOSUPPORT */
+#ifndef EAFNOSUPPORT
+#  defined EAFNOSUPPORT WSAEAFNOSUPPORT
+#  include <winsock.h>
+#else
+#  include <netinet/in.h> /* for struct in_addr */
+#endif
+
+#include <sys/socket.h> /* for AF_INET */
+
+/* { from mrt.h */
+
+typedef struct _prefix4_t {
+    u_short family;		/* AF_INET | AF_INET6 */
+    u_short bitlen;		/* same as mask? */
+    int ref_count;		/* reference count */
+    struct in_addr sin;
+} prefix4_t;
+
+typedef struct _prefix_t {
+    u_short family;		/* AF_INET | AF_INET6 */
+    u_short bitlen;		/* same as mask? */
+    int ref_count;		/* reference count */
+    union {
+		struct in_addr sin;
+		struct in6_addr sin6;
+    } add;
+} prefix_t;
+
+/* } */
+
+typedef struct _patricia_node_t {
+   u_int bit;			/* flag if this node used */
+   prefix_t *prefix;		/* who we are in patricia tree */
+   struct _patricia_node_t *l, *r;	/* left and right children */
+   struct _patricia_node_t *parent;/* may be used */
+   void *data;			/* pointer to data */
+   void	*user1;			/* pointer to usr data (ex. route flap info) */
+} patricia_node_t;
+
+typedef struct _patricia_tree_t {
+   patricia_node_t 	*head;
+   u_int		maxbits;	/* for IP, 32 bit addresses */
+   int num_active_node;		/* for debug purpose */
+} patricia_tree_t;
+
+
+patricia_node_t *patricia_search_exact (patricia_tree_t *patricia, prefix_t *prefix);
+patricia_node_t *patricia_search_best (patricia_tree_t *patricia, prefix_t *prefix);
+patricia_node_t * patricia_search_best2 (patricia_tree_t *patricia, prefix_t *prefix, 
+				   int inclusive);
+patricia_node_t *patricia_lookup (patricia_tree_t *patricia, prefix_t *prefix);
+void patricia_remove (patricia_tree_t *patricia, patricia_node_t *node);
+patricia_tree_t *New_Patricia (int maxbits);
+void Clear_Patricia (patricia_tree_t *patricia, void_fn_t func);
+void Destroy_Patricia (patricia_tree_t *patricia, void_fn_t func);
+void patricia_process (patricia_tree_t *patricia, void_fn_t func);
+prefix_t *New_Prefix(int family, void *dest, int bitlen);
+/* { from demo.c */
+
+prefix_t *
+ascii2prefix (int family, char *string);
+
+patricia_node_t *
+make_and_lookup (patricia_tree_t *tree, int afi, char *string);
+
+/* } */
+
+#define PATRICIA_MAXBITS	(sizeof(struct in6_addr) * 8)
+#define PATRICIA_NBIT(x)        (0x80 >> ((x) & 0x7f))
+#define PATRICIA_NBYTE(x)       ((x) >> 3)
+
+#define PATRICIA_DATA_GET(node, type) (type *)((node)->data)
+#define PATRICIA_DATA_SET(node, value) ((node)->data = (void *)(value))
+
+#define PATRICIA_WALK(Xhead, Xnode) \
+    do { \
+        patricia_node_t *Xstack[PATRICIA_MAXBITS+1]; \
+        patricia_node_t **Xsp = Xstack; \
+        patricia_node_t *Xrn = (Xhead); \
+        while ((Xnode = Xrn)) { \
+            if (Xnode->prefix)
+
+#define PATRICIA_WALK_ALL(Xhead, Xnode) \
+do { \
+        patricia_node_t *Xstack[PATRICIA_MAXBITS+1]; \
+        patricia_node_t **Xsp = Xstack; \
+        patricia_node_t *Xrn = (Xhead); \
+        while ((Xnode = Xrn)) { \
+	    if (1)
+
+#define PATRICIA_WALK_BREAK { \
+	    if (Xsp != Xstack) { \
+		Xrn = *(--Xsp); \
+	     } else { \
+		Xrn = (patricia_node_t *) 0; \
+	    } \
+	    continue; }
+
+#define PATRICIA_WALK_END \
+            if (Xrn->l) { \
+                if (Xrn->r) { \
+                    *Xsp++ = Xrn->r; \
+                } \
+                Xrn = Xrn->l; \
+            } else if (Xrn->r) { \
+                Xrn = Xrn->r; \
+            } else if (Xsp != Xstack) { \
+                Xrn = *(--Xsp); \
+            } else { \
+                Xrn = (patricia_node_t *) 0; \
+            } \
+        } \
+    } while (0)
+
+#endif /* _PATRICIA_H */
Index: package/lisp/src/patricia/patricia.c
===================================================================
--- package/lisp/src/patricia/patricia.c	(revision 0)
+++ package/lisp/src/patricia/patricia.c	(revision 0)
@@ -0,0 +1,985 @@
+/*
+ * $Id: patricia.c,v 1.7 2005/12/07 20:46:41 dplonka Exp $
+ * Dave Plonka <plonka@doit.wisc.edu>
+ *
+ * This product includes software developed by the University of Michigan,
+ * Merit Network, Inc., and their contributors. 
+ *
+ * This file had been called "radix.c" in the MRT sources.
+ *
+ * I renamed it to "patricia.c" since it's not an implementation of a general
+ * radix trie.  Also I pulled in various requirements from "prefix.c" and
+ * "demo.c" so that it could be used as a standalone API.
+ *
+ *
+ *	Bunch of mods from David Meyer (dmm613@gmail.com) to make 
+ *	this deal with IPv6 in a more friendly fashion
+ *
+ *
+ */
+
+static char copyright[] =
+"This product includes software developed by the University of Michigan, Merit"
+"Network, Inc., and their contributors.";
+
+#include <assert.h> /* assert */
+#include <ctype.h> /* isdigit */
+#include <errno.h> /* errno */
+#include <math.h> /* sin */
+#include <stddef.h> /* NULL */
+#include <stdio.h> /* sprintf, fprintf, stderr */
+#include <stdlib.h> /* free, atol, calloc */
+#include <string.h> /* memcpy, strchr, strlen */
+#include <sys/types.h> /* BSD: for inet_addr */
+#include <sys/socket.h> /* BSD, Linux: for inet_addr */
+#include <syslog.h> 
+#include <netinet/in.h> /* BSD, Linux: for inet_addr */
+#include <arpa/inet.h> /* BSD, Linux, Solaris: for inet_addr */
+
+#include "patricia.h"
+
+#define Delete free
+
+/* { from prefix.c */
+
+/* prefix_tochar
+ * convert prefix information to bytes
+ */
+u_char *prefix_tochar (prefix_t * prefix)
+{
+    if (prefix == NULL)
+	return (NULL);
+    return ((u_char *) & prefix->add.sin);
+}
+
+int comp_with_mask (void *addr, void *dest, u_int mask)
+{
+
+    if ( /* mask/8 == 0 || */ memcmp (addr, dest, mask / 8) == 0) {
+	int n = mask / 8;
+	int m = ((-1) << (8 - (mask % 8)));
+
+	if (mask % 8 == 0 || (((u_char *)addr)[n] & m) == (((u_char *)dest)[n] & m))
+	    return (1);
+    }
+    return (0);
+}
+
+
+/* this allows imcomplete prefix */
+int my_inet_pton (int af, const char *src, void *dst)
+{
+    if (af == AF_INET) {
+        int i, c, val;
+        u_char xp[sizeof(struct in_addr)] = {0, 0, 0, 0};
+
+        for (i = 0; ; i++) {
+	    c = *src++;
+	    if (!isdigit (c))
+		return (-1);
+	    val = 0;
+	    do {
+		val = val * 10 + c - '0';
+		if (val > 255)
+		    return (0);
+		c = *src++;
+	    } while (c && isdigit (c));
+            xp[i] = val;
+	    if (c == '\0')
+		break;
+            if (c != '.')
+                return (0);
+	    if (i >= 3)
+		return (0);
+        }
+	memcpy (dst, xp, sizeof(struct in_addr));
+        return (1);
+    } else if (af == AF_INET6) {
+        return (inet_pton (af, src, dst));
+    } else {
+	return -1;
+    }
+}
+
+#define PATRICIA_MAX_THREADS		16
+
+/* 
+ * convert prefix information to ascii string with length
+ * thread safe and (almost) re-entrant implementation
+ */
+char *prefix_toa2x (prefix_t *prefix, char *buff, int with_len)
+{
+    if (prefix == NULL)
+	return ("(Null)");
+
+    assert (prefix->ref_count >= 0);
+
+    if (buff == NULL) {
+
+        struct buffer {
+            char buffs[PATRICIA_MAX_THREADS][48+5];
+            u_int i;
+        } *buffp;
+
+#    if 0
+	THREAD_SPECIFIC_DATA (struct buffer, buffp, 1);
+#    else
+        { /* for scope only */
+	    static struct buffer local_buff;
+	    buffp = &local_buff;
+	}
+#    endif
+	if (buffp == NULL) {
+	    /* XXX should we report an error? */
+	    return (NULL);
+	}
+
+	buff = buffp->buffs[buffp->i++%PATRICIA_MAX_THREADS];
+    }
+    if (prefix->family == AF_INET) {
+	u_char *a;
+	assert (prefix->bitlen <= sizeof(struct in_addr) * 8);
+	a = prefix_touchar (prefix);
+	if (with_len) {
+	    sprintf (buff, "%d.%d.%d.%d/%d", a[0], a[1], a[2], a[3],
+		     prefix->bitlen);
+	}
+	else {
+	    sprintf (buff, "%d.%d.%d.%d", a[0], a[1], a[2], a[3]);
+	}
+	return (buff);
+    }
+    else if (prefix->family == AF_INET6) {
+	char *r;
+	r = (char *) inet_ntop (AF_INET6, &(prefix->add.sin6), buff, 48 /* a guess value */ );
+
+	if (r && with_len) {
+	    assert (prefix->bitlen <= sizeof(struct in6_addr) * 8);
+	    sprintf (buff + strlen (buff), "/%d", prefix->bitlen);
+	}
+	return (buff);
+    }
+    else
+	return (NULL);
+}
+
+/* prefix_toa2
+ * convert prefix information to ascii string
+ */
+char *prefix_toa2 (prefix_t *prefix, char *buff)
+{
+    return (prefix_toa2x (prefix, buff, 0));
+}
+
+/* prefix_toa
+ */
+char *prefix_toa (prefix_t * prefix)
+{
+    return (prefix_toa2 (prefix, (char *) NULL));
+}
+
+prefix_t *New_Prefix2 (int family, void *dest, int bitlen, prefix_t *prefix)
+{
+    int dynamic_allocated = 0;
+    int default_bitlen    = 0;
+
+    if (prefix == NULL) {
+	/*	prefix = calloc(1, sizeof (prefix_t)); */
+        if ((prefix = (prefix_t *) malloc(sizeof(prefix_t))) == NULL) {
+	    syslog(LOG_DAEMON, "New_Prefix2: can't allocate new prefix");
+	    return(0);
+	}
+	memset(prefix, 0, sizeof (prefix_t));
+	dynamic_allocated++;
+    }
+
+
+    switch(family) {
+    case AF_INET:
+        default_bitlen = sizeof(struct in_addr) * 8;
+	memcpy (&prefix->add.sin, dest, sizeof(struct in_addr));
+        break;
+    case AF_INET6:
+        default_bitlen = sizeof(struct in6_addr) * 8;
+	memcpy (&prefix->add.sin6, dest, sizeof(struct in6_addr));
+	break;
+    default:
+	free(prefix);
+        return (NULL);
+    }
+
+    prefix->bitlen = (bitlen >= 0)? bitlen: default_bitlen;
+    prefix->family = family;
+    prefix->ref_count = 0;
+    if (dynamic_allocated) {
+        prefix->ref_count++;
+    }
+    return (prefix);
+}
+
+prefix_t *New_Prefix (int family, void *dest, int bitlen)
+{
+    return (New_Prefix2 (family, dest, bitlen, NULL));
+}
+
+/* ascii2prefix
+ */
+prefix_t * ascii2prefix (int family, char *string)
+{
+    u_long		bitlen    = 0;
+    u_long		maxbitlen = 0;
+    char		*cp       = NULL;
+    int			result    = 0;
+    struct in_addr	sin;
+    struct in6_addr	sin6;
+    char		save[MAXLINE];
+
+    if (!string)
+	return (NULL);
+
+    switch(family) {		/* set up maxbitlen */
+    case AF_INET:
+	maxbitlen = sizeof(struct in_addr) * 8;
+	break;
+    case AF_INET6:
+	maxbitlen = sizeof(struct in6_addr) * 8;
+	break;
+    default:
+	fprintf(stderr, "unknown AFI (%d)\n", family);
+	return(0);
+    }
+
+    if ((cp = strchr (string, '/')) != NULL) {
+	bitlen = atol (cp + 1);
+	/* *cp = '\0'; */
+	/* copy the string to save. Avoid destroying the string */
+	assert (cp - string < MAXLINE);
+	memcpy (save, string, cp - string);
+	save[cp - string] = '\0';
+	string = save;
+	if (bitlen < 0 || bitlen > maxbitlen)
+	    bitlen = maxbitlen;
+    }
+    else {
+	bitlen = maxbitlen;
+    }
+
+    /*
+     * now do the conversion
+     */
+
+    switch(family) {
+    case	AF_INET:
+        if ((result = my_inet_pton (AF_INET, string, &sin)) <= 0)
+	    return (NULL);
+	return (New_Prefix (AF_INET, &sin, bitlen));
+    case AF_INET6:
+	if ((result = inet_pton (AF_INET6, string, &sin6)) <= 0)
+	    return (NULL);
+	return (New_Prefix (AF_INET6, &sin6, bitlen));
+    default:
+	return (NULL);
+    }
+}
+
+prefix_t *Ref_Prefix (prefix_t * prefix)
+{
+    if (prefix == NULL)
+	return (NULL);
+    if (prefix->ref_count == 0) {
+	/* make a copy in case of a static prefix */
+        return (New_Prefix2 (prefix->family, &prefix->add, prefix->bitlen, NULL));
+    }
+    prefix->ref_count++;
+    /* fprintf(stderr, "[A %s, %d]\n", prefix_toa (prefix), prefix->ref_count); */
+    return (prefix);
+}
+
+void Deref_Prefix (prefix_t * prefix)
+{
+    if (prefix == NULL)
+	return;
+    /* for secure programming, raise an assert. no static prefix can call this */
+    assert (prefix->ref_count > 0);
+
+    prefix->ref_count--;
+    assert (prefix->ref_count >= 0);
+    if (prefix->ref_count <= 0) {
+	Delete (prefix);
+	return;
+    }
+}
+
+/* } */
+
+/* #define PATRICIA_DEBUG 1  */
+
+static int num_active_patricia = 0;
+
+/* these routines support continuous mask only */
+
+patricia_tree_t *
+New_Patricia (int maxbits)
+{
+    patricia_tree_t *patricia = calloc(1, sizeof *patricia);
+
+    patricia->maxbits = maxbits;
+    patricia->head = NULL;
+    patricia->num_active_node = 0;
+    assert (maxbits <= PATRICIA_MAXBITS); /* XXX */
+    num_active_patricia++;
+    return (patricia);
+}
+
+
+/*
+ * if func is supplied, it will be called as func(node->data)
+ * before deleting the node
+ */
+
+void
+Clear_Patricia (patricia_tree_t *patricia, void_fn_t func)
+{
+    assert (patricia);
+    if (patricia->head) {
+
+        patricia_node_t *Xstack[PATRICIA_MAXBITS+1];
+        patricia_node_t **Xsp = Xstack;
+        patricia_node_t *Xrn = patricia->head;
+
+        while (Xrn) {
+            patricia_node_t *l = Xrn->l;
+            patricia_node_t *r = Xrn->r;
+
+    	    if (Xrn->prefix) {
+		Deref_Prefix (Xrn->prefix);
+		if (Xrn->data && func)
+	    	    func (Xrn->data);
+    	    }
+    	    else {
+		assert (Xrn->data == NULL);
+    	    }
+    	    Delete (Xrn);
+	    patricia->num_active_node--;
+
+            if (l) {
+                if (r) {
+                    *Xsp++ = r;
+                }
+                Xrn = l;
+            } else if (r) {
+                Xrn = r;
+            } else if (Xsp != Xstack) {
+                Xrn = *(--Xsp);
+            } else {
+                Xrn = NULL;
+            }
+        }
+    }
+    assert (patricia->num_active_node == 0);
+    /* Delete (patricia); */
+}
+
+
+void
+Destroy_Patricia (patricia_tree_t *patricia, void_fn_t func)
+{
+    Clear_Patricia (patricia, func);
+    Delete (patricia);
+    num_active_patricia--;
+}
+
+
+/*
+ * if func is supplied, it will be called as func(node->prefix, node->data)
+ */
+
+void
+patricia_process (patricia_tree_t *patricia, void_fn_t func)
+{
+    patricia_node_t *node;
+    assert (func);
+
+    PATRICIA_WALK (patricia->head, node) {
+	func (node->prefix, node->data);
+    } PATRICIA_WALK_END;
+}
+
+size_t
+patricia_walk_inorder(patricia_node_t *node, void_fn_t func)
+{
+    size_t n = 0;
+    assert(func);
+
+    if (node->l) {
+         n += patricia_walk_inorder(node->l, func);
+    }
+
+    if (node->prefix) {
+	func(node->prefix, node->data);
+	n++;
+    }
+	
+    if (node->r) {
+         n += patricia_walk_inorder(node->r, func);
+    }
+
+    return n;
+}
+
+
+patricia_node_t *
+patricia_search_exact (patricia_tree_t *patricia, prefix_t *prefix)
+{
+    patricia_node_t *node;
+    u_char *addr;
+    u_int bitlen;
+
+    assert (patricia);
+    assert (prefix);
+    assert (prefix->bitlen <= patricia->maxbits);
+
+    if (patricia->head == NULL)
+	return (NULL);
+
+    node = patricia->head;
+    addr = prefix_touchar (prefix);
+    bitlen = prefix->bitlen;
+
+    while (node->bit < bitlen) {
+
+	if (BIT_TEST (addr[node->bit >> 3], 0x80 >> (node->bit & 0x07))) {
+#ifdef PATRICIA_DEBUG
+	    if (node->prefix)
+    	        fprintf (stderr, "patricia_search_exact: take right %s/%d\n", 
+	                 prefix_toa (node->prefix), node->prefix->bitlen);
+	    else
+    	        fprintf (stderr, "patricia_search_exact: take right at %u\n", 
+			 node->bit);
+#endif /* PATRICIA_DEBUG */
+	    node = node->r;
+	}
+	else {
+#ifdef PATRICIA_DEBUG
+	    if (node->prefix)
+    	        fprintf (stderr, "patricia_search_exact: take left %s/%d\n", 
+	                 prefix_toa (node->prefix), node->prefix->bitlen);
+	    else
+    	        fprintf (stderr, "patricia_search_exact: take left at %u\n", 
+			 node->bit);
+#endif /* PATRICIA_DEBUG */
+	    node = node->l;
+	}
+
+	if (node == NULL)
+	    return (NULL);
+    }
+
+#ifdef PATRICIA_DEBUG
+    if (node->prefix)
+        fprintf (stderr, "patricia_search_exact: stop at %s/%d\n", 
+	         prefix_toa (node->prefix), node->prefix->bitlen);
+    else
+        fprintf (stderr, "patricia_search_exact: stop at %u\n", node->bit);
+#endif /* PATRICIA_DEBUG */
+    if (node->bit > bitlen || node->prefix == NULL)
+	return (NULL);
+    assert (node->bit == bitlen);
+    assert (node->bit == node->prefix->bitlen);
+    if (comp_with_mask (prefix_tochar (node->prefix), prefix_tochar (prefix),
+			bitlen)) {
+#ifdef PATRICIA_DEBUG
+        fprintf (stderr, "patricia_search_exact: found %s/%d\n", 
+	         prefix_toa (node->prefix), node->prefix->bitlen);
+#endif /* PATRICIA_DEBUG */
+	return (node);
+    }
+    return (NULL);
+}
+
+
+/* if inclusive != 0, "best" may be the given prefix itself */
+patricia_node_t *
+patricia_search_best2 (patricia_tree_t *patricia, prefix_t *prefix, int inclusive)
+{
+    patricia_node_t *node;
+    patricia_node_t *stack[PATRICIA_MAXBITS + 1];
+    u_char *addr;
+    u_int bitlen;
+    int cnt = 0;
+
+    assert (patricia);
+    assert (prefix);
+    assert (prefix->bitlen <= patricia->maxbits);
+
+    if (patricia->head == NULL)
+	return (NULL);
+
+    node = patricia->head;
+    addr = prefix_touchar (prefix);
+    bitlen = prefix->bitlen;
+
+    while (node->bit < bitlen) {
+
+	if (node->prefix) {
+#ifdef PATRICIA_DEBUG
+            fprintf (stderr, "patricia_search_best: push %s/%d\n", 
+	             prefix_toa (node->prefix), node->prefix->bitlen);
+#endif /* PATRICIA_DEBUG */
+	    stack[cnt++] = node;
+	}
+
+	if (BIT_TEST (addr[node->bit >> 3], 0x80 >> (node->bit & 0x07))) {
+#ifdef PATRICIA_DEBUG
+	    if (node->prefix)
+    	        fprintf (stderr, "patricia_search_best: take right %s/%d\n", 
+	                 prefix_toa (node->prefix), node->prefix->bitlen);
+	    else
+    	        fprintf (stderr, "patricia_search_best: take right at %u\n", 
+			 node->bit);
+#endif /* PATRICIA_DEBUG */
+	    node = node->r;
+	}
+	else {
+#ifdef PATRICIA_DEBUG
+	    if (node->prefix)
+    	        fprintf (stderr, "patricia_search_best: take left %s/%d\n", 
+	                 prefix_toa (node->prefix), node->prefix->bitlen);
+	    else
+    	        fprintf (stderr, "patricia_search_best: take left at %u\n", 
+			 node->bit);
+#endif /* PATRICIA_DEBUG */
+	    node = node->l;
+	}
+
+	if (node == NULL)
+	    break;
+    }
+
+    if (inclusive && node && node->prefix)
+	stack[cnt++] = node;
+
+#ifdef PATRICIA_DEBUG
+    if (node == NULL)
+        fprintf (stderr, "patricia_search_best: stop at null\n");
+    else if (node->prefix)
+        fprintf (stderr, "patricia_search_best: stop at %s/%d\n", 
+	         prefix_toa (node->prefix), node->prefix->bitlen);
+    else
+        fprintf (stderr, "patricia_search_best: stop at %u\n", node->bit);
+#endif /* PATRICIA_DEBUG */
+
+    if (cnt <= 0)
+	return (NULL);
+
+    while (--cnt >= 0) {
+	node = stack[cnt];
+#ifdef PATRICIA_DEBUG
+        fprintf (stderr, "patricia_search_best: pop %s/%d\n", 
+	         prefix_toa (node->prefix), node->prefix->bitlen);
+#endif /* PATRICIA_DEBUG */
+	if (comp_with_mask (prefix_tochar (node->prefix), 
+			    prefix_tochar (prefix),
+			    node->prefix->bitlen) && node->prefix->bitlen <= bitlen) {
+#ifdef PATRICIA_DEBUG
+            fprintf (stderr, "patricia_search_best: found %s/%d\n", 
+	             prefix_toa (node->prefix), node->prefix->bitlen);
+#endif /* PATRICIA_DEBUG */
+	    return (node);
+	}
+    }
+    return (NULL);
+}
+
+
+patricia_node_t *
+patricia_search_best (patricia_tree_t *patricia, prefix_t *prefix)
+{
+    return (patricia_search_best2 (patricia, prefix, 1));
+}
+
+
+patricia_node_t *
+patricia_lookup (patricia_tree_t *patricia, prefix_t *prefix)
+{
+    patricia_node_t *node, *new_node, *parent, *glue;
+    u_char *addr, *test_addr;
+    u_int bitlen, check_bit, differ_bit;
+    int i, j, r;
+
+    assert (patricia);
+    assert (prefix);
+    assert (prefix->bitlen <= patricia->maxbits);
+
+    if (patricia->head == NULL) {
+	node = calloc(1, sizeof *node);
+	node->bit = prefix->bitlen;
+	node->prefix = Ref_Prefix (prefix);
+	node->parent = NULL;
+	node->l = node->r = NULL;
+	node->data = NULL;
+	patricia->head = node;
+#ifdef PATRICIA_DEBUG
+	fprintf (stderr, "patricia_lookup: new_node #0 %s/%d (head)\n", 
+		 prefix_toa (prefix), prefix->bitlen);
+#endif /* PATRICIA_DEBUG */
+	patricia->num_active_node++;
+	return (node);
+    }
+
+    addr = prefix_touchar (prefix);
+    bitlen = prefix->bitlen;
+    node = patricia->head;
+
+    while (node->bit < bitlen || node->prefix == NULL) {
+
+	if (node->bit < patricia->maxbits &&
+	    BIT_TEST (addr[node->bit >> 3], 0x80 >> (node->bit & 0x07))) {
+	    if (node->r == NULL)
+		break;
+#ifdef PATRICIA_DEBUG
+	    if (node->prefix)
+    	        fprintf (stderr, "patricia_lookup: take right %s/%d\n", 
+	                 prefix_toa (node->prefix), node->prefix->bitlen);
+	    else
+    	        fprintf (stderr, "patricia_lookup: take right at %u\n", node->bit);
+#endif /* PATRICIA_DEBUG */
+	    node = node->r;
+	}
+	else {
+	    if (node->l == NULL)
+		break;
+#ifdef PATRICIA_DEBUG
+	    if (node->prefix)
+    	        fprintf (stderr, "patricia_lookup: take left %s/%d\n", 
+	             prefix_toa (node->prefix), node->prefix->bitlen);
+	    else
+    	        fprintf (stderr, "patricia_lookup: take left at %u\n", node->bit);
+#endif /* PATRICIA_DEBUG */
+	    node = node->l;
+	}
+
+	assert (node);
+    }
+
+    assert (node->prefix);
+#ifdef PATRICIA_DEBUG
+    fprintf (stderr, "patricia_lookup: stop at %s/%d\n", 
+	     prefix_toa (node->prefix), node->prefix->bitlen);
+#endif /* PATRICIA_DEBUG */
+
+    test_addr = prefix_touchar (node->prefix);
+    /* find the first bit different */
+    check_bit = (node->bit < bitlen)? node->bit: bitlen;
+    differ_bit = 0;
+    for (i = 0; i*8 < check_bit; i++) {
+	if ((r = (addr[i] ^ test_addr[i])) == 0) {
+	    differ_bit = (i + 1) * 8;
+	    continue;
+	}
+	/* I know the better way, but for now */
+	for (j = 0; j < 8; j++) {
+	    if (BIT_TEST (r, (0x80 >> j)))
+		break;
+	}
+	/* must be found */
+	assert (j < 8);
+	differ_bit = i * 8 + j;
+	break;
+    }
+    if (differ_bit > check_bit)
+	differ_bit = check_bit;
+#ifdef PATRICIA_DEBUG
+    fprintf (stderr, "patricia_lookup: differ_bit %d\n", differ_bit);
+#endif /* PATRICIA_DEBUG */
+
+    parent = node->parent;
+    while (parent && parent->bit >= differ_bit) {
+	node = parent;
+	parent = node->parent;
+#ifdef PATRICIA_DEBUG
+	if (node->prefix)
+            fprintf (stderr, "patricia_lookup: up to %s/%d\n", 
+	             prefix_toa (node->prefix), node->prefix->bitlen);
+	else
+            fprintf (stderr, "patricia_lookup: up to %u\n", node->bit);
+#endif /* PATRICIA_DEBUG */
+    }
+
+    if (differ_bit == bitlen && node->bit == bitlen) {
+	if (node->prefix) {
+#ifdef PATRICIA_DEBUG 
+    	    fprintf (stderr, "patricia_lookup: found %s/%d\n", 
+		     prefix_toa (node->prefix), node->prefix->bitlen);
+#endif /* PATRICIA_DEBUG */
+	    return (node);
+	}
+	node->prefix = Ref_Prefix (prefix);
+#ifdef PATRICIA_DEBUG
+	fprintf (stderr, "patricia_lookup: new node #1 %s/%d (glue mod)\n",
+		 prefix_toa (prefix), prefix->bitlen);
+#endif /* PATRICIA_DEBUG */
+	assert (node->data == NULL);
+	return (node);
+    }
+
+    new_node = calloc(1, sizeof *new_node);
+    new_node->bit = prefix->bitlen;
+    new_node->prefix = Ref_Prefix (prefix);
+    new_node->parent = NULL;
+    new_node->l = new_node->r = NULL;
+    new_node->data = NULL;
+    patricia->num_active_node++;
+
+    if (node->bit == differ_bit) {
+	new_node->parent = node;
+	if (node->bit < patricia->maxbits &&
+	    BIT_TEST (addr[node->bit >> 3], 0x80 >> (node->bit & 0x07))) {
+	    assert (node->r == NULL);
+	    node->r = new_node;
+	}
+	else {
+	    assert (node->l == NULL);
+	    node->l = new_node;
+	}
+#ifdef PATRICIA_DEBUG
+	fprintf (stderr, "patricia_lookup: new_node #2 %s/%d (child)\n", 
+		 prefix_toa (prefix), prefix->bitlen);
+#endif /* PATRICIA_DEBUG */
+	return (new_node);
+    }
+
+    if (bitlen == differ_bit) {
+	if (bitlen < patricia->maxbits &&
+	    BIT_TEST (test_addr[bitlen >> 3], 0x80 >> (bitlen & 0x07))) {
+	    new_node->r = node;
+	}
+	else {
+	    new_node->l = node;
+	}
+	new_node->parent = node->parent;
+	if (node->parent == NULL) {
+	    assert (patricia->head == node);
+	    patricia->head = new_node;
+	}
+	else if (node->parent->r == node) {
+	    node->parent->r = new_node;
+	}
+	else {
+	    node->parent->l = new_node;
+	}
+	node->parent = new_node;
+#ifdef PATRICIA_DEBUG
+	fprintf (stderr, "patricia_lookup: new_node #3 %s/%d (parent)\n", 
+		 prefix_toa (prefix), prefix->bitlen);
+#endif /* PATRICIA_DEBUG */
+    }
+    else {
+        glue = calloc(1, sizeof *glue);
+        glue->bit = differ_bit;
+        glue->prefix = NULL;
+        glue->parent = node->parent;
+        glue->data = NULL;
+        patricia->num_active_node++;
+	if (differ_bit < patricia->maxbits &&
+	    BIT_TEST (addr[differ_bit >> 3], 0x80 >> (differ_bit & 0x07))) {
+	    glue->r = new_node;
+	    glue->l = node;
+	}
+	else {
+	    glue->r = node;
+	    glue->l = new_node;
+	}
+	new_node->parent = glue;
+
+	if (node->parent == NULL) {
+	    assert (patricia->head == node);
+	    patricia->head = glue;
+	}
+	else if (node->parent->r == node) {
+	    node->parent->r = glue;
+	}
+	else {
+	    node->parent->l = glue;
+	}
+	node->parent = glue;
+#ifdef PATRICIA_DEBUG
+	fprintf (stderr, "patricia_lookup: new_node #4 %s/%d (glue+node)\n", 
+		 prefix_toa (prefix), prefix->bitlen);
+#endif /* PATRICIA_DEBUG */
+    }
+    return (new_node);
+}
+
+
+void
+patricia_remove (patricia_tree_t *patricia, patricia_node_t *node)
+{
+    patricia_node_t *parent, *child;
+
+    assert (patricia);
+    assert (node);
+
+    if (node->r && node->l) {
+#ifdef PATRICIA_DEBUG
+	fprintf (stderr, "patricia_remove: #0 %s/%d (r & l)\n", 
+		 prefix_toa (node->prefix), node->prefix->bitlen);
+#endif /* PATRICIA_DEBUG */
+	
+	/* this might be a placeholder node -- have to check and make sure
+	 * there is a prefix aossciated with it ! */
+	if (node->prefix != NULL) 
+	  Deref_Prefix (node->prefix);
+	node->prefix = NULL;
+	/* Also I needed to clear data pointer -- masaki */
+	node->data = NULL;
+	return;
+    }
+
+    if (node->r == NULL && node->l == NULL) {
+#ifdef PATRICIA_DEBUG
+	fprintf (stderr, "patricia_remove: #1 %s/%d (!r & !l)\n", 
+		 prefix_toa (node->prefix), node->prefix->bitlen);
+#endif /* PATRICIA_DEBUG */
+	parent = node->parent;
+	Deref_Prefix (node->prefix);
+	Delete (node);
+        patricia->num_active_node--;
+
+	if (parent == NULL) {
+	    assert (patricia->head == node);
+	    patricia->head = NULL;
+	    return;
+	}
+
+	if (parent->r == node) {
+	    parent->r = NULL;
+	    child = parent->l;
+	}
+	else {
+	    assert (parent->l == node);
+	    parent->l = NULL;
+	    child = parent->r;
+	}
+
+	if (parent->prefix)
+	    return;
+
+	/* we need to remove parent too */
+
+	if (parent->parent == NULL) {
+	    assert (patricia->head == parent);
+	    patricia->head = child;
+	}
+	else if (parent->parent->r == parent) {
+	    parent->parent->r = child;
+	}
+	else {
+	    assert (parent->parent->l == parent);
+	    parent->parent->l = child;
+	}
+	child->parent = parent->parent;
+	Delete (parent);
+        patricia->num_active_node--;
+	return;
+    }
+
+#ifdef PATRICIA_DEBUG
+    fprintf (stderr, "patricia_remove: #2 %s/%d (r ^ l)\n", 
+	     prefix_toa (node->prefix), node->prefix->bitlen);
+#endif /* PATRICIA_DEBUG */
+    if (node->r) {
+	child = node->r;
+    }
+    else {
+	assert (node->l);
+	child = node->l;
+    }
+    parent = node->parent;
+    child->parent = parent;
+
+    Deref_Prefix (node->prefix);
+    Delete (node);
+    patricia->num_active_node--;
+
+    if (parent == NULL) {
+	assert (patricia->head == node);
+	patricia->head = child;
+	return;
+    }
+
+    if (parent->r == node) {
+	parent->r = child;
+    }
+    else {
+        assert (parent->l == node);
+	parent->l = child;
+    }
+}
+
+
+patricia_node_t * make_and_lookup (patricia_tree_t *tree, int afi, char *string)
+{
+    prefix_t *prefix;
+    patricia_node_t *node;
+
+    prefix = ascii2prefix (afi, string);
+
+#if (DEBUG > 3)
+    printf ("make_and_lookup: %s/%d\n", prefix_toa (prefix), prefix->bitlen);
+#endif
+
+    node = patricia_lookup (tree, prefix);
+    Deref_Prefix (prefix);
+    return (node);
+}
+
+patricia_node_t *
+try_search_exact (patricia_tree_t *tree, int afi, char *string)
+{
+    prefix_t *prefix;
+    patricia_node_t *node;
+
+    prefix = ascii2prefix (afi, string);
+    node = patricia_search_exact (tree, prefix);
+
+#ifdef DEBUG
+    if (node) 
+        printf ("try_search_exact: %s/%d found\n", 
+	        prefix_toa (node->prefix), node->prefix->bitlen);
+    else
+        printf ("try_search_exact: not found\n");
+#endif
+
+    Deref_Prefix (prefix);
+    return (node);
+}
+
+void
+lookup_then_remove (patricia_tree_t *tree, int afi, char *string)
+{
+    patricia_node_t *node;
+
+    if (node = try_search_exact (tree, afi, string))
+        patricia_remove (tree, node);
+}
+
+patricia_node_t *
+try_search_best (patricia_tree_t *tree, int afi, char *string)
+{
+    prefix_t *prefix;
+    patricia_node_t *node;
+
+    prefix = ascii2prefix (afi, string);
+    printf ("try_search_best: %s/%d\n", prefix_toa (prefix), prefix->bitlen);
+    if ((node = patricia_search_best (tree, prefix)) == NULL)
+        printf ("try_search_best: not found\n");
+    else
+        printf ("try_search_best: %s/%d found\n", 
+	        prefix_toa (node->prefix), node->prefix->bitlen);
+    Deref_Prefix (prefix);
+    return (node);		    /* was return(prefix) ...why? */
+
+}
+
+/* } */
Index: package/lisp/src/lispd_syslog.c
===================================================================
--- package/lisp/src/lispd_syslog.c	(revision 0)
+++ package/lisp/src/lispd_syslog.c	(revision 0)
@@ -0,0 +1,49 @@
+/*
+ * lispd_syslog.c
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Write a message to /var/log/syslog 
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    David Meyer       <dmm@cisco.com>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+#include "lispd_external.h"
+
+set_up_syslog ()
+{
+
+    setlogmask(LOG_UPTO(LOG_INFO));
+    openlog(LISPD, LOG_CONS, LOG_USER);
+ 
+    if (!daemonize) {           /* print it to the user if not a daemon */
+        setlogmask(LOG_UPTO(LOG_DEBUG));
+        openlog(LISPD, LOG_CONS | LOG_NDELAY | LOG_PERROR | LOG_PID, LOG_USER);
+    }
+
+    syslog(LOG_INFO, "Starting up...");
+
+}
+
+
Index: package/lisp/src/cmdline.c
===================================================================
--- package/lisp/src/cmdline.c	(revision 0)
+++ package/lisp/src/cmdline.c	(revision 0)
@@ -0,0 +1,689 @@
+/*
+  File autogenerated by gengetopt version 2.22.4
+  generated with the following command:
+  gengetopt -i lispd.ggo 
+
+  The developers of gengetopt consider the fixed text that goes in all
+  gengetopt output files to be in the public domain:
+  we make no copyright claims on it.
+*/
+
+/* If we use autoconf.  */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#ifndef FIX_UNUSED
+#define FIX_UNUSED(X) (void) (X) /* avoid warnings for unused params */
+#endif
+
+#include <getopt.h>
+
+#include "cmdline.h"
+
+const char *gengetopt_args_info_purpose = "";
+
+const char *gengetopt_args_info_usage = "Usage: lispd [OPTIONS]...";
+
+const char *gengetopt_args_info_description = "";
+
+const char *gengetopt_args_info_help[] = {
+  "  -h, --help                    Print help and exit",
+  "  -V, --version                 Print version and exit",
+  "\n Mode: lispdconfig",
+  "  -d, --debug                   Debuging output",
+  "  -n, --nodaemonize             Don't daemonize",
+  "  -f, --config-file=config-file Alternate config file",
+  "  -m, --map-resolver=MR         MR is the IPv{4,6} address or FQDN of the Map \n                                  Resolver to use",
+  "  -s, --map-server=MS           MS is the IPv{4,6} address or FQDN of the Map \n                                  Server to use",
+  "  -e, --proxy-etr=PETR          PETR is the IPv{4,6} address or FQDN of the \n                                  Proxy-ETR to use",
+  "  -p, --control_port=CP         CP is the LISP control port (default: 4342)",
+  "  -r, --map-request-retries=R   R is number of map-requests to send",
+    0
+};
+
+typedef enum {ARG_NO
+  , ARG_STRING
+  , ARG_INT
+} cmdline_parser_arg_type;
+
+static
+void clear_given (struct gengetopt_args_info *args_info);
+static
+void clear_args (struct gengetopt_args_info *args_info);
+
+static int
+cmdline_parser_internal (int argc, char **argv, struct gengetopt_args_info *args_info,
+                        struct cmdline_parser_params *params, const char *additional_error);
+
+
+static char *
+gengetopt_strdup (const char *s);
+
+static
+void clear_given (struct gengetopt_args_info *args_info)
+{
+  args_info->help_given = 0 ;
+  args_info->version_given = 0 ;
+  args_info->debug_given = 0 ;
+  args_info->nodaemonize_given = 0 ;
+  args_info->config_file_given = 0 ;
+  args_info->map_resolver_given = 0 ;
+  args_info->map_server_given = 0 ;
+  args_info->proxy_etr_given = 0 ;
+  args_info->control_port_given = 0 ;
+  args_info->map_request_retries_given = 0 ;
+  args_info->lispdconfig_mode_counter = 0 ;
+}
+
+static
+void clear_args (struct gengetopt_args_info *args_info)
+{
+  FIX_UNUSED (args_info);
+  args_info->config_file_arg = NULL;
+  args_info->config_file_orig = NULL;
+  args_info->map_resolver_arg = NULL;
+  args_info->map_resolver_orig = NULL;
+  args_info->map_server_arg = NULL;
+  args_info->map_server_orig = NULL;
+  args_info->proxy_etr_arg = NULL;
+  args_info->proxy_etr_orig = NULL;
+  args_info->control_port_arg = NULL;
+  args_info->control_port_orig = NULL;
+  args_info->map_request_retries_orig = NULL;
+  
+}
+
+static
+void init_args_info(struct gengetopt_args_info *args_info)
+{
+
+
+  args_info->help_help = gengetopt_args_info_help[0] ;
+  args_info->version_help = gengetopt_args_info_help[1] ;
+  args_info->debug_help = gengetopt_args_info_help[3] ;
+  args_info->nodaemonize_help = gengetopt_args_info_help[4] ;
+  args_info->config_file_help = gengetopt_args_info_help[5] ;
+  args_info->map_resolver_help = gengetopt_args_info_help[6] ;
+  args_info->map_server_help = gengetopt_args_info_help[7] ;
+  args_info->proxy_etr_help = gengetopt_args_info_help[8] ;
+  args_info->control_port_help = gengetopt_args_info_help[9] ;
+  args_info->map_request_retries_help = gengetopt_args_info_help[10] ;
+  
+}
+
+void
+cmdline_parser_print_version (void)
+{
+  printf ("%s %s\n",
+     (strlen(CMDLINE_PARSER_PACKAGE_NAME) ? CMDLINE_PARSER_PACKAGE_NAME : CMDLINE_PARSER_PACKAGE),
+     CMDLINE_PARSER_VERSION);
+}
+
+static void print_help_common(void) {
+  cmdline_parser_print_version ();
+
+  if (strlen(gengetopt_args_info_purpose) > 0)
+    printf("\n%s\n", gengetopt_args_info_purpose);
+
+  if (strlen(gengetopt_args_info_usage) > 0)
+    printf("\n%s\n", gengetopt_args_info_usage);
+
+  printf("\n");
+
+  if (strlen(gengetopt_args_info_description) > 0)
+    printf("%s\n\n", gengetopt_args_info_description);
+}
+
+void
+cmdline_parser_print_help (void)
+{
+  int i = 0;
+  print_help_common();
+  while (gengetopt_args_info_help[i])
+    printf("%s\n", gengetopt_args_info_help[i++]);
+}
+
+void
+cmdline_parser_init (struct gengetopt_args_info *args_info)
+{
+  clear_given (args_info);
+  clear_args (args_info);
+  init_args_info (args_info);
+}
+
+void
+cmdline_parser_params_init(struct cmdline_parser_params *params)
+{
+  if (params)
+    { 
+      params->override = 0;
+      params->initialize = 1;
+      params->check_required = 1;
+      params->check_ambiguity = 0;
+      params->print_errors = 1;
+    }
+}
+
+struct cmdline_parser_params *
+cmdline_parser_params_create(void)
+{
+  struct cmdline_parser_params *params = 
+    (struct cmdline_parser_params *)malloc(sizeof(struct cmdline_parser_params));
+  cmdline_parser_params_init(params);  
+  return params;
+}
+
+static void
+free_string_field (char **s)
+{
+  if (*s)
+    {
+      free (*s);
+      *s = 0;
+    }
+}
+
+
+static void
+cmdline_parser_release (struct gengetopt_args_info *args_info)
+{
+
+  free_string_field (&(args_info->config_file_arg));
+  free_string_field (&(args_info->config_file_orig));
+  free_string_field (&(args_info->map_resolver_arg));
+  free_string_field (&(args_info->map_resolver_orig));
+  free_string_field (&(args_info->map_server_arg));
+  free_string_field (&(args_info->map_server_orig));
+  free_string_field (&(args_info->proxy_etr_arg));
+  free_string_field (&(args_info->proxy_etr_orig));
+  free_string_field (&(args_info->control_port_arg));
+  free_string_field (&(args_info->control_port_orig));
+  free_string_field (&(args_info->map_request_retries_orig));
+  
+  
+
+  clear_given (args_info);
+}
+
+
+static void
+write_into_file(FILE *outfile, const char *opt, const char *arg, const char *values[])
+{
+  FIX_UNUSED (values);
+  if (arg) {
+    fprintf(outfile, "%s=\"%s\"\n", opt, arg);
+  } else {
+    fprintf(outfile, "%s\n", opt);
+  }
+}
+
+
+int
+cmdline_parser_dump(FILE *outfile, struct gengetopt_args_info *args_info)
+{
+  int i = 0;
+
+  if (!outfile)
+    {
+      fprintf (stderr, "%s: cannot dump options to stream\n", CMDLINE_PARSER_PACKAGE);
+      return EXIT_FAILURE;
+    }
+
+  if (args_info->help_given)
+    write_into_file(outfile, "help", 0, 0 );
+  if (args_info->version_given)
+    write_into_file(outfile, "version", 0, 0 );
+  if (args_info->debug_given)
+    write_into_file(outfile, "debug", 0, 0 );
+  if (args_info->nodaemonize_given)
+    write_into_file(outfile, "nodaemonize", 0, 0 );
+  if (args_info->config_file_given)
+    write_into_file(outfile, "config-file", args_info->config_file_orig, 0);
+  if (args_info->map_resolver_given)
+    write_into_file(outfile, "map-resolver", args_info->map_resolver_orig, 0);
+  if (args_info->map_server_given)
+    write_into_file(outfile, "map-server", args_info->map_server_orig, 0);
+  if (args_info->proxy_etr_given)
+    write_into_file(outfile, "proxy-etr", args_info->proxy_etr_orig, 0);
+  if (args_info->control_port_given)
+    write_into_file(outfile, "control_port", args_info->control_port_orig, 0);
+  if (args_info->map_request_retries_given)
+    write_into_file(outfile, "map-request-retries", args_info->map_request_retries_orig, 0);
+  
+
+  i = EXIT_SUCCESS;
+  return i;
+}
+
+int
+cmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)
+{
+  FILE *outfile;
+  int i = 0;
+
+  outfile = fopen(filename, "w");
+
+  if (!outfile)
+    {
+      fprintf (stderr, "%s: cannot open file for writing: %s\n", CMDLINE_PARSER_PACKAGE, filename);
+      return EXIT_FAILURE;
+    }
+
+  i = cmdline_parser_dump(outfile, args_info);
+  fclose (outfile);
+
+  return i;
+}
+
+void
+cmdline_parser_free (struct gengetopt_args_info *args_info)
+{
+  cmdline_parser_release (args_info);
+}
+
+/** @brief replacement of strdup, which is not standard */
+char *
+gengetopt_strdup (const char *s)
+{
+  char *result = 0;
+  if (!s)
+    return result;
+
+  result = (char*)malloc(strlen(s) + 1);
+  if (result == (char*)0)
+    return (char*)0;
+  strcpy(result, s);
+  return result;
+}
+
+int
+cmdline_parser (int argc, char **argv, struct gengetopt_args_info *args_info)
+{
+  return cmdline_parser2 (argc, argv, args_info, 0, 1, 1);
+}
+
+int
+cmdline_parser_ext (int argc, char **argv, struct gengetopt_args_info *args_info,
+                   struct cmdline_parser_params *params)
+{
+  int result;
+  result = cmdline_parser_internal (argc, argv, args_info, params, 0);
+
+  if (result == EXIT_FAILURE)
+    {
+      cmdline_parser_free (args_info);
+      exit (EXIT_FAILURE);
+    }
+  
+  return result;
+}
+
+int
+cmdline_parser2 (int argc, char **argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)
+{
+  int result;
+  struct cmdline_parser_params params;
+  
+  params.override = override;
+  params.initialize = initialize;
+  params.check_required = check_required;
+  params.check_ambiguity = 0;
+  params.print_errors = 1;
+
+  result = cmdline_parser_internal (argc, argv, args_info, &params, 0);
+
+  if (result == EXIT_FAILURE)
+    {
+      cmdline_parser_free (args_info);
+      exit (EXIT_FAILURE);
+    }
+  
+  return result;
+}
+
+int
+cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
+{
+  FIX_UNUSED (args_info);
+  FIX_UNUSED (prog_name);
+  return EXIT_SUCCESS;
+}
+
+
+static char *package_name = 0;
+
+/**
+ * @brief updates an option
+ * @param field the generic pointer to the field to update
+ * @param orig_field the pointer to the orig field
+ * @param field_given the pointer to the number of occurrence of this option
+ * @param prev_given the pointer to the number of occurrence already seen
+ * @param value the argument for this option (if null no arg was specified)
+ * @param possible_values the possible values for this option (if specified)
+ * @param default_value the default value (in case the option only accepts fixed values)
+ * @param arg_type the type of this option
+ * @param check_ambiguity @see cmdline_parser_params.check_ambiguity
+ * @param override @see cmdline_parser_params.override
+ * @param no_free whether to free a possible previous value
+ * @param multiple_option whether this is a multiple option
+ * @param long_opt the corresponding long option
+ * @param short_opt the corresponding short option (or '-' if none)
+ * @param additional_error possible further error specification
+ */
+static
+int update_arg(void *field, char **orig_field,
+               unsigned int *field_given, unsigned int *prev_given, 
+               char *value, const char *possible_values[],
+               const char *default_value,
+               cmdline_parser_arg_type arg_type,
+               int check_ambiguity, int override,
+               int no_free, int multiple_option,
+               const char *long_opt, char short_opt,
+               const char *additional_error)
+{
+  char *stop_char = 0;
+  const char *val = value;
+  int found;
+  char **string_field;
+  FIX_UNUSED (field);
+
+  stop_char = 0;
+  found = 0;
+
+  if (!multiple_option && prev_given && (*prev_given || (check_ambiguity && *field_given)))
+    {
+      if (short_opt != '-')
+        fprintf (stderr, "%s: `--%s' (`-%c') option given more than once%s\n", 
+               package_name, long_opt, short_opt,
+               (additional_error ? additional_error : ""));
+      else
+        fprintf (stderr, "%s: `--%s' option given more than once%s\n", 
+               package_name, long_opt,
+               (additional_error ? additional_error : ""));
+      return 1; /* failure */
+    }
+
+  FIX_UNUSED (default_value);
+    
+  if (field_given && *field_given && ! override)
+    return 0;
+  if (prev_given)
+    (*prev_given)++;
+  if (field_given)
+    (*field_given)++;
+  if (possible_values)
+    val = possible_values[found];
+
+  switch(arg_type) {
+  case ARG_INT:
+    if (val) *((int *)field) = strtol (val, &stop_char, 0);
+    break;
+  case ARG_STRING:
+    if (val) {
+      string_field = (char **)field;
+      if (!no_free && *string_field)
+        free (*string_field); /* free previous string */
+      *string_field = gengetopt_strdup (val);
+    }
+    break;
+  default:
+    break;
+  };
+
+  /* check numeric conversion */
+  switch(arg_type) {
+  case ARG_INT:
+    if (val && !(stop_char && *stop_char == '\0')) {
+      fprintf(stderr, "%s: invalid numeric value: %s\n", package_name, val);
+      return 1; /* failure */
+    }
+    break;
+  default:
+    ;
+  };
+
+  /* store the original value */
+  switch(arg_type) {
+  case ARG_NO:
+    break;
+  default:
+    if (value && orig_field) {
+      if (no_free) {
+        *orig_field = value;
+      } else {
+        if (*orig_field)
+          free (*orig_field); /* free previous string */
+        *orig_field = gengetopt_strdup (value);
+      }
+    }
+  };
+
+  return 0; /* OK */
+}
+
+
+static int check_modes(
+  int given1[], const char *options1[],
+                       int given2[], const char *options2[])
+{
+  int i = 0, j = 0, errors = 0;
+  
+  while (given1[i] >= 0) {
+    if (given1[i]) {
+      while (given2[j] >= 0) {
+        if (given2[j]) {
+          ++errors;
+          fprintf(stderr, "%s: option %s conflicts with option %s\n",
+                  package_name, options1[i], options2[j]);
+        }
+        ++j;
+      }
+    }
+    ++i;
+  }
+  
+  return errors;
+}
+
+int
+cmdline_parser_internal (
+  int argc, char **argv, struct gengetopt_args_info *args_info,
+                        struct cmdline_parser_params *params, const char *additional_error)
+{
+  int c;	/* Character of the parsed option.  */
+
+  int error = 0;
+  struct gengetopt_args_info local_args_info;
+  
+  int override;
+  int initialize;
+  int check_required;
+  int check_ambiguity;
+  
+  package_name = argv[0];
+  
+  override = params->override;
+  initialize = params->initialize;
+  check_required = params->check_required;
+  check_ambiguity = params->check_ambiguity;
+
+  if (initialize)
+    cmdline_parser_init (args_info);
+
+  cmdline_parser_init (&local_args_info);
+
+  optarg = 0;
+  optind = 0;
+  opterr = params->print_errors;
+  optopt = '?';
+
+  while (1)
+    {
+      int option_index = 0;
+
+      static struct option long_options[] = {
+        { "help",	0, NULL, 'h' },
+        { "version",	0, NULL, 'V' },
+        { "debug",	0, NULL, 'd' },
+        { "nodaemonize",	0, NULL, 'n' },
+        { "config-file",	1, NULL, 'f' },
+        { "map-resolver",	1, NULL, 'm' },
+        { "map-server",	1, NULL, 's' },
+        { "proxy-etr",	1, NULL, 'e' },
+        { "control_port",	1, NULL, 'p' },
+        { "map-request-retries",	1, NULL, 'r' },
+        { 0,  0, 0, 0 }
+      };
+
+      c = getopt_long (argc, argv, "hVdnf:m:s:e:p:r:", long_options, &option_index);
+
+      if (c == -1) break;	/* Exit from `while (1)' loop.  */
+
+      switch (c)
+        {
+        case 'h':	/* Print help and exit.  */
+          cmdline_parser_print_help ();
+          cmdline_parser_free (&local_args_info);
+          exit (EXIT_SUCCESS);
+
+        case 'V':	/* Print version and exit.  */
+          cmdline_parser_print_version ();
+          cmdline_parser_free (&local_args_info);
+          exit (EXIT_SUCCESS);
+
+        case 'd':	/* Debuging output.  */
+          args_info->lispdconfig_mode_counter += 1;
+        
+        
+          if (update_arg( 0 , 
+               0 , &(args_info->debug_given),
+              &(local_args_info.debug_given), optarg, 0, 0, ARG_NO,
+              check_ambiguity, override, 0, 0,
+              "debug", 'd',
+              additional_error))
+            goto failure;
+        
+          break;
+        case 'n':	/* Don't daemonize.  */
+          args_info->lispdconfig_mode_counter += 1;
+        
+        
+          if (update_arg( 0 , 
+               0 , &(args_info->nodaemonize_given),
+              &(local_args_info.nodaemonize_given), optarg, 0, 0, ARG_NO,
+              check_ambiguity, override, 0, 0,
+              "nodaemonize", 'n',
+              additional_error))
+            goto failure;
+        
+          break;
+        case 'f':	/* Alternate config file.  */
+          args_info->lispdconfig_mode_counter += 1;
+        
+        
+          if (update_arg( (void *)&(args_info->config_file_arg), 
+               &(args_info->config_file_orig), &(args_info->config_file_given),
+              &(local_args_info.config_file_given), optarg, 0, 0, ARG_STRING,
+              check_ambiguity, override, 0, 0,
+              "config-file", 'f',
+              additional_error))
+            goto failure;
+        
+          break;
+        case 'm':	/* MR is the IPv{4,6} address or FQDN of the Map Resolver to use.  */
+          args_info->lispdconfig_mode_counter += 1;
+        
+        
+          if (update_arg( (void *)&(args_info->map_resolver_arg), 
+               &(args_info->map_resolver_orig), &(args_info->map_resolver_given),
+              &(local_args_info.map_resolver_given), optarg, 0, 0, ARG_STRING,
+              check_ambiguity, override, 0, 0,
+              "map-resolver", 'm',
+              additional_error))
+            goto failure;
+        
+          break;
+        case 's':	/* MS is the IPv{4,6} address or FQDN of the Map Server to use.  */
+          args_info->lispdconfig_mode_counter += 1;
+        
+        
+          if (update_arg( (void *)&(args_info->map_server_arg), 
+               &(args_info->map_server_orig), &(args_info->map_server_given),
+              &(local_args_info.map_server_given), optarg, 0, 0, ARG_STRING,
+              check_ambiguity, override, 0, 0,
+              "map-server", 's',
+              additional_error))
+            goto failure;
+        
+          break;
+        case 'e':	/* PETR is the IPv{4,6} address or FQDN of the Proxy-ETR to use.  */
+          args_info->lispdconfig_mode_counter += 1;
+        
+        
+          if (update_arg( (void *)&(args_info->proxy_etr_arg), 
+               &(args_info->proxy_etr_orig), &(args_info->proxy_etr_given),
+              &(local_args_info.proxy_etr_given), optarg, 0, 0, ARG_STRING,
+              check_ambiguity, override, 0, 0,
+              "proxy-etr", 'e',
+              additional_error))
+            goto failure;
+        
+          break;
+        case 'p':	/* CP is the LISP control port (default: 4342).  */
+          args_info->lispdconfig_mode_counter += 1;
+        
+        
+          if (update_arg( (void *)&(args_info->control_port_arg), 
+               &(args_info->control_port_orig), &(args_info->control_port_given),
+              &(local_args_info.control_port_given), optarg, 0, 0, ARG_STRING,
+              check_ambiguity, override, 0, 0,
+              "control_port", 'p',
+              additional_error))
+            goto failure;
+        
+          break;
+        case 'r':	/* R is number of map-requests to send.  */
+          args_info->lispdconfig_mode_counter += 1;
+        
+        
+          if (update_arg( (void *)&(args_info->map_request_retries_arg), 
+               &(args_info->map_request_retries_orig), &(args_info->map_request_retries_given),
+              &(local_args_info.map_request_retries_given), optarg, 0, 0, ARG_INT,
+              check_ambiguity, override, 0, 0,
+              "map-request-retries", 'r',
+              additional_error))
+            goto failure;
+        
+          break;
+
+        case 0:	/* Long option with no short option */
+        case '?':	/* Invalid option.  */
+          /* `getopt_long' already printed an error message.  */
+          goto failure;
+
+        default:	/* bug: option not considered.  */
+          fprintf (stderr, "%s: option unknown: %c%s\n", CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : ""));
+          abort ();
+        } /* switch */
+    } /* while */
+
+
+
+
+  cmdline_parser_release (&local_args_info);
+
+  if ( error )
+    return (EXIT_FAILURE);
+
+  return 0;
+
+failure:
+  
+  cmdline_parser_release (&local_args_info);
+  return (EXIT_FAILURE);
+}
Index: package/lisp/src/lispd_map_register.c
===================================================================
--- package/lisp/src/lispd_map_register.c	(revision 0)
+++ package/lisp/src/lispd_map_register.c	(revision 0)
@@ -0,0 +1,464 @@
+/* 
+ * lispd_map_register.c
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Send registration messages for each database mapping to
+ * configured map-servers.
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    David Meyer		<dmm@cisco.com>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+#include "timerfd.h"
+/*#include <sys/timerfd.h>*/
+#include <openssl/hmac.h>
+#include <openssl/evp.h>
+#include "lispd_external.h"
+
+/*
+ *	map_server_register (tree)
+ *
+ */
+
+map_register(tree) 
+    patricia_tree_t *tree;
+{
+
+    lispd_map_server_list_t   *ms;
+    lispd_pkt_map_register_t  *map_register_pkt; 
+    patricia_node_t	      *node;
+    lispd_locator_chain_t     *locator_chain;
+    lispd_locator_chain_elt_t *locator_chain_elt;
+    lispd_db_entry_t	      *db_entry;
+    uint8_t		      *packet;
+    int			       packet_len = 0;
+    int			       retval     = 0;
+
+    if (!map_servers) {
+	syslog(LOG_DAEMON, "No Map Servers conifgured!");
+	return(0);
+    }
+
+    if (!tree)
+	return(0);
+
+    PATRICIA_WALK(tree->head, node) {
+	locator_chain = ((lispd_locator_chain_t *)(node->data));
+        if (locator_chain) {
+	    if ((map_register_pkt =
+		 build_map_register_pkt(locator_chain)) == NULL) {
+		syslog(LOG_DAEMON, "Couldn't build map register packet");
+		return(0);
+	    }
+
+	    /*
+	     *	for each map server, send a register, and if verify
+	     *	send a map-request for our eid prefix
+	     */
+
+	    ms = map_servers;
+
+	    while (ms) {
+		if (!send_map_register(ms,
+				       map_register_pkt,
+				       locator_chain->mrp_len)) {
+		    syslog(LOG_DAEMON,
+			   "Couldn't send map-register for %s",
+			   locator_chain->eid_name);
+		} else if (ms->verify) {
+		    if (!build_and_send_map_request_msg(ms->address,
+						    &(locator_chain->eid_prefix),
+						    locator_chain->eid_prefix_afi,
+						    locator_chain->eid_prefix_length,
+						    1,1,0,0,0,0,LISPD_INITIAL_MRQ_TIMEOUT,1))
+
+
+			syslog(LOG_DAEMON,"map_register:couldn't build/send map_request");
+		}
+		ms = ms->next;
+	    }
+	    free(map_register_pkt);
+	}
+    } PATRICIA_WALK_END;
+    return(1);
+}
+
+
+/*
+ *	build_map_register_pkt
+ *
+ *	Build the map-register
+ *
+ */
+	
+lispd_pkt_map_register_t *build_map_register_pkt (locator_chain)
+    lispd_locator_chain_t *locator_chain;
+{
+
+    lispd_locator_chain_elt_t	       *locator_chain_elt;
+    lispd_db_entry_t		       *db_entry;
+    lispd_pkt_map_register_t	       *mrp; 
+    lispd_pkt_mapping_record_t	       *mr;
+    lispd_pkt_mapping_record_locator_t *loc_ptr;
+    int					mrp_len    = 0;
+    int					loc_len    = 0;
+    int					len        = 0;
+    int					eid_afi    = 0;
+    int				        afi_len    = 0;
+
+    /*
+     *	assume 1 recored with locator_chain->locator_count locators 
+     *
+     *	walk the locator_chain_elt to get the locators
+     *
+     */
+
+    locator_chain_elt = locator_chain->head;	
+    loc_len           = get_locator_length(locator_chain_elt);
+
+    /* get the length of the eid prefix and map to LISP_AFI types*/
+    
+    eid_afi = get_lisp_afi(locator_chain->eid_prefix_afi, &afi_len);
+
+    /* compute space needed for the whole packet */
+
+    mrp_len = sizeof(lispd_pkt_map_register_t)	    +
+	sizeof(lispd_pkt_mapping_record_t)          +	/* XXX 1 record */
+	afi_len                                     +	/* length of the eid prefix */
+	(locator_chain->locator_count               *	/* locator_count mapping records */
+	sizeof(lispd_pkt_mapping_record_locator_t)) +
+	loc_len;					/* sum of the lengths of the 
+                                                         *locator_chain->locator_count 
+							 * locators
+							 */
+
+    if ((mrp = (lispd_pkt_map_register_t *) malloc(mrp_len)) == NULL) {
+	syslog(LOG_DAEMON, "malloc (map-register packet): %s", strerror(errno));
+	return(0);
+    }
+   
+    /*
+     *	make sure this is clean
+     */
+
+    memset(mrp,0,mrp_len);
+    locator_chain->mrp_len = mrp_len;
+
+    /*
+     *	build the packet
+     *
+     *	Fill in mrp->proxy_reply and compute the HMAC in 
+     *	send_map_register()
+     *
+     */
+
+    mrp->lisp_type        = LISP_MAP_REGISTER;
+    mrp->map_notify       = 1;				/* TODO conf item */
+    mrp->nonce            = 0;
+    mrp->record_count     = 1;				/* XXX  > 1 ? */
+    mrp->key_id           = 0;				/* XXX not sure */
+    mrp->auth_data_len    = htons(LISP_SHA1_AUTH_DATA_LEN);
+
+    /* skip over the fixed part,  assume one record (mr) */
+
+    mr                    = (lispd_pkt_mapping_record_t *)
+	                     CO(mrp, sizeof(lispd_pkt_map_register_t));
+    mr->ttl	          = htonl(DEFAULT_MAP_REGISTER_TIMEOUT);
+    mr->locator_count     = locator_chain->locator_count;
+    mr->eid_prefix_length = locator_chain->eid_prefix_length;
+    mr->authoritative     = 0;
+    mr->action            = 0;
+    mr->version_hi        = 0;
+    mr->version_low       = 0;
+    mr->eid_prefix_afi    = htons(eid_afi);
+    /*
+     * skip over the mapping record and put the eid prefix immediately
+     * following...
+     */
+
+    if ((len = copy_addr((void *)
+			 CO(mr,sizeof(lispd_pkt_mapping_record_t)),
+			 &(locator_chain->eid_prefix),
+			 locator_chain->eid_prefix_afi,
+			 0)) == 0) {
+	syslog(LOG_DAEMON, "eid prefix (%s) has an unknown afi (%d)",
+	       locator_chain->eid_name,
+	       locator_chain->eid_prefix_afi);
+	return(0);
+    }
+	
+    /*
+     * skip over the fixed part and eid prefix, and build
+     * the locators  
+     */
+
+    loc_ptr = (lispd_pkt_mapping_record_locator_t *)
+	CO(mr,(sizeof(lispd_pkt_mapping_record_t) + len));
+
+    while (locator_chain_elt) {
+	db_entry             = locator_chain_elt->db_entry;
+	loc_ptr->priority    = db_entry->priority;
+	loc_ptr->weight      = db_entry->weight;
+	loc_ptr->mpriority   = db_entry->mpriority;
+	loc_ptr->mweight     = db_entry->mweight;
+	loc_ptr->reachable   = 1;		/* XXX should be computed */
+	loc_ptr->probed      = 0;		/* XXX */
+        loc_ptr->locator_afi = htons(get_lisp_afi(db_entry->locator_afi, &afi_len));
+
+	/*
+         * skip over the mapping record locator, and copy the locator
+	 * to that address...
+         */
+	 
+        if ((len = copy_addr((void *)
+			     CO(loc_ptr,
+				sizeof(lispd_pkt_mapping_record_locator_t)),
+			     &(db_entry->locator),
+			     db_entry->locator_afi,
+			     0)) == 0) {
+	    syslog(LOG_DAEMON, "locator (%s) has an unknown afi (%d)",
+		   db_entry->locator_name,
+		   db_entry->locator_afi);
+	    return(0);
+	}
+	/*
+	 * get the next locator in the chain and wind
+	 * loc_ptr to the right place 
+         */
+
+	loc_ptr           = (lispd_pkt_mapping_record_locator_t *)
+	    CO(loc_ptr, (sizeof(lispd_pkt_mapping_record_locator_t) + len));
+
+        locator_chain_elt = locator_chain_elt->next;	
+    }
+    return(mrp);
+}
+
+
+/*
+ *	send_map_register
+ *
+ *	Assumes IPv4 transport for map-registers
+ *
+ */
+
+send_map_register(ms, mrp, mrp_len)
+    lispd_map_server_list_t  *ms;
+    lispd_pkt_map_register_t *mrp; 
+    int			     mrp_len;
+{
+
+    lispd_addr_t        *addr;
+    struct sockaddr_in   map_server;
+    int			s;		/*socket */
+    int			nbytes;
+    int			md_len;
+    struct sockaddr_in	me;
+    struct sockaddr_in	from;
+    struct sockaddr_in  ctrl_saddr;
+
+    /*
+     * Fill in proxy_reply and compute the HMAC with SHA-1. Have to 
+     * do this here since we need to know which map-server (since it 
+     * has the proxy_reply bit)
+     *
+     */
+
+    mrp->proxy_reply = ms->proxy_reply;
+    memset(mrp->auth_data,0,LISP_SHA1_AUTH_DATA_LEN);	/* make sure */
+
+    if (!HMAC((const EVP_MD *) EVP_sha1(), 
+	      (const void *) ms->key,
+	      strlen(ms->key),
+	      (uchar *) mrp,
+	      mrp_len,
+	      (uchar *) mrp->auth_data,
+	      &md_len)) {
+	syslog(LOG_DAEMON, "HMAC failed for map-register");
+        free(mrp);
+	return(0);
+    }    
+
+    /* 
+     * ok, now go send it...
+     */
+
+    if ((s = socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP)) < 0) {
+	syslog(LOG_DAEMON, "socket (send_map_register): %s", strerror(errno));
+	return(0);
+    }
+
+#if (DEBUG > 3)
+    syslog(LOG_DAEMON,"vlakafos: dump from lispd_map_register.c");
+    dump_tree(AF_INET,AF4_database);
+    dump_tree(AF_INET6,AF6_database);
+    dump_database(AF4_database,AF_INET);
+    dump_database(AF6_database,AF_INET6);
+    dump_map_servers();
+    dump_map_cache();
+#endif
+
+    /*
+     * PN: Bind the UDP socket to a valid rloc on the ctrl_iface
+     * (assume v4 transport)
+     */
+    if (!(ctrl_iface) || !(ctrl_iface->AF4_locators->head)) {
+
+        /* 
+         * No physical interface available for control messages
+         */
+
+        syslog(LOG_DAEMON, "(send_map_register): Unable to find valid physical interface\n");
+        return (0);
+    }
+    memset((char *) &ctrl_saddr, 0, sizeof(struct sockaddr_in));
+    ctrl_saddr.sin_family       = AF_INET;
+    ctrl_saddr.sin_port         = htons(INADDR_ANY);
+    ctrl_saddr.sin_addr.s_addr  = (ctrl_iface->AF4_locators->head->db_entry->locator).address.ip.s_addr;
+
+    if (bind(s, (struct sockaddr *)&ctrl_saddr, sizeof(struct sockaddr_in)) < 0) {
+        syslog(LOG_DAEMON, "bind (send_map_register): %s", strerror(errno));
+        close(s);
+        return(0);
+    }
+
+    memset((char *) &map_server, 0, sizeof(map_server));
+
+    addr                       = ms->address;
+    map_server.sin_family      = AF_INET;
+    map_server.sin_addr.s_addr = addr->address.address.ip.s_addr;
+    map_server.sin_port        = htons(LISP_CONTROL_PORT);
+
+    if ((nbytes = sendto(s,
+			 (const void *) mrp,
+			 mrp_len,
+			 0,
+			 (struct sockaddr *)&map_server,
+			 sizeof(struct sockaddr))) < 0) {
+	syslog(LOG_DAEMON,"sendto (send_map_register): %s", strerror(errno));
+	close(s);
+	return(0);
+    }
+
+    if (nbytes != mrp_len) {
+	syslog(LOG_DAEMON,
+		"send_map_register: nbytes (%d) != mrp_len (%d)\n",
+		nbytes, mrp_len);
+	close(s);
+	return(0);
+    }
+
+    close(s);
+    return(1);
+}
+
+
+/*
+ *	get_locator_chain_length
+ *
+ *	Compute the sum of the lengths of the locators 
+ *	in the chain so we can allocate a chunk of memory for 
+ *	the packet....
+ */
+
+get_locator_length(locator_chain_elt) 
+    lispd_locator_chain_elt_t	*locator_chain_elt;
+{
+
+    int sum = 0;
+
+    while (locator_chain_elt) {
+	switch(locator_chain_elt->db_entry->locator_afi) {
+	case AF_INET:
+	    sum += sizeof(struct in_addr);
+	    break;
+	case AF_INET6:
+	    sum += sizeof(struct in6_addr);
+	    break;
+	default:
+	    syslog(LOG_DAEMON, "Uknown AFI (%d) for %s",
+		   locator_chain_elt->db_entry->locator_afi,
+		   locator_chain_elt->db_entry->locator_name);
+	}
+	locator_chain_elt = locator_chain_elt->next;
+    }
+    return(sum);
+}
+
+
+void start_periodic_map_register(void)
+{
+    struct itimerspec interval;
+
+    interval.it_interval.tv_sec  = MAP_REGISTER_INTERVAL;
+    interval.it_interval.tv_nsec = 0;
+    interval.it_value.tv_sec     = MAP_REGISTER_INTERVAL;
+    interval.it_value.tv_nsec    = 0;
+
+    //vlakafos
+    /*if (!map_register(AF6_database))
+        syslog(LOG_INFO, "Could not map register AF_INET6 with Map Servers"); */
+
+    if (!map_register(AF4_database))
+        syslog(LOG_INFO, "Could not map register AF_INET with Map Servers");
+
+    syslog(LOG_INFO, "Starting timer to send map register every %d seconds",
+            MAP_REGISTER_INTERVAL);
+
+    if (timerfd_settime(map_register_timer_fd, 0, &interval, NULL) == -1)
+        syslog(LOG_INFO, "timerfd_settime: %s", strerror(errno));
+}
+
+
+void stop_periodic_map_register(void)
+{
+    struct itimerspec interval;
+
+    interval.it_interval.tv_sec  = 0;
+    interval.it_interval.tv_nsec = 0;
+    interval.it_value.tv_sec     = 0;
+    interval.it_value.tv_nsec    = 0;
+
+    syslog(LOG_INFO, "Stopping timer to send map register every %d seconds",
+            MAP_REGISTER_INTERVAL);
+
+    if (timerfd_settime(map_register_timer_fd, 0, &interval, NULL) == -1)
+        syslog(LOG_INFO, "timerfd_settime: %s", strerror(errno));
+}
+
+
+inline void periodic_map_register(void)
+{
+    ssize_t s;
+    uint64_t num_exp;
+
+    if((s = read(map_register_timer_fd, &num_exp, sizeof(num_exp))) != sizeof(num_exp))
+        syslog(LOG_INFO, "read (periodic_map_register): %s", strerror(errno));
+
+    if (!map_register(AF6_database))
+        syslog(LOG_INFO, "Periodic AF_INET6 map register failed");
+
+    if (!map_register(AF4_database))
+        syslog(LOG_INFO, "Periodic AF_INET map register failed");
+}
Index: package/lisp/src/README
===================================================================
--- package/lisp/src/README	(revision 0)
+++ package/lisp/src/README	(revision 0)
@@ -0,0 +1,20 @@
+#
+#	README
+#
+#	Start a README for the lispd
+#
+#
+#	David Meyer
+#	dmm613@gmail.com
+#	Mon May 10 13:09:56 2010
+#
+#	$Header: $
+#
+
+
+
+	I.	Dependencies
+
+		libconfuse-dev (config parser)
+		libssl-dev     (HMAC/crypto stuff)
+		librt          (clock_gettime)
Index: package/lisp/src/lispd_map_request.c
===================================================================
--- package/lisp/src/lispd_map_request.c	(revision 0)
+++ package/lisp/src/lispd_map_request.c	(revision 0)
@@ -0,0 +1,600 @@
+/*
+ * lispd_map_request.c
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Send a map request.
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    David Meyer		<dmm@cisco.com>
+ *    Vina Ermagan		<vermagan@cisco.com>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+/*
+ *	Send this packet on UDP 4342
+ *
+ *
+ * Encapsulated control message header. This is followed by the IP
+ * header of the encapsulated LISP control message.
+ *
+ *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *    |Type=8 |                   Reserved                            |
+ *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *
+ *
+ *	Next is the inner IP header, either struct ip6_hdr or struct
+ *	iphdr. 
+ *
+ *	This is follwed by a UDP header, random source port, 4342 
+ *	dest port.
+ *
+ *	Followed by a struct lisp_pkt_map_request_t:
+ *
+ * Map-Request Message Format
+ *   
+ *       0                   1                   2                   3
+ *       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *      |Type=1 |A|M|P|S|      Reserved       |   IRC   | Record Count  |
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *      |                         Nonce . . .                           |
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *      |                         . . . Nonce                           |
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *      |         Source-EID-AFI        |    Source EID Address  ...    |
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *      |         ITR-RLOC-AFI 1        |    ITR-RLOC Address 1  ...    |
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *      |         ITR-RLOC-AFI n        |    ITR-RLOC Address n  ...    |
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *    / |   Reserved    | EID mask-len  |        EID-prefix-AFI         |
+ *  Rec +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *    \ |                        EID-prefix ...                         |
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *      |                      Mappping Record ...                      |
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *      |                     Mapping Protocol Data                     |
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *
+ *
+ *	<source EID address>
+ *	IRC = 0 --> one source rloc
+ *      lisp_pkt_map_request_eid_prefix_record_t
+ *      EID
+ *
+ */
+
+#include "lispd_external.h"
+
+uint8_t *build_map_request_pkt(eid_prefix, eid_prefix_afi, eid_prefix_length,
+        len, nonce, encap, solicit_map_request, smr_invoked, islocal)
+    lisp_addr_t *eid_prefix;
+    uint16_t eid_prefix_afi;
+    uint8_t eid_prefix_length;
+    int *len; /* return length here */
+    uint64_t                 *nonce;			/* return nonce here */
+    uint8_t encap;
+    uint8_t solicit_map_request; /* boolean really */
+    uint8_t	               islocal;
+
+{
+
+    struct udphdr				*udph;
+    lispd_addr_t				*my_addr;
+    uint8_t					*packet;
+    lispd_pkt_map_request_t			*mrp;
+    lispd_pkt_encapsulated_control_t		*ecm;
+    lispd_pkt_map_request_itr_rloc_t		*itr_rloc;
+    lispd_pkt_map_request_eid_prefix_record_t   *eid;
+    datacache_t				        *dcache_ptr;
+    patricia_node_t				*node;
+    void					*cur_ptr;
+    void					*iphptr;	/* v4 or v6 */
+
+    uint16_t					udpsum               = 0;
+    uint16_t					eid_afi             = 0;
+    int						packet_len          = 0;
+    int						eid_len             = 0;
+    int						ip_len              = 0;
+    int						udp_len             = 0;
+    int						map_request_msg_len = 0;
+    int						ip_header_len       = 0;
+    int						my_addr_len         = 0;
+    int						alen                = 0;
+
+    eid_afi = get_lisp_afi(eid_prefix_afi, &eid_len);
+
+    /* my_addr must have same afi as requested EID */
+    if (!(ctrl_iface) || !(ctrl_iface->AF4_locators->head)) {
+        /* 
+         * No physical interface available for control messages
+         */
+        syslog(LOG_DAEMON, "(build_map_request_pkt): Unable to find valid physical interface\n");
+        return (0);
+    }
+
+    if ((my_addr = get_my_addr(ctrl_iface->iface_name,lisp2inetafi(eid_afi))) == 0) { 
+        syslog(LOG_DAEMON,"can't find suitable source address (%s,%d)",
+               ctrl_iface->iface_name,lisp2inetafi(eid_afi));
+        return(0);
+    }
+
+    if ((my_addr_len = get_addr_len(my_addr->afi)) == 0) {
+	free(my_addr);
+	return (0);
+    }
+
+    if ((ip_header_len = get_ip_header_len(my_addr->afi)) == 0) {
+	free(my_addr);
+	return (0);
+    }
+
+    /* 
+     * caclulate sizes of interest
+     */
+
+    map_request_msg_len = sizeof(lispd_pkt_map_request_t) + /* map request */
+	eid_len                                           + /* source eid */
+	sizeof(lispd_pkt_map_request_itr_rloc_t)          + /* IRC = 1 */
+	my_addr_len                                       + /* ITR RLOC */
+	sizeof(lispd_pkt_map_request_eid_prefix_record_t) + 
+        eid_len;                                            /* EID prefix */
+
+    if (encap) {
+        udp_len = sizeof(struct udphdr) + map_request_msg_len;  /* udp header */
+
+    ip_len     = ip_header_len + udp_len;
+    packet_len = sizeof(lispd_pkt_encapsulated_control_t) + ip_len;
+	} else {
+	packet_len = map_request_msg_len;
+    }
+
+    *len       = packet_len;				    /* return this */
+
+    if ((packet = (uint8_t *) malloc(packet_len)) == NULL) {
+		syslog(LOG_DAEMON, "malloc(packet_len): %s", strerror(errno));
+		return (0);
+    }
+	memset(packet, 0, packet_len);
+
+    /*
+     *	build the encapsulated control message header
+     */
+    if (encap) {
+        ecm       = (lispd_pkt_encapsulated_control_t *) packet;
+        ecm->type = LISP_ENCAP_CONTROL_TYPE;
+
+        /*
+         * point cur_ptr at the start of the IP header
+         */
+	cur_ptr = CO(ecm, sizeof(lispd_pkt_encapsulated_control_t));
+        iphptr = cur_ptr;					/* save for ip checksum */
+
+        /*
+         * build IPvX header
+         */
+
+	if ((udph = build_ip_header(cur_ptr, my_addr, eid_prefix, ip_len)) == 0) {
+		syslog(LOG_DAEMON, "Can't build IP header (unknown AFI %d)",
+	                my_addr->afi);
+	        free(my_addr);
+		return (0);
+        }
+    
+        /*
+         * fill in the UDP header. checksum\ later.
+         *
+         * Note src port == dest port == LISP_CONTROL_PORT (4342)
+         */
+
+#ifdef BSD
+        udph->uh_sport = htons(LISP_CONTROL_PORT);
+        udph->uh_dport = htons(LISP_CONTROL_PORT);
+        udph->uh_ulen  = htons(udp_len);
+        udph->uh_sum   = 0;
+#else
+        udph->source = htons(LISP_CONTROL_PORT);
+        udph->dest   = htons(LISP_CONTROL_PORT);
+        udph->len    = htons(udp_len);
+        udph->check  = 0;
+#endif
+
+    }
+    /*
+     * build the map request
+     */
+
+    /*
+     * first, point mrp at map-request packet
+     * pointer is set based on whether map request is encapsulated or not
+     */
+
+    if (encap)
+        mrp = (lispd_pkt_map_request_t *) CO(udph, sizeof(struct udphdr));
+    else
+        mrp = (lispd_pkt_map_request_t *) packet;
+
+    mrp->type                      = LISP_MAP_REQUEST;
+    mrp->authoritative             = 0;
+    mrp->map_data_present          = 0;
+    mrp->rloc_probe                = 0;
+
+    if (solicit_map_request)
+        mrp->solicit_map_request   = 1;
+    else
+        mrp->solicit_map_request   = 0;
+
+    if (smr_invoked)
+        mrp->smr_invoked           = 1;
+    else
+        mrp->smr_invoked           = 0;
+
+    mrp->additional_itr_rloc_count = 0;		/* 0 --> 1 */
+    mrp->record_count              = 1;		/* XXX: assume 1 record */
+    mrp->nonce = build_nonce((unsigned int) time(NULL));
+    *nonce                         = mrp->nonce;
+    mrp->source_eid_afi = htons(get_lisp_afi(eid_prefix_afi, NULL));
+
+    /*
+     * Source-EID address goes here.
+     *
+     *	point cur_ptr at where the variable length Source-EID 
+     *  address goes, namely, CO(mrp,sizeof(lispd_pkt_map_request_t))
+     */    
+
+    /* TODO
+     * VE:
+     * This should be my_eid instead of the eid_prefix.
+     */
+
+    cur_ptr = CO(mrp, sizeof(lispd_pkt_map_request_t));
+    if ((alen = copy_addr(cur_ptr, eid_prefix, eid_prefix_afi, 0)) == 0) {
+        free(packet);
+        free(dcache_ptr);
+	return (0);
+    }
+
+    /*
+     * now the ITR-RLOC (XXX: assumes only one)
+     */
+
+    itr_rloc = (lispd_pkt_map_request_itr_rloc_t *) CO(cur_ptr, alen);
+    itr_rloc->afi = htons(get_lisp_afi(my_addr->afi, NULL));
+    cur_ptr = CO(itr_rloc, sizeof(lispd_pkt_map_request_itr_rloc_t));
+    if ((alen = copy_addr(cur_ptr, (lisp_addr_t *) &(my_addr->address.address),
+			my_addr->afi, 0)) == 0) {
+	free(packet);
+        free(dcache_ptr);
+	return (0);
+    }
+
+    /* 
+     *	finally, the requested EID prefix
+     */
+
+    eid = (lispd_pkt_map_request_eid_prefix_record_t *) CO(cur_ptr, alen);
+    eid->eid_prefix_mask_length = eid_prefix_length;
+    eid->eid_prefix_afi = htons(get_lisp_afi(eid_prefix_afi, NULL));
+    cur_ptr = CO(eid, sizeof(lispd_pkt_map_request_eid_prefix_record_t));
+    if (copy_addr(cur_ptr,				/* EID */
+	eid_prefix, eid_prefix_afi, 0) == 0) {
+	free(packet);
+        free(dcache_ptr);
+	return (0);
+    }
+    
+    /*
+     * now compute the checksums if encapsulated...
+     */
+
+    if (encap) {
+        if (my_addr->afi == AF_INET)
+	    ((struct ip *) iphptr)->ip_sum = ip_checksum(iphptr, ip_header_len);
+	if ((udpsum = udp_checksum(udph, udp_len, iphptr, my_addr->afi)) == -1) {
+	    return (0);
+        }
+	udpsum( udph) = udpsum;
+    }
+    free(my_addr);
+    return (packet);
+}
+
+/*
+ *	send_map_request
+ *
+ */
+
+send_map_request(packet, packet_len, resolver)
+    uint8_t *packet;
+    int packet_len;
+    lispd_addr_t *resolver; 
+{
+
+    struct sockaddr_in   map_resolver;
+    int			s;		/*socket */
+    int			nbytes = 0;
+    int			md_len = 0;
+    struct sockaddr_in  ctrl_saddr;
+
+    /* XXX: assume v4 transport */
+
+    if ((s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
+	syslog(LOG_DAEMON, "socket (send_map_request): %s", strerror(errno));
+	return (0);
+    }
+
+    /*
+     * PN: Bind the UDP socket to a valid rloc on the ctrl_iface
+     * (assume v4 transport)
+     */
+    if (!(ctrl_iface) || !(ctrl_iface->AF4_locators->head)) {
+        /* 
+         * No physical interface available for control messages
+         */
+        syslog(LOG_DAEMON, "(send_map_request): Unable to find valid physical interface\n");
+        close(s);
+        return (0);
+    }
+    memset((char *) &ctrl_saddr, 0, sizeof(struct sockaddr_in));
+    ctrl_saddr.sin_family       = AF_INET;
+    ctrl_saddr.sin_port         = htons(INADDR_ANY);
+    ctrl_saddr.sin_addr.s_addr  = (ctrl_iface->AF4_locators->head->db_entry->locator).address.ip.s_addr;
+
+    if (bind(s, (struct sockaddr *)&ctrl_saddr, sizeof(struct sockaddr_in)) < 0) {
+        syslog(LOG_DAEMON, "bind (send_map_request): %s", strerror(errno));
+        close(s);
+        return(0);
+    }
+
+    memset((char *) &map_resolver, 0, sizeof(map_resolver));
+
+    map_resolver.sin_family      = AF_INET;	/* XXX: assume v4 transport */
+    map_resolver.sin_addr.s_addr = resolver->address.address.ip.s_addr;
+    map_resolver.sin_port        = htons(LISP_CONTROL_PORT);
+
+    if ((nbytes = sendto(s, 
+                         (const void *) packet, packet_len, 0,
+                         (struct sockaddr *) &map_resolver, sizeof(struct sockaddr))) < 0) {
+	syslog(LOG_DAEMON, "sendto (send_map_request): %s", strerror(errno));
+        close(s);
+	return (0);
+    }
+
+    if (nbytes != packet_len) {
+	syslog(LOG_DAEMON,
+                "send_map_request: nbytes (%d) != packet_len (%d)\n", 
+                nbytes, packet_len);
+        close(s);
+	return (0);
+    }
+
+    close(s);
+    free(packet);
+    return (1);
+}
+
+/*
+ *	build_and_send_map_request --
+ *
+ *	Put a wrapper around build_map_request_pkt and send_map_request
+ *
+ */
+
+build_and_send_map_request_msg(dest, eid_prefix, eid_prefix_afi,
+        eid_prefix_length, eid_name, encap, solicit_map_request,
+        smr_invoked, islocal,retries,timeout,search)
+    lispd_addr_t *dest;
+    lisp_addr_t *eid_prefix;
+    uint16_t eid_prefix_afi;
+    uint8_t eid_prefix_length;
+    char *eid_name;
+    uint8_t encap;                  /* "boolean" */
+    uint8_t solicit_map_request;    /* "boolean" */
+    uint8_t smr_invoked;            /* "boolean" */
+    uint8_t islocal;                /* "boolean" */
+    uint8_t retries;
+    uint16_t timeout;
+    uint8_t search;
+{
+
+    uint8_t *packet;
+    uint64_t nonce;
+    int      len;				/* return the length here */
+	datacache_elt_t *res_elt;
+
+	if (search) {
+		if (search_datacache_entry_eid (eid_prefix_afi,eid_prefix,res_elt)) {
+			// We have already sent a Map-Request towards this destination
+			// We should wait until the ongoing Map-Request expires to re-send
+			// another one
+			return (1);
+		}
+	}
+
+	packet = build_map_request_pkt(eid_prefix, eid_prefix_afi,
+			eid_prefix_length, &len, &nonce, encap, solicit_map_request,
+			smr_invoked, islocal,retries);
+
+
+    if (!packet) {
+		syslog(LOG_DAEMON, "Could not build map-request packet for %s/%d",
+				eid_name, eid_prefix_length);
+		return (0);
+    }
+
+    if (!send_map_request(packet, len, dest)) {
+		syslog(LOG_DAEMON, "Could not send map-request for %s/%d", eid_name,
+	       eid_prefix_length);
+		return (0);
+    }
+
+    /*
+     * Add outstanding nonce to datacache, unless SMR
+     */
+
+    if (!solicit_map_request) {
+        if (!build_datacache_entry(dest,eid_prefix, eid_prefix_afi, eid_prefix_length,
+                    nonce, islocal, solicit_map_request, retries,timeout,encap)) {
+            syslog(LOG_DAEMON, "Couldn't build datacache_entry");
+            return (0);
+        }
+    }
+    return (1);
+}
+
+/*
+ *	process Map_Request Message
+ *	Receive a Map_request message and process based on control bits
+ *
+ *	For first phase just accept (encapsulated) SMR. Proxy bit is set to avoid receiving ecm, and all other types are ignored.
+ *
+ *
+ */
+
+int process_map_request_msg(uint8_t *packet, int s, struct sockaddr *from, int afi) {
+
+    lisp_addr_t *src_eid_prefix;
+    int src_eid_afi;
+    void *cur_ptr;
+    int alen = 0;
+    int afi_len = 0;
+    int ip_header_len = 0;
+    int len = 0;
+    char eid_name[128];
+    lispd_pkt_map_request_t *msg;
+    struct ip *iph;
+    struct ip6_hdr *ip6h;
+    struct udphdr *udph;
+    int encap_afi;
+    uint16_t udpsum = 0;
+    uint16_t ipsum = 0;
+    int udp_len = 0;
+    lisp_addr_t my_rloc;
+    map_reply_opts opts;
+
+    if (((lispd_pkt_encapsulated_control_t *) packet)->type == LISP_ENCAP_CONTROL_TYPE) {
+
+        /*
+         * Read IP header.
+         */
+
+        iph = (struct ip *) CO(packet, sizeof(lispd_pkt_encapsulated_control_t));
+
+        switch (iph->ip_v) {
+        case IPVERSION:
+            ip_header_len = (iph->ip_hl) * 4;
+            udph = (struct udphdr *) CO(iph, ip_header_len);
+            encap_afi = AF_INET;
+            break;
+        case IP6VERSION:
+            ip6h = (struct ip6_hdr *) CO(packet, sizeof(lispd_pkt_encapsulated_control_t));
+            if ((ip_header_len = get_ip_header_len(AF_INET6)) == 0)
+                return(0);
+            udph = (struct udphdr *) CO(ip6h, ip_header_len);
+            encap_afi = AF_INET6;
+            break;
+        default:
+            syslog(LOG_DAEMON, "process_map_request_msg: couldn't read incoming Encapsulated Map-Request: IP header corrupted.");
+            return(0);
+        }
+
+#ifdef BSD
+        udp_len = ntohs(udph->uh_ulen);
+#else
+        udp_len = ntohs(udph->len);
+#endif
+
+        /*
+	 * Verify the checksums.
+	 */
+
+        if (iph->ip_v == IPVERSION) {
+            ipsum = ip_checksum(iph, ip_header_len);
+            if (ipsum != 0) {
+                syslog(LOG_DAEMON, " Map-Request: IP checksum failed.");
+            }
+
+            if ((udpsum = udp_checksum(udph, udp_len, iph, encap_afi)) == -1) {
+                    return(0);
+            }
+
+            if (udpsum != 0) {
+                    syslog(LOG_DAEMON, " Map-Request: UDP checksum failed.");
+                    return(0);
+
+            }
+        }
+
+        /*
+	 * Point cur_ptr at the start of the Map-Request payload.
+	 */
+
+        len = ip_header_len + sizeof(struct udphdr);
+        msg = (lispd_pkt_map_request_t *) CO(iph, len);
+
+    } else if (((lispd_pkt_map_request_t *) packet)->type == LISP_MAP_REQUEST) {
+        msg = (lispd_pkt_map_request_t *) packet;
+    } else
+        return(0); //we should never reach this return()
+
+    /* Source EID is optional in general, but required for SMRs */
+    src_eid_afi = lisp2inetafi(ntohs(msg->source_eid_afi));
+    if (src_eid_afi != 0) {
+        src_eid_prefix = (lisp_addr_t *) CO(msg, sizeof(lispd_pkt_map_request_t));
+        inet_ntop(src_eid_afi, &(src_eid_prefix->address), eid_name, 128);
+        afi_len = (get_addr_len(src_eid_afi)) * 8;
+
+        if (msg->solicit_map_request) {
+            if(!build_and_send_map_request_msg(map_resolvers->address,
+                        src_eid_prefix, src_eid_afi, afi_len, eid_name,
+                        1, 0, 1, 0, 0, LISPD_INITIAL_MRQ_TIMEOUT, 1)) {
+                syslog(LOG_DAEMON, "process_map_request_msg: couldn't build/send SMR triggered Map-Request");
+                return(0);
+            }
+            syslog(LOG_DAEMON, "Sent SMR triggered Map-Request for %s", eid_name);
+        }
+    }
+
+    if (msg->rloc_probe) {
+        if(lispd2lisp(&source_rloc, &my_rloc) < 0) {
+            syslog(LOG_DAEMON, "process_map_request_msg: lispd2lisp failed");
+            return(0);
+        }
+
+        opts.send_rec   = 1;
+        opts.rloc_probe = 1;
+        opts.echo_nonce = 0;
+        if(!build_and_send_map_reply_msg(&my_rloc, from, s, msg->nonce, opts)) {
+            syslog(LOG_DAEMON, "process_map_request_msg: couldn't build/send RLOC-probe reply");
+            return(0);
+        }
+        syslog(LOG_DAEMON, "Sent RLOC-probe reply");
+    }
+
+    /*
+     *  Encapsulated Map-Requests are ignored at this time due to the
+     *  Map-Server proxy-replying for us.
+     *  TODO: For generic ETR functionality this should be implemented
+     */
+    return(1);
+}
Index: package/lisp/src/cmdline.h
===================================================================
--- package/lisp/src/cmdline.h	(revision 0)
+++ package/lisp/src/cmdline.h	(revision 0)
@@ -0,0 +1,200 @@
+/** @file cmdline.h
+ *  @brief The header file for the command line option parser
+ *  generated by GNU Gengetopt version 2.22.4
+ *  http://www.gnu.org/software/gengetopt.
+ *  DO NOT modify this file, since it can be overwritten
+ *  @author GNU Gengetopt by Lorenzo Bettini */
+
+#ifndef CMDLINE_H
+#define CMDLINE_H
+
+/* If we use autoconf.  */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h> /* for FILE */
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#ifndef CMDLINE_PARSER_PACKAGE
+/** @brief the program name (used for printing errors) */
+#define CMDLINE_PARSER_PACKAGE "lispd"
+#endif
+
+#ifndef CMDLINE_PARSER_PACKAGE_NAME
+/** @brief the complete program name (used for help and version) */
+#define CMDLINE_PARSER_PACKAGE_NAME "lispd"
+#endif
+
+#ifndef CMDLINE_PARSER_VERSION
+/** @brief the program version */
+#define CMDLINE_PARSER_VERSION "0.1"
+#endif
+
+/** @brief Where the command line options are stored */
+struct gengetopt_args_info
+{
+  const char *help_help; /**< @brief Print help and exit help description.  */
+  const char *version_help; /**< @brief Print version and exit help description.  */
+  const char *debug_help; /**< @brief Debuging output help description.  */
+  const char *nodaemonize_help; /**< @brief Don't daemonize help description.  */
+  char * config_file_arg;	/**< @brief Alternate config file.  */
+  char * config_file_orig;	/**< @brief Alternate config file original value given at command line.  */
+  const char *config_file_help; /**< @brief Alternate config file help description.  */
+  char * map_resolver_arg;	/**< @brief MR is the IPv{4,6} address or FQDN of the Map Resolver to use.  */
+  char * map_resolver_orig;	/**< @brief MR is the IPv{4,6} address or FQDN of the Map Resolver to use original value given at command line.  */
+  const char *map_resolver_help; /**< @brief MR is the IPv{4,6} address or FQDN of the Map Resolver to use help description.  */
+  char * map_server_arg;	/**< @brief MS is the IPv{4,6} address or FQDN of the Map Server to use.  */
+  char * map_server_orig;	/**< @brief MS is the IPv{4,6} address or FQDN of the Map Server to use original value given at command line.  */
+  const char *map_server_help; /**< @brief MS is the IPv{4,6} address or FQDN of the Map Server to use help description.  */
+  char * proxy_etr_arg;	/**< @brief PETR is the IPv{4,6} address or FQDN of the Proxy-ETR to use.  */
+  char * proxy_etr_orig;	/**< @brief PETR is the IPv{4,6} address or FQDN of the Proxy-ETR to use original value given at command line.  */
+  const char *proxy_etr_help; /**< @brief PETR is the IPv{4,6} address or FQDN of the Proxy-ETR to use help description.  */
+  char * control_port_arg;	/**< @brief CP is the LISP control port (default: 4342).  */
+  char * control_port_orig;	/**< @brief CP is the LISP control port (default: 4342) original value given at command line.  */
+  const char *control_port_help; /**< @brief CP is the LISP control port (default: 4342) help description.  */
+  int map_request_retries_arg;	/**< @brief R is number of map-requests to send.  */
+  char * map_request_retries_orig;	/**< @brief R is number of map-requests to send original value given at command line.  */
+  const char *map_request_retries_help; /**< @brief R is number of map-requests to send help description.  */
+  
+  unsigned int help_given ;	/**< @brief Whether help was given.  */
+  unsigned int version_given ;	/**< @brief Whether version was given.  */
+  unsigned int debug_given ;	/**< @brief Whether debug was given.  */
+  unsigned int nodaemonize_given ;	/**< @brief Whether nodaemonize was given.  */
+  unsigned int config_file_given ;	/**< @brief Whether config-file was given.  */
+  unsigned int map_resolver_given ;	/**< @brief Whether map-resolver was given.  */
+  unsigned int map_server_given ;	/**< @brief Whether map-server was given.  */
+  unsigned int proxy_etr_given ;	/**< @brief Whether proxy-etr was given.  */
+  unsigned int control_port_given ;	/**< @brief Whether control_port was given.  */
+  unsigned int map_request_retries_given ;	/**< @brief Whether map-request-retries was given.  */
+
+  int lispdconfig_mode_counter; /**< @brief Counter for mode lispdconfig */
+} ;
+
+/** @brief The additional parameters to pass to parser functions */
+struct cmdline_parser_params
+{
+  int override; /**< @brief whether to override possibly already present options (default 0) */
+  int initialize; /**< @brief whether to initialize the option structure gengetopt_args_info (default 1) */
+  int check_required; /**< @brief whether to check that all required options were provided (default 1) */
+  int check_ambiguity; /**< @brief whether to check for options already specified in the option structure gengetopt_args_info (default 0) */
+  int print_errors; /**< @brief whether getopt_long should print an error message for a bad option (default 1) */
+} ;
+
+/** @brief the purpose string of the program */
+extern const char *gengetopt_args_info_purpose;
+/** @brief the usage string of the program */
+extern const char *gengetopt_args_info_usage;
+/** @brief all the lines making the help output */
+extern const char *gengetopt_args_info_help[];
+
+/**
+ * The command line parser
+ * @param argc the number of command line options
+ * @param argv the command line options
+ * @param args_info the structure where option information will be stored
+ * @return 0 if everything went fine, NON 0 if an error took place
+ */
+int cmdline_parser (int argc, char **argv,
+  struct gengetopt_args_info *args_info);
+
+/**
+ * The command line parser (version with additional parameters - deprecated)
+ * @param argc the number of command line options
+ * @param argv the command line options
+ * @param args_info the structure where option information will be stored
+ * @param override whether to override possibly already present options
+ * @param initialize whether to initialize the option structure my_args_info
+ * @param check_required whether to check that all required options were provided
+ * @return 0 if everything went fine, NON 0 if an error took place
+ * @deprecated use cmdline_parser_ext() instead
+ */
+int cmdline_parser2 (int argc, char **argv,
+  struct gengetopt_args_info *args_info,
+  int override, int initialize, int check_required);
+
+/**
+ * The command line parser (version with additional parameters)
+ * @param argc the number of command line options
+ * @param argv the command line options
+ * @param args_info the structure where option information will be stored
+ * @param params additional parameters for the parser
+ * @return 0 if everything went fine, NON 0 if an error took place
+ */
+int cmdline_parser_ext (int argc, char **argv,
+  struct gengetopt_args_info *args_info,
+  struct cmdline_parser_params *params);
+
+/**
+ * Save the contents of the option struct into an already open FILE stream.
+ * @param outfile the stream where to dump options
+ * @param args_info the option struct to dump
+ * @return 0 if everything went fine, NON 0 if an error took place
+ */
+int cmdline_parser_dump(FILE *outfile,
+  struct gengetopt_args_info *args_info);
+
+/**
+ * Save the contents of the option struct into a (text) file.
+ * This file can be read by the config file parser (if generated by gengetopt)
+ * @param filename the file where to save
+ * @param args_info the option struct to save
+ * @return 0 if everything went fine, NON 0 if an error took place
+ */
+int cmdline_parser_file_save(const char *filename,
+  struct gengetopt_args_info *args_info);
+
+/**
+ * Print the help
+ */
+void cmdline_parser_print_help(void);
+/**
+ * Print the version
+ */
+void cmdline_parser_print_version(void);
+
+/**
+ * Initializes all the fields a cmdline_parser_params structure 
+ * to their default values
+ * @param params the structure to initialize
+ */
+void cmdline_parser_params_init(struct cmdline_parser_params *params);
+
+/**
+ * Allocates dynamically a cmdline_parser_params structure and initializes
+ * all its fields to their default values
+ * @return the created and initialized cmdline_parser_params structure
+ */
+struct cmdline_parser_params *cmdline_parser_params_create(void);
+
+/**
+ * Initializes the passed gengetopt_args_info structure's fields
+ * (also set default values for options that have a default)
+ * @param args_info the structure to initialize
+ */
+void cmdline_parser_init (struct gengetopt_args_info *args_info);
+/**
+ * Deallocates the string fields of the gengetopt_args_info structure
+ * (but does not deallocate the structure itself)
+ * @param args_info the structure to deallocate
+ */
+void cmdline_parser_free (struct gengetopt_args_info *args_info);
+
+/**
+ * Checks that all the required options were specified
+ * @param args_info the structure to check
+ * @param prog_name the name of the program that will be used to print
+ *   possible errors
+ * @return
+ */
+int cmdline_parser_required (struct gengetopt_args_info *args_info,
+  const char *prog_name);
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* CMDLINE_H */
Index: package/lisp/src/lispd.h
===================================================================
--- package/lisp/src/lispd.h	(revision 0)
+++ package/lisp/src/lispd.h	(revision 0)
@@ -0,0 +1,856 @@
+/*
+ * lispd.h
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Definitions for lispd.
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    David Meyer		<dmm@cisco.com>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+#include <arpa/inet.h>
+#include <ctype.h>
+#include <errno.h>
+#include <ifaddrs.h>
+#include <inttypes.h>
+#include <netdb.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <netinet/in_systm.h>
+#include <netinet/ip6.h>
+#include <netinet/ip.h>
+#include <netinet/udp.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <strings.h>
+#include <sys/ioctl.h>
+#include <syslog.h>
+#include <sys/param.h>
+#include <sys/socket.h>
+#include <time.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <time.h>
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+#include "lisp_ipc.h"
+#include "patricia/patricia.h"
+
+/*
+ *	Protocols constants related with timeouts
+ *
+ */
+
+#define LISPD_INITIAL_MRQ_TIMEOUT	1 // Initial expiration timer for the first MRq
+#define LISPD_INITIAL_SMR_TIMEOUT	1 // Initial expiration timer for the first MRq SMR
+#define LISPD_MAX_MRQ_TIMEOUT		32 // Max expiration timer for the subsequent MRq
+#define LISPD_EXPIRE_TIMEOUT				1 // Time interval in which events are expired
+#define LISPD_MAX_SMR_RETRANSMIT			3 // Maximum amount of SMR MRq transmitted
+
+
+/*
+ *	CO --
+ *
+ *	Calculate Offset
+ *
+ *	Try not to make dumb mistakes with
+ *	pointer arithmetic
+ *
+ */
+
+#define	CO(addr,len) (((char *) addr + len))
+
+
+/*
+ *	SA_LEN --
+ *
+ *	sockaddr length
+ *
+ */
+
+#define SA_LEN(a) ((a == AF_INET) ? sizeof(struct sockaddr_in) : sizeof(struct sockaddr_in6))
+
+/*
+ *	names for where the udp checksum goes
+ */
+
+#ifdef BSD
+#define udpsum(x) x->uh_sum
+#else
+#define udpsum(x) x->check
+#endif
+
+/*
+ *	lispd constants
+ */
+
+#define	EVER			;;
+#define	LISPD			"lispd"
+#define PID_FILE		"/var/run/lispd.pid"
+#define	MAX_IP_PACKET		4096
+
+/*
+ *	misc parameters
+ */
+
+#define	IP6VERSION			6	/* what's the symbol? */
+#define	PACKED				__attribute__ ((__packed__))
+#define	uchar				u_char
+
+#define GOOD				1
+#define BAD				0
+#define	MAX_IP_PACKET			4096
+#define	MIN_EPHEMERAL_PORT		32768
+#define	MAX_EPHEMERAL_PORT		65535
+
+#define	DEFAULT_MAP_REQUEST_RETRIES	3
+#define	DEFAULT_MAP_REGISTER_TIMEOUT	10	/* PN: expected to be in minutes; however, 
+                                                 * lisp_mod treats this as seconds instead of
+                                                 * minutes
+                                                 */
+#define MAP_REGISTER_INTERVAL           60      /* LJ: sets the interval at which periodic
+                                                 * map register messages are sent (seconds).
+                                                 * The spec recommends 1 minute
+                                                 */
+#define DEFAULT_DATA_CACHE_TTL		60	/* seconds */
+#define DEFAULT_SELECT_TIMEOUT		1000	/* ms */
+
+/*
+ * LISP Types
+ */
+
+#define	LISP_MAP_REQUEST		1
+#define	LISP_MAP_REPLY			2
+#define	LISP_MAP_REGISTER		3
+#define	LISP_MAP_NOTIFY 		4
+#define LISP_ENCAP_CONTROL_TYPE		8
+#define	LISP_CONTROL_PORT		4342
+
+/*
+ *	Map Reply action codes
+ */
+
+#define LISP_ACTION_NO_ACTION		0
+#define LISP_ACTION_FORWARD		1
+#define LISP_ACTION_DROP		2
+#define LISP_ACTION_SEND_MAP_REQUEST	3
+
+/*
+ *	#define AF_INET         2
+ *	#define AF_INET6        10
+ *
+ */
+
+#define LISP_AFI_IP			1
+#define LISP_AFI_IPV6			2
+#define	LISP_IP_MASK_LEN		32
+
+/*
+ *	locator_types
+ */
+
+#define	STATIC_LOCATOR			0
+#define	DYNAMIC_LOCATOR			1
+#define	FQDN_LOCATOR			2
+
+/*
+ *	map-cache entry types (how_learned)
+ */
+
+#define	STATIC_MAP_CACHE_ENTRY		0
+#define	DYNAMIC_MAP_CACHE_ENTRY		1
+
+/*
+ *	for map-register auth data...
+ */
+
+#define LISP_SHA1_AUTH_DATA_LEN		20
+
+/*
+ * Netlink mcast groups lispd is interested in
+ * for interface management
+ */
+#define LISPD_IFACE_NLMGRPS     (RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV4_ROUTE) 
+/* #define LISPD_IFACE_NLMGRPS     (RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV6_IFADDR \
+                                                | RTMGRP_IPV4_ROUTE | RTMGRP_IPV6_ROUTE )
+*/
+
+/*
+ * LISP-MN EID interface name(s)
+ */
+#define LISP_MN_EID_IFACE_NAME  "lmn0"
+
+/*
+ * Maximum length (in bytes) of an IP address
+ */
+#define MAX_INET_ADDRSTRLEN INET6_ADDRSTRLEN
+
+/*
+ *	lispd database entry
+ */
+
+typedef struct {
+    lisp_addr_t     eid_prefix;
+    uint16_t        eid_prefix_length;
+    uint16_t        eid_prefix_afi; 
+    lisp_addr_t     locator;
+    uint16_t        locator_afi;
+    uint8_t         locator_type:2;
+    uint8_t	    reserved:6;
+    char *	    locator_name;
+    uint8_t         priority;
+    uint8_t         weight;
+    uint8_t         mpriority;
+    uint8_t         mweight;
+} lispd_db_entry_t;
+
+typedef struct {
+    lisp_addr_t     eid_prefix;
+    uint8_t         eid_prefix_length;
+    uint16_t        eid_prefix_afi;
+    lisp_addr_t     locator;
+    char *	    locator_name;
+    uint16_t        locator_afi;
+    uint8_t         locator_type:2;
+    uint8_t	    reserved:5;
+    uint8_t	    how_learned:1;	/* 1 --> static */
+    uint8_t         priority;
+    uint8_t         weight;
+    uint8_t         mpriority;
+    uint8_t         mweight;
+    uint32_t	    ttl;	
+    uint8_t	    actions;
+} lispd_map_cache_entry_t;
+
+
+/*
+ *	lispd's local database
+ */
+
+typedef struct _lispd_database_t {
+    lispd_db_entry_t		db_entry;
+    struct _lispd_database_t	*next;
+} lispd_database_t;
+
+/*
+ *	map-cache, static or otherwise
+ */
+
+typedef struct _lispd_map_cache_t {
+    lispd_map_cache_entry_t	map_cache_entry;
+    struct _lispd_map_cache_t	*next;
+} lispd_map_cache_t;
+
+/*
+ *	save the afi in the lispd_addr_t
+ */
+
+typedef struct  {
+    lisp_addr_t address;
+    uint16_t    afi;
+} lispd_addr_t;
+
+
+/*
+ *	generic list of addresses
+ */
+
+typedef struct _lispd_addr_list_t {
+    lispd_addr_t	      *address;
+    struct _lispd_addr_list_t *next;
+} lispd_addr_list_t;
+
+
+typedef	struct _lispd_map_server_list_t {
+    lispd_addr_t	            *address;
+    uint8_t		            key_type;
+    char	 	            *key;
+    uint8_t			    proxy_reply;
+    uint8_t			    verify;
+    struct _lispd_map_server_list_t *next;
+} lispd_map_server_list_t;
+
+
+
+/*
+ * Mapping record used in all LISP control messages.
+ *
+ *  +--->  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  |      |                          Record  TTL                          |
+ *  |      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  R      | Locator Count | EID mask-len  | ACT |A|       Reserved        |
+ *  e      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  c      | Rsvd  |  Map-Version Number   |            EID-AFI            |
+ *  o      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  r      |                          EID-prefix                           |
+ *  d      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  |     /|    Priority   |    Weight     |  M Priority   |   M Weight    |
+ *  |    / +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  |  Loc |         Unused Flags    |L|p|R|           Loc-AFI             | 
+ *  |    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  |     \|                             Locator                           |
+ *  +--->  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+
+/*
+ * Fixed portion of the mapping record. EID prefix address and
+ * locators follow.
+ */
+
+typedef struct lispd_pkt_mapping_record_t_ {
+    uint32_t ttl;
+    uint8_t locator_count;
+    uint8_t eid_prefix_length;
+#ifdef __LITTLE_ENDIAN_BITFIELD
+    uint8_t reserved1:4;
+    uint8_t authoritative:1;
+    uint8_t action:3;
+#else
+    uint8_t action:3;
+    uint8_t authoritative:1;
+    uint8_t reserved1:4;
+#endif
+    uint8_t reserved2;
+#ifdef __LITTLE_ENDIAN_BITFIELD
+    uint8_t version_hi:4;
+    uint8_t reserved3:4;
+#else
+    uint8_t reserved3:4;
+    uint8_t version_hi:4;
+#endif
+    uint8_t version_low;
+    uint16_t eid_prefix_afi;
+} PACKED lispd_pkt_mapping_record_t;
+
+
+
+/*
+ * Fixed portion of the mapping record locator. Variable length
+ * locator address follows.
+ */
+typedef struct lispd_pkt_mapping_record_locator_t_ {
+    uint8_t priority;
+    uint8_t weight;
+    uint8_t mpriority;
+    uint8_t mweight;
+    uint8_t unused1;
+#ifdef __LITTLE_ENDIAN_BITFIELD
+    uint8_t reachable:1;
+    uint8_t probed:1;
+    uint8_t local:1;
+    uint8_t unused2:5;
+#else
+    uint8_t unused2:5;
+    uint8_t local:1;
+    uint8_t probed:1;
+    uint8_t reachable:1;
+#endif
+    uint16_t locator_afi;
+} PACKED lispd_pkt_mapping_record_locator_t;
+
+/*
+ * Map-Registers have an authentication header before the UDP header.
+ *
+ *        0                   1                   2                   3
+ *        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ *       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *       |Type=3 |P|            Reserved               |M| Record Count  |
+ *       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *       |                         Nonce . . .                           |
+ *       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *       |                         . . . Nonce                           |
+ *       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *       |            Key ID             |  Authentication Data Length   |
+ *       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *       ~                     Authentication Data                       ~
+ *       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *       |                       Mapping Records ...                     |
+ *       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+
+
+
+/*
+ * Map-Register Message Format
+ *
+ *        0                   1                   2                   3
+ *        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ *       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *       |Type=3 |P|            Reserved               |M| Record Count  |
+ *       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *       |                         Nonce . . .                           |
+ *       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *       |                         . . . Nonce                           |
+ *       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *       |            Key ID             |  Authentication Data Length   |
+ *       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *       ~                     Authentication Data                       ~
+ *   +-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *   |   |                          Record  TTL                          |
+ *   |   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *   R   | Locator Count | EID mask-len  | ACT |A|      Reserved         |
+ *   e   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *   c   | Rsvd  |  Map-Version Number   |        EID-prefix-AFI         |
+ *   o   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *   r   |                          EID-prefix                           |
+ *   d   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *   |  /|    Priority   |    Weight     |  M Priority   |   M Weight    |
+ *   | L +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *   | o |        Unused Flags     |L|p|R|           Loc-AFI             |
+ *   | c +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *   |  \|                             Locator                           |
+ *   +-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+
+typedef struct lispd_pkt_map_register_t_ {
+#ifdef __LITTLE_ENDIAN_BITFIELD
+    uint8_t  reserved1:3;
+    uint8_t  proxy_reply:1;
+    uint8_t  lisp_type:4;
+#else
+    uint8_t  lisp_type:4;
+    uint8_t  proxy_reply:1;
+    uint8_t  reserved1:3;
+#endif
+    uint8_t reserved2;
+#ifdef __LITTLE_ENDIAN_BITFIELD
+    uint8_t map_notify:1;
+    uint8_t reserved3:7;
+#else
+    uint8_t reserved3:7;
+    uint8_t map_notify:1;
+#endif
+    uint8_t  record_count;
+    uint64_t nonce;
+    uint16_t key_id;
+    uint16_t auth_data_len;
+    uint8_t  auth_data[LISP_SHA1_AUTH_DATA_LEN];
+} PACKED lispd_pkt_map_register_t;
+
+
+
+/*
+ *	new lisp database layout
+ *
+ *
+ *  lispd_database {AF4_database,AF6_database}
+ *    |
+ *    | try_search_exact(AFn_database, AF_n, prefix/len);
+ *    |
+ *    v  
+ * patricia_node_t   patricia_node_t ...   patricia_node_t
+ *    |                  |                        |
+ *    |  data            | data                   | data  data contains a 
+ *    |                  |                        |       locator_chain_t
+ *    |                  v                        v       per afi eid/n 
+ *    v             tail                            
+ * locator_chain_t--------------------------------------+   
+ *    |                                                 |
+ *    | head                                            |
+ *    |                                                 |
+ *    v                 next                      next  v
+ *  locator_chain_elt_t ----> locator_chain_elt_t ----> .... 
+ *    | |                     |                         |
+ *    | | locator             |                         |
+ *    | |                     |                         |
+ *    | +--> locator_t        |                         |
+ *    |                       |                         |
+ *    | db_entry              | db_entry                | db_entry
+ *    |                       |                         |
+ *    v                       v                         v
+ *  db_entry_t           db_entry_t                db_entry_t
+ *
+ *
+ *
+ */
+
+typedef struct lispd_locator_chain_elt_t_ {
+    lispd_db_entry_t	            *db_entry;
+    char			    *locator_name;
+    struct lispd_locator_chain_elt_t_ *next;
+} lispd_locator_chain_elt_t;
+
+
+typedef struct {			/* chain per eid-prefix/len/afi */
+    int		mrp_len;		/* map register packet length */
+    uint32_t	timer;			/* send map_register w timer expires */
+    ushort	locator_count;		/* number of mappings, 1 locator/per */
+    lisp_addr_t eid_prefix;		/* eid_prefix for this chain */
+    uint8_t	eid_prefix_length;	/* eid_prefix_length for this chain */
+    uint16_t	eid_prefix_afi;		/* eid_prefix_afi for this chain */
+    char	*eid_name;		/* eid_prefix_afi for this chain */
+    uint8_t	has_dynamic_locators:1;	/* append dynamic/fqdn to front */
+    uint8_t	has_fqdn_locators:1;
+    uint8_t	reserved:6; 
+    lispd_locator_chain_elt_t *head;	/* first entry in chain */
+    lispd_locator_chain_elt_t *tail;	/* last entry in chain */
+} lispd_locator_chain_t;
+
+
+
+/*
+ * Encapsulated control message header. This is followed by the IP
+ * header of the encapsulated LISP control message.
+ *
+ *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *    |Type=8 |                   Reserved                            |
+ *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+typedef struct lispd_pkt_encapsulated_control_t_ {
+#ifdef __LITTLE_ENDIAN_BITFIELD
+    uint8_t reserved1:4;
+    uint8_t type:4;
+#else
+    uint8_t type:4;
+    uint8_t reserved1:4;
+#endif
+    uint8_t reserved2[3];
+} PACKED lispd_pkt_encapsulated_control_t;
+
+/*
+ * Map-Request Message Format
+ *
+ *       0                   1                   2                   3
+ *       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *      |Type=1 |A|M|P|S|p|s|    Reserved     |   IRC   | Record Count  |
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *      |                         Nonce . . .                           |
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *      |                         . . . Nonce                           |
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *      |         Source-EID-AFI        |   Source EID Address  ...     |
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *      |         ITR-RLOC-AFI 1        |    ITR-RLOC Address 1  ...    |
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *      |                              ...                              |
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *      |         ITR-RLOC-AFI n        |    ITR-RLOC Address n  ...    |
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *    / |   Reserved    | EID mask-len  |        EID-prefix-AFI         |
+ *  Rec +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *    \ |                       EID-prefix  ...                         |
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *      |                   Map-Reply Record  ...                       |
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *      |                     Mapping Protocol Data                     |
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+
+/*
+ * Use the nonce to calculate the source port for a map request
+ * message.
+ */
+#define LISP_PKT_MAP_REQUEST_UDP_SPORT(Nonce) (0xf000 | (Nonce & 0xfff))
+
+#define LISP_PKT_MAP_REQUEST_TTL 32
+
+/*
+ * Fixed size portion of the map request. Variable size source EID
+ * address, originating ITR RLOC AFIs and addresses and then map
+ * request records follow.
+ */
+typedef struct lispd_pkt_map_request_t_ {
+#ifdef __LITTLE_ENDIAN_BITFIELD
+    uint8_t solicit_map_request:1;
+    uint8_t rloc_probe:1;
+    uint8_t map_data_present:1;
+    uint8_t authoritative:1;
+    uint8_t type:4;
+#else
+    uint8_t type:4;
+    uint8_t authoritative:1;
+    uint8_t map_data_present:1;
+    uint8_t rloc_probe:1;
+    uint8_t solicit_map_request:1;
+#endif
+#ifdef __LITTLE_ENDIAN_BITFIELD
+    uint8_t reserved1:6;
+    uint8_t smr_invoked:1;
+    uint8_t pitr:1;
+#else
+    uint8_t pitr:1;
+    uint8_t smr_invoked:1;
+    uint8_t reserved1:6;
+#endif
+#ifdef __LITTLE_ENDIAN_BITFIELD
+    uint8_t additional_itr_rloc_count:5;
+    uint8_t reserved2:3;
+#else
+    uint8_t reserved2:3;
+    uint8_t additional_itr_rloc_count:5;
+#endif
+    uint8_t record_count;
+    uint64_t nonce;
+    uint16_t source_eid_afi;
+} PACKED lispd_pkt_map_request_t;
+
+/*
+ * The IRC value above is set to one less than the number of ITR-RLOC
+ * fields (an IRC of zero means one ITR-RLOC). In 5 bits we can encode
+ * the number 15 which means we can have up to 16 ITR-RLOCs.
+ */
+#define LISP_PKT_MAP_REQUEST_MAX_ITR_RLOCS 16
+
+/*
+ * Fixed size portion of map request ITR RLOC.
+ */
+typedef struct lispd_pkt_map_request_itr_rloc_t_ {
+    uint16_t afi;
+    /*    uint8_t address[0]; */
+} PACKED lispd_pkt_map_request_itr_rloc_t;
+
+/*
+ * Fixed size portion of the map request record. Variable size EID
+ * prefix address follows.
+ */
+typedef struct lispd_pkt_map_request_eid_prefix_record_t_ {
+    uint8_t reserved;
+    uint8_t eid_prefix_mask_length;
+    uint16_t eid_prefix_afi;
+} PACKED lispd_pkt_map_request_eid_prefix_record_t;
+
+
+/*
+ * Map-Reply Message Format
+ *
+ *       0                   1                   2                   3
+ *       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *      |Type=2 |P|E|           Reserved                | Record Count  |
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *      |                         Nonce . . .                           |
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *      |                         . . . Nonce                           |
+ *  +-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  |   |                          Record  TTL                          |
+ *  |   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  R   | Locator Count | EID mask-len  | ACT |A|      Reserved         |
+ *  e   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  c   | Rsvd  |  Map-Version Number   |            EID-AFI            |
+ *  o   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  r   |                          EID-prefix                           |
+ *  d   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  |  /|    Priority   |    Weight     |  M Priority   |   M Weight    |
+ *  | L +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  | o |        Unused Flags     |L|p|R|           Loc-AFI             |
+ *  | c +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  |  \|                            Locator                            |
+ *  +-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *      |                     Mapping Protocol Data                     |
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+
+/*
+ * Use the nonce to calculate the source port for a map request
+ * message.
+ */
+
+/*
+ * Fixed size portion of the map reply.
+ * map reply records follow.
+ */
+typedef struct lispd_pkt_map_reply_t_ {
+#ifdef __LITTLE_ENDIAN_BITFIELD
+    uint8_t reserved1:2;
+    uint8_t echo_nonce:1;
+    uint8_t rloc_probe:1;
+    uint8_t type:4;
+#else
+    uint8_t type:4;
+    uint8_t rloc_probe:1;
+    uint8_t echo_nonce:1;
+    uint8_t reserved1:2;
+#endif
+    uint8_t reserved2;
+    uint8_t reserved3;
+    uint8_t record_count;
+    uint64_t nonce;
+} PACKED lispd_pkt_map_reply_t;
+
+
+/*
+ * Fixed size portion of the map reply record. Variable size EID
+ * prefix address follows.
+ */
+
+typedef struct lispd_pkt_map_reply_eid_prefix_record_t_ {
+    uint32_t record_ttl;
+    uint8_t locator_count;
+    uint8_t eid_prefix_mask_length;
+#ifdef __LITTLE_ENDIAN_BITFIELD
+    uint8_t reserved1:4;
+    uint8_t authoritative:1;
+    uint8_t actions:3;
+#else
+    uint8_t actions:3;
+    uint8_t authoritative:1;
+    uint8_t reserved1:4;
+#endif
+    uint8_t reserved2;
+#ifdef __LITTLE_ENDIAN_BITFIELD
+    uint16_t version_number:12;//is this OK?
+    uint16_t reserved3:4;
+#else
+    uint16_t reserved3:4;
+    uint16_t version_number:12;
+#endif
+    uint16_t eid_prefix_afi;
+
+} PACKED lispd_pkt_map_reply_eid_prefix_record_t;
+
+
+/*
+ * Locator portion of map-reply
+ */
+
+typedef struct lispd_pkt_map_reply_locator_t_ {
+    uint8_t priority;
+    uint8_t weight;
+    uint8_t m_priority;
+    uint8_t m_weight;
+    uint8_t unused_flags1;
+#ifdef __LITTLE_ENDIAN_BITFIELD
+    uint8_t reachable:1;
+    uint8_t p:1;
+    uint8_t local:1;
+    uint8_t unused_flags2:5;
+#else
+    uint8_t unused_flags2:5;
+    uint8_t local:1;
+    uint8_t p:1;
+    uint8_t reachable:1;
+#endif
+    uint16_t locator_afi;
+} PACKED lispd_pkt_map_reply_locator_t;
+
+/*
+ *	essentially the data cache
+ */
+
+// Modified by acabello
+typedef struct datacache_elt_t_ {
+    uint64_t	            nonce;
+    lispd_addr_t		dest;
+    uint8_t	            local:1;		/* is this a database entry? */
+    uint8_t	            ttl:7;
+    lisp_addr_t             eid_prefix;
+    uint8_t	            eid_prefix_length;
+    uint16_t	            eid_prefix_afi;	
+    uint8_t					smr:1; /* Is SMR or standard Map-Request? */
+    uint8_t					retries; /* Number of retries (both SMR and standard Map-Request */
+    uint8_t					encap:1;
+    uint16_t				timeout;
+    struct timer_rec_t_		*timer;
+    struct datacache_elt_t_ *next;
+    struct datacache_elt_t_  *prev;
+} datacache_elt_t;
+
+
+/*
+ * Ordered list of timers
+ */
+
+typedef struct timer_rec_t_ {
+	struct timer_rec_t_ *next;
+	struct timer_rec_t_ *prev;
+	time_t timer;
+	datacache_elt_t *elt;
+}timer_rec_t;
+
+typedef struct timer_datacache_t_ {
+	timer_rec_t *head;
+	timer_rec_t *tail;
+	void (*callback)(datacache_elt_t*); // Callback function for expired nonces
+} timer_datacache_t;
+
+typedef struct datacache_t_ {
+    datacache_elt_t *head;
+    datacache_elt_t *tail;
+    timer_datacache_t *timer_datacache;
+} datacache_t;
+
+/*
+ * PN:
+ * Data structures for interface management
+ */
+
+typedef struct _db_entry_list_elt {
+    lispd_db_entry_t *db_entry;
+    struct _db_entry_list_elt *next;
+} db_entry_list_elt;
+
+typedef struct {
+    db_entry_list_elt   *head;
+    db_entry_list_elt   *tail;
+} db_entry_list;
+
+/*
+ * lispd tracks the AF4 and AF6 eid prefixes associated with 
+ * each physical interface.
+ * TODO: 
+ * 1. Currently, lispd assumes single AF4/AF6 eid per iface.
+ * Multiple EIDs are a possibility in the future.
+ * 2. The impact of weight/priority fields (from lispd config file)
+ * on multiple interfaces
+ */
+typedef struct _iface_list_elt {
+    char    *iface_name;        // name of the physical interface
+    char    *AF4_eid_prefix;    // v4 eid associated with the iface
+    char    *AF6_eid_prefix;    // v6 eid associated with the iface
+    db_entry_list *AF4_locators;// list of v4 locators 
+    db_entry_list *AF6_locators;// list of v6 locators
+    int     ready;              // is the iface up and runing?
+    int     weight;             // weight & priority associated with the
+    int     priority;           // iface 
+    lispd_addr_t    gateway;    // gateway IP (v4/v6) for this iface
+    struct _iface_list_elt *next;
+} iface_list_elt;
+
+/* 
+ * Structure to track list of physical ifaces
+ */
+typedef struct {
+    iface_list_elt *head;
+    iface_list_elt *tail;
+} iface_list;
+
+/*
+ * Structure to simplify netlink processing
+ */
+typedef struct nlsock_handle
+{
+    int         fd;       // netlink socket fd
+    uint32_t    seq;      // netlink message seq number
+} nlsock_handle;
+
+/*
+ * Structure to set Map Reply options
+ */
+typedef struct {
+    uint8_t send_rec;       // send a Map Reply record as well
+    uint8_t rloc_probe;     // set RLOC probe bit
+    uint8_t echo_nonce;     // set Echo-nonce bit
+} map_reply_opts;
Index: package/lisp/src/lispd_external.h
===================================================================
--- package/lisp/src/lispd_external.h	(revision 0)
+++ package/lisp/src/lispd_external.h	(revision 0)
@@ -0,0 +1,99 @@
+/*
+ * lispd_external.h
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * External definitions for lispd
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    David Meyer		<dmm@cisco.com>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+
+//vlakafos
+//#define DEBUG 4
+
+#include "lispd.h"
+
+/* from patricia.h */
+
+
+extern	uint64_t build_nonce(int seed);
+extern	struct udphdr *build_ip_header();
+extern	int get_afi(char * str);
+extern	lispd_addr_t *get_my_addr(char *if_name, int afi);
+extern	lispd_addr_t *lispd_get_address(char *host,
+					lispd_addr_t *addr,
+					uint32_t *flags);
+extern  lispd_addr_t *lispd_get_ifaceaddress(char *iface_name,
+                                        lispd_addr_t *addr);
+extern  uint8_t *build_map_request_pkt();
+extern int process_map_reply(uint8_t *packet);
+extern  lispd_pkt_map_register_t *build_map_register_pkt (lispd_locator_chain_t
+							  *locator_chain);
+extern	int install_database_mapping(lispd_db_entry_t *db_entry);
+extern  patricia_node_t * make_and_lookup (patricia_tree_t *tree,
+					   int afi, char *string);
+extern	char *prefix_toa (prefix_t * prefix);
+extern  int setup_netlink_iface();
+extern  int process_netlink_iface();
+extern  int update_iface_list(char *iface_name, 
+                                char *eid_preifx, 
+                                lispd_db_entry_t *db_entry, int ready,
+                                int weight, int priority);
+extern  iface_list_elt *find_active_ctrl_iface ();
+extern  iface_list_elt *search_iface_list(char *iface_name);
+extern  void add_item_to_db_entry_list(db_entry_list *dbl, 
+                                        db_entry_list_elt *elt);
+extern  int del_item_from_db_entry_list(db_entry_list *dbl, 
+                                        lispd_db_entry_t *elt);
+
+
+extern	lispd_database_t  *lispd_database;
+extern	lispd_map_cache_t *lispd_map_cache;
+extern  patricia_tree_t	  *AF4_database;
+extern  patricia_tree_t   *AF6_database;
+extern  datacache_t	  *datacache;
+
+extern	lispd_addr_list_t *map_resolvers;
+extern	lispd_addr_list_t *proxy_etrs;
+extern	lispd_map_server_list_t *map_servers;
+extern	char		    *config_file;
+extern  char                *map_resolver;
+extern  char		    *map_server;
+extern  char		    *proxy_etr;
+extern	char		    msg[];
+extern  int	            map_request_retries;
+extern  int	            control_port;
+extern  int	            debug;
+extern  int	            daemonize;
+
+extern	int		    netlink_fd;
+extern	int		    v6_receive_fd;
+extern  int		    v4_receive_fd;
+extern  int		    map_register_timer_fd;
+extern	struct  sockaddr_nl dst_addr;
+extern	struct  sockaddr_nl src_addr;
+extern  nlsock_handle       nlh;
+extern  iface_list_elt      *ctrl_iface; 
+extern  lispd_addr_t        source_rloc;
Index: package/lisp/src/cksum.c
===================================================================
--- package/lisp/src/cksum.c	(revision 0)
+++ package/lisp/src/cksum.c	(revision 0)
@@ -0,0 +1,160 @@
+/*
+ * cksum.c
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Implementation for UDP checksum.
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    David Meyer		<dmm@cisco.com>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+#include "lispd.h"
+
+uint16_t ip_checksum(buffer, size) 
+    uint16_t *buffer;
+    int      size; 
+{
+    uint32_t cksum = 0;
+    
+    while (size > 1) {
+        cksum += *buffer++;
+        size -= sizeof(uint16_t);
+    }
+
+    if (size) {
+        cksum += *(uint8_t *) buffer;
+    }
+
+    cksum  = (cksum >> 16) + (cksum & 0xffff);
+    cksum += (cksum >> 16);
+    
+    return ((uint16_t)(~cksum));
+}
+
+
+/*    
+ *
+ *	Calculate the IPv4 UDP checksum (calculated with the whole packet).
+ *
+ *	Parameters:
+ *
+ *	buff	-	pointer to the UDP header
+ *	len	-	the UDP packet length.
+ *	src	-	the IP source address (in network format).
+ *	dest	-	the IP destination address (in network format).
+ *
+ *	Returns:        The result of the checksum
+ *
+ */
+
+uint16_t udp_ipv4_checksum (buff,len,src,dest)
+	const void	*buff;
+	unsigned int	len;
+	in_addr_t	src;
+	in_addr_t	dest;
+{
+
+    const uint16_t *buf	   = buff;
+    uint16_t	   *ip_src = (void *)&src;
+    uint16_t	   *ip_dst = (void *)&dest;
+    uint32_t       length  = len;
+    uint32_t	   sum     = 0;
+
+    while (len > 1) {
+	sum += *buf++;
+	if (sum & 0x80000000)
+	    sum = (sum & 0xFFFF) + (sum >> 16);
+	len -= 2;
+    }
+ 
+    /* Add the padding if the packet length is odd */
+
+    if (len & 1)
+	sum += *((uint8_t *)buf);
+ 
+    /* Add the pseudo-header */
+
+    sum += *(ip_src++);
+    sum += *ip_src;
+ 
+    sum += *(ip_dst++);
+    sum += *ip_dst;
+ 
+    sum += htons(IPPROTO_UDP);
+    sum += htons(length);
+ 
+    /* Add the carries */
+
+    while (sum >> 16)
+	sum = (sum & 0xFFFF) + (sum >> 16);
+ 
+    /* Return the one's complement of sum */
+
+    return ((uint16_t)(~sum));
+}
+
+
+/*
+ *	TBD 
+ */
+
+uint16_t udp_ipv6_checksum (buff,len,src,dest)
+	const void	*buff;
+	unsigned int	len;
+	struct in6_addr src;
+	struct in6_addr dest;
+{
+
+    return (0);
+}
+
+/*
+ *	upd_checksum
+ *
+ *	Calculate the IPv4 or IPv6 UDP checksum
+ *
+ */
+
+uint16_t udp_checksum (udph,udp_len,iphdr,afi)
+     struct udphdr *udph;
+     int	   udp_len;
+     void	   *iphdr;
+     int	   afi;
+{
+    switch (afi) {
+    case AF_INET:
+        return(udp_ipv4_checksum(udph,
+				 udp_len,
+				 ((struct ip *)iphdr)->ip_src.s_addr,
+				 ((struct ip *)iphdr)->ip_dst.s_addr));
+    case AF_INET6:
+	return(udp_ipv6_checksum(udph,
+				 udp_len,
+				 ((struct ip6_hdr *)iphdr)->ip6_src.s6_addr,
+				 ((struct ip6_hdr *)iphdr)->ip6_dst.s6_addr));
+    default:
+	syslog(LOG_DAEMON, "udp_checksum: Unknown AFI");
+	return(-1);
+    }
+}
Index: package/lisp/src/lispd_map_reply.c
===================================================================
--- package/lisp/src/lispd_map_reply.c	(revision 0)
+++ package/lisp/src/lispd_map_reply.c	(revision 0)
@@ -0,0 +1,508 @@
+/*
+ * lispd_map_reply.c
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Necessary logic to handle incoming map replies.
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    Kari Okamoto	    <okamotok@stanford.edu>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *    Lorand Jakab      <ljakab@ac.upc.edu>
+ *
+ */
+
+/*
+ * Map-Reply Message Format from lisp draft-ietf-lisp-08
+ *
+ *       0                   1                   2                   3
+ *       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *      |Type=2 |P|E|           Reserved                | Record Count  |
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *      |                         Nonce . . .                           |
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *      |                         . . . Nonce                           |
+ *  +-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  |   |                          Record  TTL                          |
+ *  |   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  R   | Locator Count | EID mask-len  | ACT |A|      Reserved         |
+ *  e   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  c   | Rsvd  |  Map-Version Number   |            EID-AFI            |
+ *  o   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  r   |                          EID-prefix                           |
+ *  d   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  |  /|    Priority   |    Weight     |  M Priority   |   M Weight    |
+ *  | L +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  | o |        Unused Flags     |L|p|R|           Loc-AFI             |
+ *  | c +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  |  \|                            Locator                            |
+ *  +-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *      |                     Mapping Protocol Data                     |
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+
+
+#include "lispd_external.h"
+
+
+process_map_reply(packet)
+    uint8_t *packet;
+
+{
+    lispd_pkt_map_reply_t       			*mrp;
+    lispd_pkt_map_reply_eid_prefix_record_t 		*record;
+    lispd_pkt_map_reply_locator_t			*loc_pkt;
+    lispd_map_cache_entry_t     			*map_cache_entry;
+    datacache_elt_t             			*itr, *prev;
+    datacache_elt_t                         *elt = NULL;
+    lisp_addr_t						*eid;
+    lisp_addr_t						*loc;
+    int                                                 eid_afi;
+    uint64_t                                            nonce;
+    int							i;
+    int                                                 match = 0;
+    int                                                 ret;
+
+    mrp = (lispd_pkt_map_reply_t *)packet;
+    nonce = mrp->nonce;
+
+    /*
+     * Advance ptrs to point to their corresponding locations
+     * within the incoming packet
+     *
+     * VE:
+     * Assumption is Map Reply has only one record
+     */
+
+    record = (lispd_pkt_map_reply_eid_prefix_record_t *)CO(mrp, sizeof(lispd_pkt_map_reply_t));
+    eid = (lisp_addr_t *)CO(record, sizeof(lispd_pkt_map_reply_eid_prefix_record_t));
+    eid_afi = lisp2inetafi(ntohs(record->eid_prefix_afi));
+
+    if(record->locator_count > 0){
+    switch (eid_afi) {
+        case AF_INET: //ipv4: 4B
+            loc_pkt = (lispd_pkt_map_reply_locator_t *)CO(eid, sizeof(struct in_addr));
+            break;
+        case AF_INET6: //ipv6: 16B
+            loc_pkt = (lispd_pkt_map_reply_locator_t *)CO(eid, sizeof(struct in6_addr));
+            break;
+        default:
+            syslog (LOG_DAEMON, "process_map_reply(), unknown AFI");
+            return (0);
+    }
+
+    loc = (lisp_addr_t *)CO(loc_pkt, sizeof(lispd_pkt_map_reply_locator_t));
+    }
+    /*
+     * Check for rloc probing bit?
+     * Can calculate RTT if we want to know
+     */
+
+    /*
+     * Search datacache for the corresponding entry
+     */
+    // Modified by acabello
+    if (!search_datacache_entry_nonce(nonce,&elt)) {
+    syslog(LOG_DAEMON,"Map-Reply: Datacache not found for nonce:\n");
+    lispd_print_nonce(nonce);
+        return 0;
+    }
+    if (!is_eid_included(elt,eid_afi,record->eid_prefix_mask_length,eid)) {
+    syslog(LOG_DAEMON,"Map-Reply: EID does not match for MRp with nonce:\n");
+    lispd_print_nonce(nonce);
+        return 0;
+    }
+    delete_datacache_entry(elt);
+
+    /*
+     * Allocate memory for the new map cache entry, fill it in
+     */
+    if ((map_cache_entry = (lispd_map_cache_entry_t *) malloc(sizeof(lispd_map_cache_entry_t))) == NULL) {
+        syslog(LOG_DAEMON, "process_map_reply(), malloc (map-cache entry): %s", strerror(errno));
+        return(0);
+    }
+
+    memset(map_cache_entry, 0, sizeof(lispd_map_cache_entry_t));
+
+    map_cache_entry->eid_prefix = *eid;
+    map_cache_entry->eid_prefix_length = record->eid_prefix_mask_length;
+    map_cache_entry->eid_prefix_afi = eid_afi;
+    map_cache_entry->locator_type = 2;     /* 2 --> map reply */
+    map_cache_entry->how_learned = DYNAMIC_MAP_CACHE_ENTRY;      
+    map_cache_entry->ttl = ntohl(record->record_ttl);
+    map_cache_entry->actions = record->actions;
+
+
+    /*
+     *  VE:
+     * If there are none -> negative map reply.
+     */
+
+    if((record->locator_count) == 0){
+        /*
+	 * LJ:   We add the first PETR in the list as locator
+         * TODO: We should iterate list, and adjust weights accordingly
+	 */
+        if (proxy_etrs) {
+            map_cache_entry->locator = proxy_etrs->address->address;
+            map_cache_entry->locator_name = "locator_name";
+            map_cache_entry->locator_afi = proxy_etrs->address->afi;
+            map_cache_entry->priority = 1;
+            map_cache_entry->weight = 100;
+            map_cache_entry->mpriority = 255;
+            map_cache_entry->mweight = 100;
+        }
+	ret = install_map_cache_entry(map_cache_entry);
+#ifdef DEBUG
+	syslog (LOG_DAEMON, "Negative  Map cache installed, ret =%d", ret);
+#endif
+	if (ret < 0) {
+		syslog (LOG_DAEMON, "Map cache install failed; ret=%d", ret);
+	}
+#if (DEBUG > 3)
+        dump_map_cache();
+#endif
+    }
+
+ /*
+  * Loop through locators if there is more than one provided.
+  */
+
+    for(i = 0; i < record->locator_count; i++) {
+
+        /*
+         * VE:
+         * Don't we need to use copy_addr for IPv6?
+         */
+        map_cache_entry->locator = *loc;
+
+        /* PN, DM:
+         * "locator_name" is currently used by lispd for debug messages
+         * Not used by data plane.
+         * Probably best to remove this member from map_cache_entry structure?
+         */
+        map_cache_entry->locator_name = "locator_name"; //where is the actual name?
+        map_cache_entry->locator_afi = lisp2inetafi(ntohs(loc_pkt->locator_afi));
+        map_cache_entry->priority = loc_pkt->priority;
+        map_cache_entry->weight = loc_pkt->weight;
+        map_cache_entry->mpriority = loc_pkt->m_priority;
+        map_cache_entry->mweight = loc_pkt->m_weight;
+
+	/*
+	 * Advance the ptrs for the next locator
+	 */
+	if(i+1 < record->locator_count) {
+
+	    if(eid_afi == AF_INET) { //ipv4: 4B
+		loc_pkt = (lispd_pkt_map_reply_locator_t *)CO(loc, sizeof(struct in_addr));
+	    } else if(eid_afi == AF_INET6){ //ipv6: 16B
+		loc_pkt = (lispd_pkt_map_reply_locator_t *)CO(loc, sizeof(struct in6_addr));
+	    } else
+		return(0);
+
+	    loc = (lisp_addr_t *)CO(loc_pkt, sizeof(lispd_pkt_map_reply_locator_t));
+	}
+
+
+        /*
+         * Send the cache entry to the data plane via netlink
+         */
+
+        /* PN, DM:
+         * install_map_cache_entry installs one map cache entry/rloc
+         * per call.
+         * After this code was written, the data plane was modified
+         * to take a bunch of LispMapCacheAdd cmds in a single netlink msg.
+         * Do we want to modify install_map_cache_entry to send down
+         * a bunch of cmds instead of one at a time?
+         */
+        ret = install_map_cache_entry(map_cache_entry);
+
+#ifdef DEBUG
+        syslog (LOG_DAEMON, "Map cache installed, ret =%d", ret);
+#endif
+        if (ret < 0) {
+            syslog (LOG_DAEMON, "Map cache install failed; ret=%d", ret);
+        }
+    }//for locator_count
+
+    free(map_cache_entry);
+    map_cache_entry = NULL;
+    return(0);
+}
+
+
+/*
+ * TODO (LJ): There should be a build_mapping_record() function, shared with
+ *            the Map-Register code, and the appropriate structure in lispd.h
+ *            should be shared as well
+ */
+
+uint8_t *build_map_reply_pkt(lisp_addr_t *src, lisp_addr_t *dst, uint64_t nonce,
+        map_reply_opts opts, lispd_locator_chain_t *locator_chain, int *len) {
+    lispd_addr_t source;
+    uint8_t *packet;
+    int packet_len = 0;
+    int iph_len = 0;
+    struct udphdr *udph;
+    int udpsum = 0;
+    lispd_pkt_map_reply_t *map_reply_msg;
+    int map_reply_msg_len = 0;
+    lispd_pkt_map_reply_eid_prefix_record_t *mr_msg_eid;
+    lispd_pkt_map_reply_locator_t *loc_ptr;
+    lispd_locator_chain_elt_t *locator_chain_elt;
+    lispd_db_entry_t *db_entry;
+    int eid_afi = 0;
+    int afi_len = 0;
+    int loc_len = 0;
+    int cpy_len = 0;
+
+    map_reply_msg_len = sizeof(lispd_pkt_map_reply_t);
+    if ((iph_len = get_ip_header_len(src->afi)) == 0)
+        return(0);
+
+    /* If the options ask for a mapping record, calculate addtional length */
+    if (opts.send_rec)
+        if (locator_chain) {
+            locator_chain_elt = locator_chain->head;
+            loc_len = get_locator_length(locator_chain_elt);
+            eid_afi = get_lisp_afi(locator_chain->eid_prefix_afi, &afi_len);
+
+            map_reply_msg_len += sizeof(lispd_pkt_map_reply_eid_prefix_record_t) +
+                                 afi_len +
+                                 (locator_chain->locator_count *
+                                 sizeof(lispd_pkt_map_reply_locator_t)) +
+                                 loc_len;
+
+        }
+
+    packet_len = iph_len + sizeof(struct udphdr) + map_reply_msg_len;
+
+    if ((packet = malloc(packet_len)) == NULL) {
+        syslog(LOG_DAEMON, "build_and_send_map_reply_msg: malloc(%d) %s",
+                map_reply_msg_len, strerror(errno));
+        return(0);
+    }
+    memset(packet, 0, packet_len);
+
+    lisp2lispd(src, &source);
+    udph = build_ip_header((void *)packet, &source, dst, iph_len);
+
+#ifdef BSD
+    udph->uh_sport = htons(LISP_CONTROL_PORT);
+    udph->uh_dport = htons(LISP_CONTROL_PORT);
+    udph->uh_ulen  = htons(sizeof(struct udphdr) + map_reply_msg_len);
+    udph->uh_sum   = 0;
+#else
+    udph->source = htons(LISP_CONTROL_PORT);
+    udph->dest   = htons(LISP_CONTROL_PORT);
+    udph->len    = htons(sizeof(struct udphdr) + map_reply_msg_len);
+    udph->check  = 0;
+#endif
+
+    map_reply_msg = (lispd_pkt_map_reply_t *) CO(udph, sizeof(struct udphdr));
+
+    map_reply_msg->type = 2;
+    if (opts.rloc_probe)
+        map_reply_msg->rloc_probe = 1;
+    if (opts.echo_nonce)
+        map_reply_msg->echo_nonce = 1;
+    map_reply_msg->nonce = nonce;
+
+    if (opts.send_rec) {
+        /*
+         * Optionally, we send a Map Reply record. For RLOC Probing,
+         * the language in the spec is SHOULD
+         */
+        map_reply_msg->record_count = 1;
+        mr_msg_eid = (lispd_pkt_map_reply_eid_prefix_record_t *)
+                     CO(map_reply_msg, sizeof(lispd_pkt_map_reply_t));
+        mr_msg_eid->record_ttl             = htonl(DEFAULT_MAP_REGISTER_TIMEOUT);
+        mr_msg_eid->locator_count          = locator_chain->locator_count;
+        mr_msg_eid->eid_prefix_mask_length = locator_chain->eid_prefix_length;
+        mr_msg_eid->actions                = 0;
+        mr_msg_eid->authoritative          = 1;
+        mr_msg_eid->version_number         = 0;
+        mr_msg_eid->eid_prefix_afi         = htons(eid_afi);
+
+        if ((cpy_len = copy_addr((void *) CO(mr_msg_eid,
+                sizeof(lispd_pkt_map_reply_eid_prefix_record_t)),
+                &(locator_chain->eid_prefix), locator_chain->eid_prefix_afi, 0)) == 0) {
+            syslog(LOG_DAEMON, "build_map_reply_pkt: copy_addr failed");
+        }
+
+        loc_ptr = (lispd_pkt_map_reply_locator_t *) CO(mr_msg_eid,
+             sizeof(lispd_pkt_map_reply_eid_prefix_record_t) + cpy_len);
+
+        while (locator_chain_elt) {
+            db_entry             = locator_chain_elt->db_entry;
+            loc_ptr->priority    = db_entry->priority;
+            loc_ptr->weight      = db_entry->weight;
+            loc_ptr->m_priority  = db_entry->mpriority;
+            loc_ptr->m_weight    = db_entry->mweight;
+            loc_ptr->local       = 1;
+            if (opts.rloc_probe)
+                loc_ptr->p       = 1;       /* XXX probed locator, should check addresses */
+            loc_ptr->reachable   = 1;       /* XXX should be computed */
+            loc_ptr->locator_afi = htons(get_lisp_afi(db_entry->locator_afi, &afi_len));
+
+            if ((cpy_len = copy_addr((void *) CO(loc_ptr,
+                    sizeof(lispd_pkt_map_reply_locator_t)), &(db_entry->locator),
+                    db_entry->locator_afi, 0)) == 0) {
+                syslog(LOG_DAEMON, "build_map_reply_pkt: copy_addr failed for locator %s",
+                        db_entry->locator_name);
+                return(0);
+            }
+
+            loc_ptr = (lispd_pkt_map_reply_locator_t *)
+                CO(loc_ptr, (sizeof(lispd_pkt_map_reply_locator_t) + cpy_len));
+            locator_chain_elt = locator_chain_elt->next;
+        }
+    }
+
+    /* Compute checksums */
+    if (src->afi == AF_INET)
+        ((struct ip *) packet)->ip_sum = ip_checksum(packet, iph_len);
+    if ((udpsum = udp_checksum(udph, packet_len - iph_len, packet, src->afi)) == -1) {
+        return (0);
+    }
+    udpsum(udph) = udpsum;
+    *len = packet_len;
+    return(packet);
+}
+
+int send_map_reply(struct sockaddr *dst, uint8_t *packet, int packet_len) {
+    struct ifreq ifr;
+    int s, nbytes, one = 1;
+
+    if ((s = socket(dst->sa_family, SOCK_RAW, IPPROTO_UDP)) < 0) {
+        syslog(LOG_DAEMON, "send_map_reply: socket: %s", strerror(errno));
+        return(0);
+    }
+
+    /*
+     * By default, raw sockets create the IP header automatically, with operating
+     * system defaults and the protocol number specified in the socket() function
+     * call. If IP header values need to be customized, the socket option
+     * IP_HDRINCL must be set and the header built manually.
+     */
+    if (setsockopt(s, IPPROTO_IP, IP_HDRINCL, &one, sizeof(one)) == -1) {
+        syslog(LOG_DAEMON, "send_map_reply: setsockopt IP_HDRINCL: %s", strerror(errno));
+        close(s);
+        return(0);
+    }
+
+    /* XXX (LJ): Even with source routing set up, the packet leaves on lmn0, unless
+     *           we specificly ask for the output device to be the control interface
+     */
+    memset(&ifr, 0, sizeof(ifr));
+    snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "%s", ctrl_iface->iface_name);
+    if (setsockopt(s, SOL_SOCKET, SO_BINDTODEVICE, (void *)&ifr, sizeof(ifr)) == -1) {
+        syslog(LOG_DAEMON, "send_map_reply: setsockopt SO_BINDTODEVICE: %s", strerror(errno));
+        close(s);
+        return(0);
+    }
+
+    if ((nbytes = sendto(s, (const void *) packet, packet_len, 0,
+                    dst, sizeof(struct sockaddr))) < 0) {
+        syslog(LOG_DAEMON, "send_map_reply: sendto: %s", strerror(errno));
+        close(s);
+        return (0);
+    }
+
+    if (nbytes != packet_len) {
+        syslog(LOG_DAEMON, "send_map_reply: nbytes (%d) != packet_len (%d)\n",
+                nbytes, packet_len);
+        close(s);
+        return (0);
+    }
+
+    close(s);
+    free(packet);
+    return (1);
+}
+
+/*
+ * build_and_send_map_reply_msg()
+ *
+ */
+
+int build_and_send_map_reply_msg(lisp_addr_t *src, struct sockaddr *dst, int s,
+        uint64_t nonce, map_reply_opts opts) {
+    lisp_addr_t destination;
+    patricia_node_t *node;
+    lispd_locator_chain_t *locator_chain = NULL;
+    uint8_t *packet;
+    int len = 0;
+
+    if (sockaddr2lisp(dst, &destination) < 0) {
+        syslog(LOG_DAEMON, "build_and_send_map_reply_msg: sockaddr2lisp failed");
+        return(0);
+    }
+
+    if (opts.send_rec) {
+    /* LJ: For now, IPv4 EIDs only. TODO IPv6 */
+        PATRICIA_WALK(AF4_database->head, node) {
+            locator_chain = ((lispd_locator_chain_t *)(node->data));
+        } PATRICIA_WALK_END;
+    }
+
+    packet = build_map_reply_pkt(src, &destination, nonce, opts, locator_chain, &len);
+
+    /* Send the packet over a raw socket */
+    if (!send_map_reply(dst, packet, len)) {
+        syslog(LOG_DAEMON, "Could not send Map-Reply!");
+        free(packet);
+        return (0);
+    }
+
+    /* LJ: The code below is for the case when we reuse the receiving socket.
+     *     However, since it is bound to INADDR_ANY, it selects source
+     *     address based on exit interface, and because of that it will
+     *     use our EID on lmn0. Because we want source port 4342, and it is
+     *     already bound, we need to use raw sockets in send_map_reply()
+     */
+/*
+    if ((nbytes = sendto(s, (const void *) packet, map_reply_msg_len, 0,
+                    dst, sizeof(struct sockaddr))) < 0) {
+        syslog(LOG_DAEMON, "send_map_reply: sendto: %s", strerror(errno));
+        free(packet);
+        return (0);
+    }
+
+    if (nbytes != map_reply_msg_len) {
+        syslog(LOG_DAEMON, "build_and_send_map_reply_msg: nbytes (%d) != map_reply_msg_len (%d)\n",
+                nbytes, map_reply_msg_len);
+        return (0);
+    }
+    free(packet);
+*/
+
+    return(1);
+}
+
+/*
+ * Editor modelines
+ *
+ * vi: set shiftwidth=4 tabstop=4 expandtab:
+ * :indentSize=4:tabSize=4:noTabs=true:
+ */
Index: package/lisp/src/lispd_iface_mgmt.c
===================================================================
--- package/lisp/src/lispd_iface_mgmt.c	(revision 0)
+++ package/lisp/src/lispd_iface_mgmt.c	(revision 0)
@@ -0,0 +1,1481 @@
+/*
+ * lispd_iface_mgmt.c
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Netlink support and related routines for interface management.
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *	  Preethi Natarajan <prenatar@cisco.com>
+ *    Vijay Subramanian <vijaynsu@cisco.com> 
+ *    Pere Monclus		<pmonclus@cisco.com> 
+ *
+ *
+ */
+
+#include "lispd_external.h"
+
+#define BUF_SIZE                    512
+#define RT_TABLE_LISP_MN            5
+#define LISP_MN_EID_IFACE_MTU       1300
+#define LISP_MN_IP_RULE_PRIORITY    1
+
+typedef struct _reqaddr_t {
+    struct nlmsghdr n;
+    struct ifaddrmsg r;
+    char buf [BUF_SIZE];
+} reqaddr_t;
+
+typedef     struct _reqinfo_t {
+    struct nlmsghdr     n;
+    struct ifinfomsg    r;
+    char            buf[BUF_SIZE];
+} reqinfo_t;
+
+typedef struct _reqmsg_t {
+    struct nlmsghdr     n;
+    struct rtmsg        r;
+    char            buf[BUF_SIZE];
+} reqmsg_t;
+
+/*
+ * This function sends a netlink message
+ * to the kernel 
+ */
+static int nlsock_talk(n)
+        struct nlmsghdr *n;
+{
+    int status;
+    struct sockaddr_nl nladdr;
+
+    /* 
+     * Set the netlink socket addr details so that the message
+     * is received by the kernel
+     */
+    memset(&nladdr, 0, sizeof(nladdr));
+    nladdr.nl_family = AF_NETLINK;
+    nladdr.nl_pad = 0;
+    nladdr.nl_pid = 0;      // destination == kernel
+    nladdr.nl_groups = 0;
+
+    /*
+     * Package the netlink msg inside an iovec
+     */
+    struct iovec iov = {
+        (void *)n,      // actual vector to be txd 
+        n->nlmsg_len    // length of vector
+    };
+
+    struct msghdr msg = {
+            (void *)&nladdr,        // destination
+            sizeof(nladdr),         // destination length
+            &iov,                   // Vector data 
+            1,                      // Vector data len
+            NULL,                   // Ancillary data 
+            0,                      // Ancillary data len
+            0                       // falgs
+    };
+
+    if(sendmsg(nlh.fd, &msg, 0) < 0) {
+        syslog (LOG_DAEMON, "sendmsg (nlsock_talk()) failed: %s\n",
+                strerror(errno));
+        return 0;
+    }
+
+    return 1;
+}
+
+#define NLMSG_TAIL(nmsg) \
+        ((struct rtattr *)(((void * )(nmsg)) + NLMSG_ALIGN((nmsg)->nlmsg_len)))
+
+/* 
+ * This function populates the tail of a netlink msg
+ * with new rtattr struct
+ */
+static int addattr_l(n, maxlen, type, data, alen)
+        struct nlmsghdr *n;     // the netlink msg header
+        int maxlen;             // max length of the netlink msg
+        int type;               // RTA attr type of the data
+        void *data;             // data to add
+        int alen;               // data length
+{
+
+    int len = RTA_LENGTH(alen);
+    struct rtattr *rta;
+
+    if (NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len) > maxlen) {
+        syslog(LOG_DAEMON, "Align issue (addattr_l): netlink msg buf too small for data\n");
+        return 0;
+    }
+                
+    rta = NLMSG_TAIL(n);
+    rta->rta_type = type;
+    rta->rta_len = len;
+
+    memcpy(RTA_DATA(rta), data, alen);
+    n->nlmsg_len = NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len);
+    return 1;
+
+}
+
+/* 
+ * This function deletes a specific route
+ */
+static int route_del(src, src_plen, 
+        dst, dst_plen, 
+        gateway, device_id, table)
+    lispd_addr_t *src;
+    int src_plen;
+    lispd_addr_t *dst;
+    int dst_plen;
+    lispd_addr_t *gateway;
+    int device_id; 
+    int table;
+{
+
+    return (route_mod(RTM_DELROUTE, 
+                src, src_plen,
+                dst, dst_plen,
+                gateway, device_id, table));
+
+}
+
+/* 
+ * This function adds a specific route
+ */
+int route_add(src, src_plen, 
+        dst, dst_plen, 
+        gateway, device_id, table)
+    lispd_addr_t *src;
+    int src_plen;
+    lispd_addr_t *dst;
+    int dst_plen;
+    lispd_addr_t *gateway;
+    int device_id; 
+    int table;
+{
+
+    return (route_mod(RTM_NEWROUTE, 
+                src, src_plen,
+                dst, dst_plen,
+                gateway, device_id, table));
+
+}
+
+/* 
+ * This function modifies (add/del) a route via
+ * netlink
+ */
+int route_mod(cmd, src, src_plen, dst, dst_plen, 
+        gateway, device_id, table)
+    int cmd;                    // add or del
+    lispd_addr_t *src;          // src address 
+    int src_plen;               // src addr prefix length
+    lispd_addr_t *dst;          // dst address
+    int dst_plen;               // dst addr prefix length
+    lispd_addr_t *gateway;      // gateway addr
+    int device_id;              // outgoing iface id
+    int table;                  // routing table number
+{
+
+        reqmsg_t       req;
+        int attr_size =0;
+        memset(&req, 0, sizeof(req));
+
+        /*
+         * Fill up the netlink msg with appropriate flags and data
+         */
+        req.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct rtmsg));
+        req.n.nlmsg_type = cmd;
+        req.n.nlmsg_flags = NLM_F_REQUEST;
+
+        if (cmd == RTM_NEWROUTE) {
+            req.n.nlmsg_flags |= NLM_F_CREATE | NLM_F_EXCL;
+        }
+
+        req.n.nlmsg_seq = ++nlh.seq;
+        req.n.nlmsg_pid = getpid();
+
+        if (gateway) {
+            req.r.rtm_family =  gateway->afi;
+        }
+
+        req.r.rtm_table = table;
+        req.r.rtm_protocol = RTPROT_BOOT;
+        req.r.rtm_scope = RT_SCOPE_UNIVERSE;
+        req.r.rtm_type = RTN_UNICAST;
+        req.r.rtm_src_len = src_plen;
+        req.r.rtm_dst_len = dst_plen;
+
+        if(device_id)
+                addattr_l(&req.n, sizeof(req), RTA_OIF, &device_id, 
+                        sizeof(int));
+        if(src) {
+            attr_size = ((src->afi == AF_INET6) ? 
+                sizeof(struct in6_addr) : sizeof(struct in_addr));
+            addattr_l(&req.n, sizeof(req), RTA_DST, 
+                        &(src->address), attr_size); 
+        }
+        if(dst) {
+            attr_size = ((dst->afi == AF_INET6) ? 
+                sizeof(struct in6_addr) : sizeof(struct in_addr));
+            addattr_l(&req.n, sizeof(req), RTA_DST, 
+                        &(dst->address), attr_size); 
+        }
+        if(gateway) {
+            attr_size = ((gateway->afi == AF_INET6) ? 
+                sizeof(struct in6_addr) : sizeof(struct in_addr));
+            addattr_l(&req.n, sizeof(req), RTA_GATEWAY, 
+                        &(gateway->address), attr_size);
+        }
+
+        /* 
+         * Send netlink msg to kernel
+         */
+        if (!nlsock_talk(&req.n, 0, 0, NULL)) {
+            syslog (LOG_DAEMON, "nlsock_talk (route_mod()) failed\n");
+            return (0);
+        }
+
+        return 1;
+}
+
+/*
+ * This function parses netlink error messages
+ */
+static void parse_nl_error(nlHdr)
+        struct nlmsghdr *nlHdr;
+{
+    struct nlmsgerr *nlErr;
+
+    nlErr = (struct nlmsgerr *)NLMSG_DATA(nlHdr);
+    syslog(LOG_DAEMON, "parse_nl_error: code: %d\n", 
+            nlErr->error);
+}
+
+/*
+ * This function parses and gathers information from
+ * netlink route messages
+ */
+static iface_list_elt *parse_nl_route (nlHdr, gateway)
+        struct nlmsghdr * nlHdr;
+        lispd_addr_t    * gateway;
+{
+
+    struct rtmsg *rt;
+    struct rtattr *rtAttr;
+    int rtLen;
+    char tempBuf[BUF_SIZE];
+    iface_list_elt  *iface_elt = NULL;
+
+    switch (nlHdr->nlmsg_type) {
+        case RTM_NEWROUTE:
+            sprintf(tempBuf, "Parsing RTM_NEWROUTE Message:\n");
+            break;
+        case RTM_DELROUTE:
+            sprintf(tempBuf, "Parsing RTM_DELROUTE Message:\n");
+            break;
+        default:
+            syslog(LOG_DAEMON,"parse_nl_route(): Unknown message type\n");
+            return (NULL);
+    }
+
+    rt = (struct rtmsg *)NLMSG_DATA(nlHdr);
+    if ((rt->rtm_family != AF_INET) && (rt->rtm_family != AF_INET6)) {
+        syslog(LOG_DAEMON, "parse_nl_route: Unknown adddress family\n");
+        return NULL;
+    }
+
+    if (rt->rtm_table != RT_TABLE_MAIN) {
+
+        /* not interested in routes/gateways affecting
+         * tables other the main routing table
+         */
+        return NULL;
+    }
+    syslog(LOG_DAEMON,"%s", tempBuf);
+
+    rtAttr = (struct rtattr *)RTM_RTA(rt);
+    rtLen = RTM_PAYLOAD(nlHdr);
+    for (; RTA_OK(rtAttr, rtLen); rtAttr = RTA_NEXT(rtAttr, rtLen)) {
+        switch (rtAttr->rta_type) {
+            case RTA_OIF:
+                if_indextoname(*(int *)RTA_DATA(rtAttr), tempBuf);
+                syslog(LOG_DAEMON, "Output interface: %s\n", tempBuf);
+                iface_elt = search_iface_list(tempBuf); 
+                break;
+            case RTA_GATEWAY:
+                inet_ntop(rt->rtm_family, RTA_DATA(rtAttr), tempBuf,
+                        sizeof(tempBuf));
+                syslog(LOG_DAEMON, "Gateway Address: %s\n", tempBuf);
+                gateway->afi = rt->rtm_family;
+                switch (gateway->afi) {
+                    case AF_INET:
+                        memcpy(&(gateway->address.address), 
+                            (struct in_addr *)RTA_DATA(rtAttr),
+                            sizeof(struct in_addr));
+                        break;
+                    case AF_INET6:
+                        memcpy(&(gateway->address.address),
+                            (struct in6_addr *)RTA_DATA(rtAttr),
+                            sizeof(struct in6_addr));
+                        break;
+                }
+                break;
+            case RTA_DST:
+                inet_ntop(rt->rtm_family, RTA_DATA(rtAttr), tempBuf,
+                        sizeof(tempBuf));
+                syslog(LOG_DAEMON, "Destination Address: %s\n", tempBuf);
+                break;
+        }
+
+    }
+
+    return (iface_elt);
+
+}
+
+/* 
+ * This function parses and gathers information from 
+ * netlink address messages
+ */
+static iface_list_elt *parse_nl_addr(nlHdr, addr)
+        struct nlmsghdr * nlHdr;
+        lispd_addr_t    *addr;
+
+{
+    struct ifaddrmsg  *ifaddr;
+    struct rtattr *rtAttr;
+    int rtLen;
+    char tempBuf[BUF_SIZE];
+    iface_list_elt  *iface_elt =   NULL;
+        
+    switch (nlHdr->nlmsg_type) {
+        case RTM_NEWADDR:
+            sprintf(tempBuf, "Parsing RTM_NEWADDR Message:\n");
+            break;
+        case RTM_DELADDR:
+            sprintf(tempBuf, "Parsing RTM_DELADDR Message:\n");
+            break;
+        default:
+            syslog(LOG_DAEMON, "parse_nl_addr(): Unknown Message Type\n\n");
+            return NULL;
+            break;
+    }
+
+    ifaddr = (struct ifaddrmsg *)NLMSG_DATA(nlHdr);
+    if ((ifaddr->ifa_family != AF_INET) &&
+        (ifaddr->ifa_family != AF_INET6)) {
+        syslog(LOG_DAEMON, "parse_nl_addr(): Unknown address family\n");
+        return NULL;
+    }
+    syslog(LOG_DAEMON, "%s", tempBuf);
+
+    addr->afi = ifaddr->ifa_family;
+
+    rtAttr = (struct rtattr *)IFA_RTA(ifaddr);
+    rtLen = IFA_PAYLOAD(nlHdr);
+    for (; RTA_OK(rtAttr, rtLen); rtAttr = RTA_NEXT(rtAttr, rtLen)) {
+        switch (rtAttr->rta_type) {
+            case IFA_LOCAL:
+                inet_ntop(addr->afi, RTA_DATA(rtAttr), tempBuf,
+                    sizeof(tempBuf));
+                syslog(LOG_DAEMON, "Local address: %s\n", tempBuf);
+                break;
+            case IFA_BROADCAST:
+                inet_ntop(addr->afi, RTA_DATA(rtAttr), tempBuf,
+                    sizeof(tempBuf));
+                syslog(LOG_DAEMON, "Broadcast address: %s\n", tempBuf);
+                break;
+            case IFA_ANYCAST:
+                inet_ntop(addr->afi, RTA_DATA(rtAttr), tempBuf,
+                    sizeof(tempBuf));
+                syslog(LOG_DAEMON, "Anycast address: %s\n", tempBuf);
+                break;
+            case IFA_ADDRESS:
+                inet_ntop(addr->afi, RTA_DATA(rtAttr), tempBuf,
+                    sizeof(tempBuf));
+                syslog(LOG_DAEMON, "Interface address: %s\n", tempBuf);
+                switch (addr->afi) {
+                    case AF_INET:
+                        memcpy(&(addr->address.address), 
+                            (struct in_addr *)RTA_DATA(rtAttr),
+                            sizeof(struct in_addr));
+                        break;
+                    case AF_INET6:
+                        memcpy(&(addr->address.address),
+                            (struct in6_addr *)RTA_DATA(rtAttr),
+                            sizeof(struct in6_addr));
+                        break;
+                }
+                break;
+            case IFA_LABEL:
+                syslog(LOG_DAEMON, "Interface name: %s\n",
+                        (unsigned char *)RTA_DATA(rtAttr));
+                iface_elt = search_iface_list( 
+                        (unsigned char *)RTA_DATA(rtAttr));
+                break;
+        }
+    }
+    return iface_elt;
+}
+
+/*
+ * This function modifies kernel's list of ip rules
+ */
+static int rule_mod (if_index, cmd, 
+        table, priority, type, 
+        src, src_plen, dst, dst_plen, flags)
+        int if_index;       // interface index
+        int cmd;            // add or del the rule?
+        uint8_t table;      // rule for which routing table?
+        uint32_t priority;  // rule priority
+        uint8_t type;       // type of route 
+        lispd_addr_t *src;  // src addr to match
+        int src_plen;       // src addr prefix length
+        lispd_addr_t *dst;  // dst addr to match
+        int dst_plen;       // dst addr prefix length
+        int flags;          // flags, if any
+{
+    uint8_t buf[BUF_SIZE];
+    struct nlmsghdr *n;
+    struct rtmsg *rtm;
+    int attr_size;
+
+    memset(buf, 0, sizeof(buf));
+    n = (struct nlmsghdr *)buf;
+
+    /*
+     * Fill up the netlink message flags and attributes
+     */
+    n->nlmsg_len = NLMSG_LENGTH(sizeof(struct rtmsg));
+    n->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
+
+    if (cmd == RTM_NEWRULE) {
+        n->nlmsg_flags |= NLM_F_CREATE;
+    }
+
+    n->nlmsg_type = cmd;
+    n->nlmsg_seq = ++nlh.seq;
+    n->nlmsg_pid = getpid();
+
+    rtm = NLMSG_DATA(n);
+    if (src) rtm->rtm_family = src->afi; /* assume family == src family */
+    else rtm->rtm_family = AF_INET;
+    rtm->rtm_dst_len = dst_plen;
+    rtm->rtm_src_len = src_plen;
+    rtm->rtm_table = table;
+    rtm->rtm_scope = RT_SCOPE_UNIVERSE;
+    rtm->rtm_type = type;
+    rtm->rtm_flags = flags;
+
+    if(dst) {
+        attr_size = ((dst->afi == AF_INET6) ?  
+                sizeof(struct in6_addr) : sizeof(struct in_addr));
+        addattr_l(n, sizeof(buf), RTA_DST, &(dst->address), attr_size);
+    }
+    if (src) {
+        attr_size = ((src->afi == AF_INET6) ?  
+                sizeof(struct in6_addr) : sizeof(struct in_addr));
+        addattr_l(n, sizeof(buf), RTA_SRC, &(src->address), attr_size);
+    }
+    if (priority)
+        addattr_l(n, sizeof(buf), RTA_PRIORITY, &priority,
+                sizeof(uint32_t));  
+    if (if_index)
+        addattr_l(n, sizeof(buf), RTA_IIF, &if_index, 
+                sizeof(int));
+
+    /*
+     * Send the netlink message to kernel 
+     */
+    if (!nlsock_talk(n, 0, 0, NULL)) {
+        syslog (LOG_DAEMON, "nlsock_talk (rule_mod()) failed\n");
+        return (0);
+    }
+     
+    return 1;
+}
+
+/*
+ * This function adds a specific ip rule to 
+ * kernel's rule list
+ */
+static int rule_add(int if_index, uint8_t table,
+         uint32_t priority, uint8_t type,
+         lispd_addr_t *src, int src_plen,
+         lispd_addr_t *dst, int dst_plen, int flags)
+{
+    return rule_mod(if_index, RTM_NEWRULE, table,
+            priority, type,
+            src, src_plen, dst, dst_plen, flags);
+}
+
+/*
+ * This function deletes a specific ip rule to 
+ * kernel's rule list
+ */
+static int rule_del(int if_index, uint8_t table,
+         uint32_t priority, uint8_t type,
+         lispd_addr_t *src, int src_plen,
+         lispd_addr_t *dst, int dst_plen, int flags)
+{
+    return rule_mod(if_index, RTM_DELRULE, table,
+            priority, type,
+            src, src_plen, dst, dst_plen, flags);
+}
+
+/*
+ * This function configures source address based
+ * policy routing in the kernel
+ */
+static int setup_source_routing(iface_name, src_rloc, gateway)
+    char *iface_name;       // outgoing interface
+    lispd_addr_t *src_rloc; // src address to match
+    lispd_addr_t *gateway;  // default gateway address
+{
+
+    /* 
+     * Step 1:
+     * add the ip rule for the LISP_MN routing table
+     * ip rule add from <src_rloc> table RT_TABLE_LISP_MN
+     */
+    if (!rule_add(0, RT_TABLE_LISP_MN, LISP_MN_IP_RULE_PRIORITY, 
+            RTN_UNICAST, src_rloc, 
+            ((src_rloc->afi == AF_INET6) ? 128 : 32),
+            NULL, 0, 0 )) {
+        syslog(LOG_DAEMON, "rule_add (setup_source_routing()) failed\n");
+        return 0;
+    }
+
+    /*
+     * Step 2:
+     * add the default gateway for this rule
+     * ip route add default via <gtw> dev <iface> table RT_TABLE_LISP_MN
+     */
+    int if_index = if_nametoindex(iface_name);
+    if (!route_add(NULL, 0, 
+                NULL, 0, 
+                gateway, if_index, RT_TABLE_LISP_MN)) {
+        syslog(LOG_DAEMON, "route_add (setup_source_routing()) failed\n");
+        return 0;
+    }
+    return 1;
+}
+
+/* This function deletes the rule and default gateway
+ * for a particular policy route
+ */
+static int delete_source_routing(iface_name, src_rloc, gateway)
+    char *iface_name;       // outgoing interface
+    lispd_addr_t *src_rloc; // src address to match
+    lispd_addr_t *gateway;  // default gateway address
+{
+    int if_index = if_nametoindex(iface_name);
+
+    /* 
+     * Step 1:
+     * delete the ip rule for the LISP_MN routing table
+     * ip rule del from <src_rloc> table RT_TABLE_LISP_MN
+     */
+    if (!rule_del(0, RT_TABLE_LISP_MN, LISP_MN_IP_RULE_PRIORITY, 
+            RTN_UNICAST, src_rloc, 
+            ((src_rloc->afi == AF_INET6) ? 128 : 32), 
+            NULL, 0, 0 )) {
+        syslog(LOG_DAEMON, "rule_del (delete_source_routing()) failed\n");
+        return 0;
+    }
+
+    /*
+     * Step 2:
+     * delete the default gateway for this rule
+     * ip route del default via <gtw> dev <iface> table RT_TABLE_LISP_MN
+     */
+    if (!route_del(NULL, 0, 
+                NULL, 0, gateway, if_index, RT_TABLE_LISP_MN)) {
+        syslog(LOG_DAEMON, "route_del (delete_source_routing()) failed\n");
+        return 0;
+    }
+    return 1;
+}
+
+/*
+ * This function deletes the rloc from lispd's
+ * patricia tree database and updates interface list
+ */
+int delete_rloc (iface_elt, rloc) 
+    iface_list_elt    *iface_elt;
+    lispd_addr_t      *rloc;
+{
+    patricia_node_t             *node           = NULL;
+    lispd_locator_chain_t       *locator_chain  = NULL;
+    lispd_db_entry_t            *db_entry       = NULL;
+    prefix_t                    *prefix         = NULL;
+    lispd_locator_chain_elt_t   *del_elt        = NULL;
+    lispd_locator_chain_elt_t   *prev_elt       = NULL;
+    char                        *eid            = NULL;
+    int                         afi;
+    char                        addr_str[MAX_INET_ADDRSTRLEN];
+
+    /*
+     * First find the eid associated with this interface
+     * How do we know which eid to use -- the v4 or v6 one?
+     * XXX: Assume eid's afi == rloc's afi
+     * Then, find the patricia node associated with the eid
+     */
+    switch(rloc->afi) {
+        case AF_INET:
+            eid   = strdup(iface_elt->AF4_eid_prefix);
+            prefix = ascii2prefix(rloc->afi, eid);
+            node = patricia_search_exact(AF4_database, prefix);
+            break;
+        case AF_INET6:
+            eid   = strdup(iface_elt->AF6_eid_prefix);
+            prefix = ascii2prefix(rloc->afi, eid);
+            node = patricia_search_exact(AF6_database, prefix);
+            break;
+        default:
+            syslog(LOG_DAEMON, "delete_rloc(): Unknown AFI (%d)\n", rloc->afi);
+            return (0);
+    }
+
+    if (node == NULL) {
+        syslog(LOG_DAEMON, "delete_rloc(): EID (%s) not found in database", eid);
+        free(eid);
+        return(0);
+    }
+
+    if (node->data == NULL) {           
+        syslog(LOG_DAEMON, "delete_rloc(): NULL locator chain for eid (%s)\n", eid);
+        free(eid);
+        return(0);
+    }
+
+    /*
+     * Find the matching locator_chain_elt
+     * Note: There can be situations where an interface is
+     * associated with multiple rlocs. That's why its better
+     * to search for the excat rloc match instead of the simpler
+     * match by interface name (locator_chain_elt->locator_name)
+     */
+    locator_chain = (lispd_locator_chain_t *)node->data;
+    del_elt   = locator_chain->head;
+    prev_elt  = locator_chain->head;
+
+    while (del_elt) {
+        if (!(memcmp(&del_elt->db_entry->locator, 
+                        &rloc->address, sizeof(lisp_addr_t)))) {
+
+            /* Found the matching locator;
+             * Delete the locator form the locator chain
+             */ 
+            db_entry = del_elt->db_entry;
+            if ((del_elt == locator_chain->head) && 
+                (del_elt == locator_chain->tail)) {
+
+                /* single entry in locator chain 
+                 */
+                locator_chain->head = NULL;
+                locator_chain->tail = NULL;
+
+            }
+            else {
+                prev_elt->next = del_elt->next;
+                if (del_elt == locator_chain->head) {
+                    /* set the new head */
+                    locator_chain->head = del_elt->next;
+                }
+                if (del_elt == locator_chain->tail) {
+                    /* set the new tail */
+                    locator_chain->tail = prev_elt;
+                }
+            }
+            locator_chain->locator_count -= 1;
+
+            syslog(LOG_DAEMON, "delete_rloc(): %s deleted from interface %s", 
+                    inet_ntop (db_entry->locator_afi,
+                            &(db_entry->locator.address), addr_str, 
+                            MAX_INET_ADDRSTRLEN),
+                    iface_elt->iface_name);
+
+            /* 
+             * Update iface_elt by deleting the corresponding
+             * db_entry from iface_elt
+             */
+            switch(rloc->afi) {
+                case AF_INET:
+                    del_item_from_db_entry_list(iface_elt->AF4_locators, db_entry);
+                    break;
+                case AF_INET6:
+                    del_item_from_db_entry_list(iface_elt->AF6_locators, db_entry);
+                    break;
+            }
+
+            free(db_entry);
+            free(del_elt->locator_name);
+            free(del_elt);
+            free (eid);
+            return (1); // success
+
+        }
+        prev_elt = del_elt;
+        del_elt = del_elt->next;
+    }
+
+    /* we didn't find the locator */
+    syslog(LOG_DAEMON, "delete_rloc(): %s not found in patricia tree\n",
+             inet_ntop (rloc->afi,
+                     &(rloc->address.address), addr_str, 
+                     MAX_INET_ADDRSTRLEN));
+    free(eid);
+    return(0);
+} 
+
+lispd_db_entry_t *add_rloc (iface_elt, rloc) 
+    iface_list_elt    *iface_elt;
+    lispd_addr_t      *rloc;
+{
+    patricia_node_t             *node           = NULL;
+    lispd_locator_chain_t       *locator_chain  = NULL;
+    lispd_db_entry_t            *db_entry       = NULL;
+    prefix_t                    *prefix         = NULL;
+    lispd_locator_chain_elt_t   *add_elt        = NULL;
+    char                        *token          = NULL;
+    db_entry_list_elt           *db_elt         = NULL;
+    char                        *eid            = NULL;
+    int                         afi;
+    char                        addr_str[MAX_INET_ADDRSTRLEN];
+
+    /*
+     * First find the eid associated with this interface
+     * How do we know which eid to use -- the v4 or v6 one?
+     * XXX: Assume eid's afi == rloc's afi
+     * Then, find the patricia node associated with the eid
+     */
+    switch(rloc->afi) {
+        case AF_INET:
+            eid   = strdup(iface_elt->AF4_eid_prefix);
+            prefix = ascii2prefix(rloc->afi, eid);
+            node = patricia_search_exact(AF4_database, prefix);
+            break;
+        case AF_INET6:
+            eid   = strdup(iface_elt->AF6_eid_prefix);
+            prefix = ascii2prefix(rloc->afi, eid);
+            node = patricia_search_exact(AF6_database, prefix);
+            break;
+        default:
+            syslog(LOG_DAEMON, "add_rloc(): Unknown AFI (%d)\n", rloc->afi);
+            return (0);
+    }
+
+    if (node == NULL) {
+        syslog(LOG_DAEMON, "add_rloc(): EID (%s) not found in database", eid);
+        free(eid);
+        return(0);
+    }
+
+    if ((db_entry = (lispd_db_entry_t *)
+        malloc(sizeof(lispd_db_entry_t))) == NULL) {
+        syslog(LOG_DAEMON,"add_rloc(): malloc(sizeof(lispd_database_t)): %s", strerror(errno));
+        free (eid);
+        return(0);
+    }
+    memset(db_entry,0,sizeof(lispd_db_entry_t));
+
+    /* 
+     * Fill up db_entry 
+     */
+    db_entry->locator_name = strdup(iface_elt->iface_name);
+    memcpy((void *) &(db_entry->locator.address),
+           (void *) &(rloc->address),
+           sizeof(lisp_addr_t));
+    db_entry->locator_afi = rloc->afi;
+
+    afi = get_afi(eid);
+
+    if ((token = strtok(eid, "/")) == NULL) {
+        syslog(LOG_DAEMON,"eid prefix not of the form prefix/length");
+        free (eid);
+        free(db_entry);
+        return(0);
+    }
+
+    /* 
+     *  get the EID prefix into the right place/format
+     */
+    if (inet_pton(afi, token, &(db_entry->eid_prefix.address)) != 1) {
+        syslog(LOG_DAEMON, "inet_pton: %s", strerror(errno));
+        free(db_entry);
+        free (eid);
+        return(0);
+    }
+
+    /*
+     *  get the prefix length into token
+     */
+    if ((token = strtok(NULL,"/")) == NULL) {
+        syslog(LOG_DAEMON, "strtok: %s", strerror(errno));
+        free(db_entry);
+        free (eid);
+        return(0);
+    }
+
+    db_entry->eid_prefix_length = atoi(token);
+    db_entry->eid_prefix_afi    = afi;
+
+    /* 
+     * XXX: Assume priority and weight are 
+     * identical for all locators of this iface 
+     */
+    db_entry->priority          = iface_elt->priority; 
+    db_entry->weight            = iface_elt->weight;
+    
+    /*
+     *  link up db_entry into the patricia tree
+     */
+    if ((add_elt = malloc(sizeof(lispd_locator_chain_elt_t))) == NULL) {
+        syslog(LOG_DAEMON, "add_rloc(): Can't malloc(sizeof(lispd_locator_chain_elt_t)): %s", strerror(errno));
+        free(db_entry);
+        free(eid);
+        return(0);
+    }
+    memset(add_elt, 0, sizeof(lispd_locator_chain_elt_t));
+    add_elt->db_entry      = db_entry;  
+    add_elt->locator_name  = db_entry->locator_name;
+
+    if (node->data == NULL) {           
+        /*
+         * Setup node->data
+         */
+        if ((locator_chain = malloc(sizeof(lispd_locator_chain_t))) == NULL) {
+            syslog(LOG_DAEMON, "Can't malloc(sizeof(lispd_locator_chain_t))");
+            free(db_entry);
+            free(eid);
+            return(0);
+        }
+        memset(locator_chain,0,sizeof(lispd_locator_chain_t));
+        node->data = (lispd_locator_chain_t *) locator_chain;   
+        /*
+         *      put the eid_prefix information into the locator_chain
+         */
+        copy_lisp_addr_t(&(locator_chain->eid_prefix),
+                         &(db_entry->eid_prefix),
+                         db_entry->eid_prefix_afi,
+                         0);            
+        locator_chain->eid_prefix_length    = db_entry->eid_prefix_length;
+        locator_chain->eid_prefix_afi       = db_entry->eid_prefix_afi;
+        locator_chain->eid_name             = strdup(eid);
+        locator_chain->has_dynamic_locators = DYNAMIC_LOCATOR;
+        locator_chain->timer                = DEFAULT_MAP_REGISTER_TIMEOUT;
+    } else {                            
+        /* there's an existing locator_chain */
+        locator_chain = (lispd_locator_chain_t *) node->data; 
+    }
+
+    /*
+     * Setup a new locator_chain_elt for this rloc
+     */
+    if ((add_elt = malloc(sizeof(lispd_locator_chain_elt_t))) == NULL) {
+        syslog(LOG_DAEMON, 
+                "add_rloc(): Can't malloc(sizeof(lispd_locator_chain_elt_t)): %s", 
+                strerror(errno));
+        free(db_entry);
+        free(eid);
+        return(0);
+    }
+    memset(add_elt, 0, sizeof(lispd_locator_chain_elt_t));
+    add_elt->db_entry      = db_entry;  
+    add_elt->locator_name  = db_entry->locator_name;
+
+    /*
+     *  connect up the locator_chain and locator_chain_elt
+     */
+    if (locator_chain->head == NULL) {
+        locator_chain->head = add_elt;
+        locator_chain->tail = add_elt;
+    } else {
+        locator_chain->tail->next = add_elt;
+        locator_chain->tail       = add_elt;
+    }
+
+    locator_chain->locator_count ++;
+
+    syslog(LOG_DAEMON, "add_rloc(): %s added to interface %s", 
+                    inet_ntop (db_entry->locator_afi,
+                            &(db_entry->locator.address), addr_str, 
+                            MAX_INET_ADDRSTRLEN),
+                    iface_elt->iface_name);
+
+    /* 
+     * Update iface_elt with the new db_entry element
+     */
+    if ((db_elt = (db_entry_list_elt *) malloc (sizeof(db_entry_list_elt))) == NULL) {
+        syslog(LOG_DAEMON, "add_rloc(): Can't malloc(sizeof(db_entry_list_elt))\n");
+        free(eid);
+        return (0);
+    }
+    memset (db_elt, 0, sizeof(db_entry_list_elt));
+    db_elt->db_entry    = db_entry;
+    db_elt->next        = NULL;
+    
+    switch(rloc->afi) {
+        case AF_INET:
+            add_item_to_db_entry_list(iface_elt->AF4_locators, db_elt);
+            break;
+        case AF_INET6:
+            add_item_to_db_entry_list(iface_elt->AF6_locators, db_elt);
+            break;
+    }
+
+    return db_entry;
+
+}
+
+int setup_netlink_iface ()
+{
+    struct sockaddr_nl addr;
+
+    memset(&nlh, 0, sizeof(nlsock_handle));
+    if ((nlh.fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE)) < 0)
+        return (0);
+
+    memset((void *)&addr, 0, sizeof(addr));
+
+    addr.nl_family = AF_NETLINK;
+    addr.nl_pid = getpid();
+    addr.nl_groups = LISPD_IFACE_NLMGRPS;
+
+    if (bind(nlh.fd,
+        (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+        syslog(LOG_DAEMON, 
+                "bind (setup_netlink_iface()) failed: %s\n", strerror(errno));
+        return (0);
+    }
+    return (1);
+}
+
+int process_netlink_iface ()
+{
+
+    struct  sockaddr_nl nladdr;
+    struct  msghdr msg;
+    char    buffer[65536];
+    struct  iovec iov;
+    struct  nlmsghdr *nh;
+    int     len;
+    struct  ifinfomsg   *iface;
+    char    iface_name[IFNAMSIZ];
+    lispd_db_entry_t    *db_entry = NULL;
+    iface_list_elt      *elt = NULL;
+    lispd_addr_t    rloc;
+    lispd_addr_t    gateway;
+
+    memset (buffer, 0, sizeof(buffer));
+    iov.iov_base    =   (void *)buffer;
+    iov.iov_len     =   sizeof(buffer);
+
+    memset (&msg, 0, sizeof(struct msghdr));
+    msg.msg_name    =   (void *)&(nladdr);
+    msg.msg_namelen =   sizeof(nladdr);
+    msg.msg_iov     =   &iov;
+    msg.msg_iovlen  =   1;
+
+    len = recvmsg(nlh.fd, &msg, 0);
+    if (len < 0) {
+        syslog (LOG_DAEMON, "process_netlink(): Error reading netlink message (%d)", len);
+        return (0);
+    }
+
+    nh = (struct nlmsghdr *)buffer;
+    while (NLMSG_OK(nh, len)) {
+
+        memset (&rloc, 0, sizeof(lispd_addr_t));
+        elt = NULL;
+        iface = NULL;
+        memset (&gateway, 0, sizeof(lispd_addr_t));
+
+        switch (nh->nlmsg_type) {
+            case NLMSG_DONE:
+                break;
+
+            case NLMSG_ERROR:
+                parse_nl_error(nh);
+                break; 
+
+            case RTM_NEWLINK:
+                iface   =   NLMSG_DATA(nh);
+                if_indextoname(iface->ifi_index, iface_name);
+                elt = search_iface_list(iface_name);
+                if (elt == NULL) {
+                    nh = NLMSG_NEXT(nh, len);
+                    continue;
+                }
+                syslog (LOG_DAEMON, "process_netlink(): RTM_NEWLINK on %s\n", iface_name);
+
+                /* 
+                 * Update interface status
+                 * If needed, find another active interface for control
+                 * messages
+                 */
+                if ((iface->ifi_flags & IFF_UP) && 
+                        (iface->ifi_flags & IFF_RUNNING)) 
+                    elt->ready = 1;
+                else {
+                    elt->ready = 0;
+                    if (elt == ctrl_iface) 
+                        ctrl_iface = NULL;
+                }
+                
+                if (ctrl_iface == NULL) {
+                  ctrl_iface = find_active_ctrl_iface ();
+                }
+                break;
+
+            /*    
+             * RTM_DELLINK is never received on Ubuntu 10.04
+             */
+            /* case RTM_DELLINK:
+                iface   =   NLMSG_DATA(nh);
+                if_indextoname(iface->ifi_index, iface_name);
+                syslog (LOG_DAEMON, "RTM_DELLINK on %s\n", iface_name);
+                break;
+            */
+
+            case RTM_NEWADDR:
+                elt = parse_nl_addr(nh, &rloc);
+                if (elt == NULL) {
+                    nh = NLMSG_NEXT(nh, len);
+                    continue;
+                }
+
+                db_entry = add_rloc(elt, &rloc);
+                set_rloc(&rloc);
+
+                /* 
+                 * Install the new RLOC in lisp_mod.
+                 * Note that lisp_mod will start using the 
+                 * new RLOC as soon as the RLOC is installed.
+                 * The corresponding policy routing may not even
+                 * be setup then.
+                 * Until policy routing is setup, LISP packets
+                 * with the new src RLOC will not be routed 
+                 * correclty.
+                 */
+                 
+                /* XXX:
+                 * Delay by a few seconds before installing
+                 * the new address in lisp_mod.
+                 * Else, seems to be a race condition?
+                 */
+                sleep (2);
+                if(db_entry) {
+                    install_database_mapping(db_entry);
+                } 
+                break;
+
+            case RTM_NEWROUTE:
+                elt = parse_nl_route(nh, &gateway);
+                if ((elt == NULL) || (gateway.afi == 0)) {
+                    nh = NLMSG_NEXT(nh, len);
+                    continue;
+                }
+
+                /* 
+                 * XXX:
+                 * Ubuntu 10.04 seems to support multiple default
+                 * gateways and dhclient seems to add the new gateway
+                 * as another default gateway in the system
+                 *
+                 * Can a linux system have multiple default gateways?
+                 * Do we see this behavior on other linux systems?
+                 *
+                 * In any case, we can have only 1 default gateway --
+                 * the LISP MN EID. So, delete the newly added
+                 * default gateway
+                 */
+                syslog(LOG_DAEMON, "process_netlink(): Deleting default gw\n");
+                /* 
+                 * XXX: If multiple default gateways are possible
+                 * we need to write netlink code to delete
+                 * the newly added default gw. The system()
+                 * below is a temporary fix
+                 */
+                system("ip route del default");
+
+                /* 
+                 * Make sure LISP-MN eid iface is still the default
+                 * gateway
+                 */
+                syslog(LOG_DAEMON, 
+                        "process_netlink(): Set %s as default gateway\n", 
+                        LISP_MN_EID_IFACE_NAME);
+
+                lispd_addr_t eid_addr;
+                memset (&eid_addr, 0, sizeof(lispd_addr_t));
+
+                /*
+                 * Set the EID addr on the LISP-MN Iface
+                 * Assume its the same family as the gateway family
+                 */
+                eid_addr.afi = gateway.afi; 
+                switch (gateway.afi) {
+                    case AF_INET6:
+                        memcpy(&(eid_addr.address), 
+                            &(elt->AF6_locators->head->db_entry->eid_prefix), sizeof(lisp_addr_t)); 
+                        break;
+                    default:
+                        memcpy(&(eid_addr.address), 
+                            &(elt->AF4_locators->head->db_entry->eid_prefix), sizeof(lisp_addr_t)); 
+                }
+
+                if(!route_add(NULL, 0, NULL, 0, &eid_addr, 
+                            if_nametoindex(LISP_MN_EID_IFACE_NAME),
+                            RT_TABLE_MAIN )) {
+                      syslog(LOG_DAEMON, "process_netlink(): route_add failed\n");
+                } 
+
+                /* 
+                 * Remember the new gateway for future policy 
+                 * routing updates
+                 */
+                memset(&(elt->gateway), 0, sizeof(lispd_addr_t));
+                memcpy(&(elt->gateway), &gateway, sizeof(lispd_addr_t));
+
+                /* 
+                 * setup policy routing for this interface using
+                 * this gateway
+                 */
+                syslog(LOG_DAEMON, "process_netlink(): Setup policy routing\n");
+                lispd_addr_t src_rloc;
+                memset (&src_rloc, 0, sizeof(lispd_addr_t));
+
+                /*
+                 * Assume src rloc afi == gateway's afi
+                 */
+
+                src_rloc.afi = gateway.afi;
+
+                /* XXX
+                 * What is the src rloc for policy routing?
+                 * Assume src rloc to use == head entry of
+                 * the list of locators
+                 * Ideally, we should find the src rloc in a more robust
+                 * way such as:
+                 * - go through the list of locators and find 
+                 *   the one that matches the gateway's network;
+                 *   To do this, db_entry must also store the 
+                 *   locator's netmask?
+                 */
+                db_entry = ((src_rloc.afi == AF_INET6) ? 
+                     elt->AF6_locators->head->db_entry : 
+                     elt->AF4_locators->head->db_entry);
+                memcpy(&(src_rloc.address), 
+                        &(db_entry->locator),
+                        sizeof(lisp_addr_t));
+                setup_source_routing (elt->iface_name, 
+                    &src_rloc, &gateway);
+                memcpy(&source_rloc, &src_rloc, sizeof(lispd_addr_t));
+
+                /*
+                 * Install the new src rloc/db_netry in lisp_mod
+                 * NOTE: the rloc might've already been installed
+                 * during RTM_NEWADDR
+                 */
+                install_database_mapping(db_entry);
+                set_rloc(&src_rloc);
+
+                /*
+                 * Update control interface for lispd control messages
+                 * if needed
+                 */
+                if (ctrl_iface == NULL)
+                    ctrl_iface = find_active_ctrl_iface();
+
+                /*
+                 * Map register the new RLOC
+                 */
+                /* XXX:
+                 * Delay sending map register by a few secs
+                 * Otherwise seems like a race condition?
+                 */
+                sleep (3);
+                syslog(LOG_DAEMON, "process_netlink_iface(): Map register\n");
+
+                start_periodic_map_register();
+
+                /*
+                 * Trigger SMR to MN's peers
+                 */
+                get_map_cache_list();
+
+                break; 
+
+            case RTM_DELROUTE:
+                elt = parse_nl_route(nh, &gateway);
+                if ((elt == NULL) || (gateway.afi == 0)) {
+                    nh = NLMSG_NEXT(nh, len);
+                    continue;
+                }
+                break; 
+
+            case RTM_DELADDR:
+                elt = parse_nl_addr(nh, &rloc);
+
+                if (elt == NULL) {
+                    nh = NLMSG_NEXT(nh, len);
+                    continue;
+                }
+
+                /* 
+                 * Delete the rloc from lispd's database
+                 * and interface list
+                 */
+                delete_rloc(elt, &rloc);
+
+                /* 
+                 * XXX:
+                 * Delete rloc from lisp_mod via netlink.
+                 * To do this, we need a new netlink msg 
+                 * and corresponding support in lisp_mod.
+                 * Also, lisp_mod should update LSB info
+                 * and stop encapping lisp packets with src 
+                 * addr = deleted addr
+                 */
+
+                /* 
+                 * Delete policy routing associated
+                 * with the interface
+                 */
+                if (elt->gateway.afi)
+                {
+                    delete_source_routing(elt->iface_name, &rloc,
+                            &(elt->gateway));
+
+                    memset(&elt->gateway, 0, sizeof(lispd_addr_t));
+
+                }
+
+                /*
+                 * Update ctrl_iface if needed
+                 */
+                if (elt == ctrl_iface) {
+                    ctrl_iface = NULL;
+                    ctrl_iface = find_active_ctrl_iface();
+                }
+                break;
+
+            default:
+                printf("arrived at default\n");
+                break;
+        }
+
+        if (nh->nlmsg_type == NLMSG_DONE)
+            break; //from while
+        nh = NLMSG_NEXT(nh, len);
+
+    }
+
+    return (1);
+}
+
+/*
+ * This function brings up an interface
+ * and sets the mtu on it
+ */
+int lisp_eid_iface_config(iface_name, mtu)
+    char *iface_name;
+    int mtu;
+{
+    int sd;
+    int rc;
+    struct ifreq ifr;
+    memset (&ifr, 0, sizeof(struct ifreq));
+
+    if ((sd = socket(PF_INET, SOCK_DGRAM, 0)) < 0) {
+        syslog(LOG_DAEMON, "socket (iface_config): %s", 
+                strerror(errno));
+        return 0;
+    }
+
+    strcpy(ifr.ifr_name, iface_name);
+        
+    if ((rc = ioctl(sd, SIOCGIFFLAGS, &ifr)) < 0) {
+        syslog(LOG_DAEMON, "ioctl SIOCGIFFLAGS (iface_config): %s", 
+                strerror(errno));
+        close(sd);
+        return 0;
+    }
+
+    if (!(ifr.ifr_flags & IFF_UP)) {
+        /*
+         * Get the interface up and running
+         */
+        ifr.ifr_flags |= IFF_UP | IFF_RUNNING;
+
+        if ((rc = ioctl(sd, SIOCSIFFLAGS, &ifr)) < 0) {
+            syslog(LOG_DAEMON, "ioctl SIOCSIFFLAGS (iface_config): %s", 
+                strerror(errno));
+            close(sd);
+            return 0;
+        }
+    }
+
+    /*
+     * Set the MTU on the interface
+     */
+    ifr.ifr_mtu = mtu;
+    if ((rc = ioctl(sd, SIOCSIFMTU, &ifr)) < 0) {
+        syslog(LOG_DAEMON, "ioctl SIOCSIFMTU (iface_config): %s", 
+                strerror(errno));
+        close(sd);
+        return 0;
+    }
+
+    close(sd);
+    return 1;
+
+}
+
+/* 
+ * This function configures the lisp eid interface (ex: lmn0) 
+ * 1. Configures the iface with eid addr
+ * 2. Brings up the interface and sets the mtu
+ * 3. Configures the interface as the default gw
+ */
+int setup_lisp_eid_iface(eid_iface_name, eid_addr, eid_prefix_len)
+
+        char *eid_iface_name;
+        lispd_addr_t *eid_addr;
+        int eid_prefix_len;
+{
+
+        struct in_addr ifa_broadcast;
+        int if_index = if_nametoindex(eid_iface_name);
+
+        /* 
+         * Step 1:
+         * Configure the interface with appropriate parameters
+         * such as EID addr, local addr, broadcast addr etc
+         */
+        reqaddr_t  raddr;
+        memset(&raddr, 0, sizeof(raddr));
+        raddr.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifaddrmsg));
+        raddr.n.nlmsg_type = RTM_NEWADDR;
+        raddr.n.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
+        raddr.n.nlmsg_seq = ++nlh.seq;
+        raddr.n.nlmsg_pid = getpid();
+        raddr.r.ifa_flags = IFA_F_PERMANENT; 
+        raddr.r.ifa_scope = RT_SCOPE_UNIVERSE; 
+        raddr.r.ifa_index = if_index;
+        raddr.r.ifa_prefixlen = eid_prefix_len;
+        raddr.r.ifa_family = eid_addr->afi;
+
+        int attr_size = ((eid_addr->afi == AF_INET6) ? 
+                sizeof(struct in6_addr) : sizeof(struct in_addr));
+        
+        if (!addattr_l(&(raddr.n), sizeof(raddr), IFA_ADDRESS,
+                      &(eid_addr->address), attr_size)) {
+                syslog(LOG_DAEMON, "addattr_l(IFA_ADDRESS) failed \n");
+                return 0;
+        }
+
+        /* PN:
+         * XXX IFA_LOCAL addr == IFA_ADDRESS ?
+         */
+        if (!addattr_l(&(raddr.n), sizeof(raddr), IFA_LOCAL,
+                      &(eid_addr->address), attr_size)) {
+                syslog(LOG_DAEMON, "addattr_l(IFA_LOCAL) failed\n");
+                return 0;
+        }
+
+        /* PN
+         * XXX: Set the right broadcast address
+         */
+        /* struct in_addr ifa_broadcast;
+        if (addattr_l(&raddr.n, sizeof(raddr), IFA_BROADCAST,
+                      &ifa_broadcast.s_addr,
+                      sizeof(ifa_broadcast.s_addr)) < 0) {
+                syslog(LOG_DAEMON, "addattr_l(IFA_BROADCAST) failed\n");
+                return 0;
+        } */
+
+
+        /*
+         * Send the netlink message to kernel 
+         */
+        if (!nlsock_talk(&raddr.n, 0, 0, NULL)) {
+            syslog(LOG_DAEMON, "nlsock_talk (setup_lisp_eid_iface()) failed\n");
+            return 0;
+        }
+
+        /* Step 2: 
+         * Configure the LISP EID interface:
+         */
+        if (!lisp_eid_iface_config(eid_iface_name, 
+                    LISP_MN_EID_IFACE_MTU)) {
+            syslog(LOG_DAEMON, "lisp_eid_iface_config (setup_lisp_eid_iface()) failed\n");
+            return 0;
+        }
+
+        /* 
+         * Step 3:
+         * Set the LISP EID interface as the default gateway/interface
+         */
+        if(!route_add(NULL, 0, NULL, 0, eid_addr, if_index, RT_TABLE_MAIN )) {
+            syslog(LOG_DAEMON, "route_add (setup_lisp_eid_iface()) failed\n");
+            return 0;
+        }
+        syslog(LOG_DAEMON, "Configured LISP-MN EID interface\n");
+        return 1;
+}
+
+
+/*
+ *	exit_cleanup()
+ *
+ *	remove lisp modules (and restore network settings)
+ */
+
+void exit_cleanup(void) {
+    /* Close timer file descriptors */
+    close(map_register_timer_fd);
+
+    /* Close receive sockets */
+    close(v6_receive_fd);
+    close(v4_receive_fd);
+
+    /* Close LISP netlink socket */
+    close(netlink_fd);
+
+    /* Remove lisp modules */
+    system("/sbin/modprobe -r lisp lisp_int");
+
+    /* Remove source routing ip rule */
+    delete_source_routing(ctrl_iface, &source_rloc, NULL);
+
+    /* Close routing netlink socket */
+    close(nlh.fd);
+
+    /* Close syslog */
+    closelog();
+
+    exit(EXIT_SUCCESS);
+}
Index: package/lisp/src/lispd_patricia.c
===================================================================
--- package/lisp/src/lispd_patricia.c	(revision 0)
+++ package/lisp/src/lispd_patricia.c	(revision 0)
@@ -0,0 +1,79 @@
+/*
+ * lispd_patricia.c
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Patrica tree manipulation functions
+ * 
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    David Meyer		<dmm@cisco.com>
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+#include "lispd_external.h"
+
+/*
+ *	make_and_lookup for network format prefix
+ */
+
+patricia_node_t *make_and_lookup_network(afi,addr,mask_len)
+     int	afi;
+     void      *addr;
+     int	mask_len;
+{
+    struct in_addr	*sin;
+    struct in6_addr	*sin6;
+    int			 bitlen;
+    prefix_t		*prefix;
+    patricia_node_t	*node;
+
+    if ((node = malloc(sizeof(patricia_node_t))) == NULL) {
+	syslog(LOG_DAEMON, "can't allocate patrica_node_t");
+	return(NULL);
+    }
+
+    switch(afi) {
+    case AF_INET:
+        sin    = (struct in_addr *) addr;
+	if ((prefix = New_Prefix(AF_INET, sin, mask_len)) == NULL) {
+	    syslog(LOG_DAEMON, "couldn't alocate prefix_t for AF_INET");
+	    return(NULL);
+	}
+        node   = patricia_lookup(AF4_database, prefix);
+	break;
+    case AF_INET6:
+        sin6   = (struct in6_addr *) addr;
+	if ((prefix = New_Prefix(AF_INET6, sin6, mask_len)) == NULL) {
+	    syslog(LOG_DAEMON, "couldn't alocate prefix_t for AF_INET6");
+	    return(NULL);
+	}
+        node   = patricia_lookup(AF6_database, prefix);
+	break;
+    default:
+	free(node);
+	free(prefix);
+        syslog(LOG_DAEMON, "Unknown afi (%d) when allocating prefix_t", afi);
+	return (NULL);
+    }
+    Deref_Prefix (prefix);
+    return(node);
+}
Index: package/lisp/src/timerfd.c
===================================================================
--- package/lisp/src/timerfd.c	(revision 0)
+++ package/lisp/src/timerfd.c	(revision 0)
@@ -0,0 +1,32 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * timerfd_create() / timerfd_settime() / timerfd_gettime() for uClibc
+ *
+ * Copyright (C) 2009 Stephan Raue <stephan@openelec.tv>
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ */
+	
+#include <sys/syscall.h>
+/*#include <sys/timerfd.h>*/
+#include "timerfd.h"
+	
+/*
+ * timerfd_create()
+ */
+#ifdef __NR_timerfd_create
+int timerfd_create(int clockid, int flags)
+{
+        return syscall(__NR_timerfd_create, clockid, flags);
+}
+#endif
+	
+/*
+ * timerfd_settime()
+ */
+#ifdef __NR_timerfd_settime
+int timerfd_settime(int ufd, int flags, const struct itimerspec *umtr, struct itimerspec *otmr)
+{
+        return syscall(__NR_timerfd_settime, ufd, flags, umtr, otmr);
+}
+#endif
Index: package/lisp/src/Makefile
===================================================================
--- package/lisp/src/Makefile	(revision 0)
+++ package/lisp/src/Makefile	(revision 0)
@@ -0,0 +1,34 @@
+#
+#	Makefile for lispd
+#
+
+LIBS		+= -lconfuse -lssl -lcrypto
+INC		+= lispd.h
+OBJS		= cmdline.o timerfd.o lispd.o lispd_config.o lispd_syslog.o	\
+		  lispd_lib.o lispd_ipc.o lispd_map_register.o		\
+		  patricia/patricia.o lispd_map_request.o cksum.o	\
+		  lispd_patricia.o lispd_map_reply.o lispd_iface_mgmt.o	\
+		  lispd_iface_list.o
+EXE		= lispd
+#CC		= gcc
+#CFLAGS		= -g -DDEBUG=3
+#MAKEFILE	= Makefile
+#PREFIX		= /usr/local/sbin
+
+$(EXE): $(OBJS) 
+	$(CC) $(LDFLAGS) $(LIBS) -o $@ $^
+#	$(CC) -o $@ $^ $(CFLAGS) $(LIBS) $(LDFLAGS)
+
+%.o: %.c $(INC)
+	$(CC) $(CFLAGS) -c -o $@ $<
+#%.o: %.c $(DEPS) $(INC) $(MAKEFILE)
+#	$(CC) -c -o $@ $< $(CFLAGS)
+
+clean:
+	rm -f *.o cmdline.[ch] $(EXE) patricia/*.o cscope.out
+#
+#install: $(EXE)
+#	mkdir -p $(PREFIX) && cp $(EXE) $(PREFIX)
+#
+#tags:
+#	cscope -R -b
Index: package/lisp/src/lispd_iface_list.c
===================================================================
--- package/lisp/src/lispd_iface_list.c	(revision 0)
+++ package/lisp/src/lispd_iface_list.c	(revision 0)
@@ -0,0 +1,276 @@
+/* 
+ * lispd_iface_list.c
+ *
+ * This file is part of LISP Mobile Node Implementation.
+ * Various routines to manage the list of interfaces.
+ *
+ * Copyright (C) 2011 Cisco Systems, Inc, 2011. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Please send any bug reports or fixes you make to the email address(es):
+ *    LISP-MN developers <devel@lispmob.org>
+ *
+ * Written or modified by:
+ *    Preethi Natarajan <prenatar@cisco.com>
+ *
+ */
+
+#include "lispd.h"
+
+iface_list  *avail_phy_ifaces = NULL;
+
+/*
+ * Add a new iface_list_elt to the 
+ * tail of an iface_list
+ */
+static void add_item_to_iface_list (list, item) 
+    iface_list      *list;
+    iface_list_elt  *item;
+{
+    if (list->head == NULL) { 
+        list->head = item; 
+        list->tail = item; 
+    } 
+    else { 
+        list->tail->next = item; 
+        list->tail = item; 
+    }
+}
+
+/*
+ * Add a new db_entry_list_elt to the
+ * head of a db_entry_list
+ */
+void add_item_to_db_entry_list (list, item) 
+    db_entry_list      *list;
+    db_entry_list_elt  *item;
+{
+    db_entry_list_elt   *prev_head = NULL;
+    if (list->head == NULL) { 
+        list->head = item; 
+        list->tail = item; 
+    } 
+    else { 
+        /* 
+         * Add new locators to the head of the list
+         * such that head of list is most likely the best
+         * source rloc to use for control/data msgs.
+         */
+        prev_head = list->head;
+        list->head = item;
+        item->next = prev_head;
+    }
+}
+
+/*
+ * Delete db_entry_list_elt from db_entry_list
+ */
+int del_item_from_db_entry_list (list, item)
+    db_entry_list      *list;
+    lispd_db_entry_t         *item;
+{
+    db_entry_list_elt   *prev = list->head;
+    db_entry_list_elt   *curr = list->head;
+
+    if ((list->head->db_entry == item) && 
+            (list->tail->db_entry == item)) {
+        free (list->head);
+        list->head = NULL;
+        list->tail = NULL;
+        return (1);
+    }
+    while (curr) {
+         if (curr->db_entry == item) {
+             prev->next = curr->next;
+             if(curr == list->head) {
+                /* set new head */
+                list->head = curr->next;
+             }
+             if (curr == list->tail) {
+                /* set new tail */
+                list->tail = prev;
+             }
+
+             free (curr);
+             return (1);
+         }
+         prev = curr;
+         curr = curr->next;
+    } 
+    return (0);
+}
+
+/*
+ * Search iface_list for an iface_list_elt
+ * with a particular interface name
+ */
+iface_list_elt *search_iface_list (iface_name) 
+    char            *iface_name;
+{
+    iface_list_elt  *item = avail_phy_ifaces->head;
+    while (item) { 
+        if (!strcmp((item)->iface_name, iface_name)) 
+            return item;
+        item = item->next;
+    } 
+    return (NULL);
+}
+
+
+static void dump_iface_list (item)
+    iface_list_elt *item;
+{
+    syslog(LOG_DAEMON, "Interface list:");
+    while (item) { 
+        syslog(LOG_DAEMON, "  %s %s %s %p %p %d\n",
+                item->iface_name, 
+                item->AF4_eid_prefix, item->AF6_eid_prefix,
+                item->AF4_locators, item->AF6_locators, item->ready); 
+        item = item->next; 
+    }
+}
+
+/*
+ * Add/update iface_list_elt with the input parameters
+ */
+int update_iface_list (iface_name, eid_prefix, 
+        db_entry, is_up, priority, weight)
+    char *iface_name;
+    char *eid_prefix;
+    lispd_db_entry_t  *db_entry;
+    int is_up;
+    int weight;
+    int priority;
+{
+    iface_list_elt *elt = NULL;
+    db_entry_list_elt *db_elt   = NULL;
+    int afi;
+
+    if (!avail_phy_ifaces) {
+        /* first iface_list_elt */
+        if((avail_phy_ifaces = (iface_list *) malloc (sizeof(iface_list))) == NULL) {
+            syslog(LOG_DAEMON, "Can't malloc(sizeof(iface_list))\n");
+            return (0);
+        }
+        memset (avail_phy_ifaces, 0, sizeof(iface_list));
+    }
+
+    elt = search_iface_list (iface_name);
+
+    if (elt == NULL) {
+        /* should create a new iface_list_elt */
+        if ((elt = (iface_list_elt *) malloc (sizeof(iface_list_elt))) == NULL) {
+            syslog(LOG_DAEMON, "Can't malloc(sizeof(iface_list_elt))\n");
+            return (0);
+        }
+        memset (elt, 0, sizeof(iface_list_elt));
+        if (((elt->AF4_locators = (db_entry_list *)malloc (sizeof(db_entry_list))) == NULL) ||
+            ((elt->AF6_locators = (db_entry_list *)malloc (sizeof(db_entry_list))) == NULL)) {
+
+            syslog(LOG_DAEMON, "Can't malloc(sizeof(db_entry_list)\n");
+            free(elt->AF4_locators);
+            free(elt->AF6_locators);
+            free(elt);
+            return (0);
+        }
+        memset (elt->AF4_locators, 0, sizeof(db_entry_list));
+        memset (elt->AF6_locators, 0, sizeof(db_entry_list));
+        elt->iface_name     = strdup(iface_name);
+
+        afi = get_afi(eid_prefix);
+        switch (afi) {
+            case AF_INET6:
+                if (!elt->AF6_eid_prefix) 
+                    elt->AF6_eid_prefix = strdup(eid_prefix);
+            default:
+                if (!elt->AF4_eid_prefix) 
+                    elt->AF4_eid_prefix = strdup(eid_prefix);
+        }
+
+        add_item_to_iface_list (avail_phy_ifaces,elt);
+    }
+
+    elt->ready          = is_up;
+    elt->weight         = weight;
+    elt->priority       = priority;
+
+    if (db_entry == NULL)
+        /* No rloc available to add */
+        return (1);
+
+    if ((db_elt = (db_entry_list_elt *) malloc (sizeof(db_entry_list_elt))) == NULL) {
+            syslog(LOG_DAEMON, "Can't malloc(sizeof(db_entry_list_elt))\n");
+            return (0);
+    }
+    memset (db_elt, 0, sizeof(db_entry_list_elt));
+    db_elt->db_entry    = db_entry;
+    db_elt->next        = NULL;
+
+    switch (db_entry->locator_afi) {
+        case AF_INET:
+            add_item_to_db_entry_list(elt->AF4_locators, db_elt);
+            break;
+        case AF_INET6:
+            add_item_to_db_entry_list(elt->AF6_locators, db_elt);
+            break;
+        default:
+            syslog (LOG_DAEMON, "Unknown AFI; db_entry not added\n");
+
+    }
+
+    dump_iface_list(avail_phy_ifaces->head);
+
+    return (1);
+}
+
+/*
+ * Function returns an active (up and running) physical interface
+ * with a v4 or v6 locator
+ */
+iface_list_elt *find_active_ctrl_iface()
+{
+    iface_list_elt  *temp = avail_phy_ifaces->head;
+    char x[128];
+
+    while (temp) {
+        if (temp->ready) {
+            if (temp->AF4_locators->head) {
+                if (temp->AF4_locators->head->db_entry) {
+                    syslog(LOG_DAEMON, "Interface for ctrl msgs: %s, v4 rloc: %s\n", 
+                        temp->iface_name,
+                        inet_ntop(AF_INET, 
+                            &(temp->AF4_locators->head->db_entry->locator), 
+                            x, 128));
+                    return temp;
+                }
+            }
+            if (temp->AF6_locators->head) {
+                if (temp->AF6_locators->head->db_entry) {
+                    syslog(LOG_DAEMON, "Interface for ctrl msgs: %s, v6 rloc: %s\n", 
+                        temp->iface_name,
+                        inet_ntop(AF_INET6, 
+                            &(temp->AF6_locators->head->db_entry->locator), 
+                            x, 128));
+                    return temp;
+                }
+            }
+        }
+        temp = temp->next;
+
+    }
+    syslog(LOG_DAEMON, "Cannot find interface for control messages\n");
+    return NULL;
+}
Index: package/lisp/Makefile
===================================================================
--- package/lisp/Makefile	(revision 0)
+++ package/lisp/Makefile	(revision 0)
@@ -0,0 +1,44 @@
+#
+# OpenWrt LISP Package
+# Vasileios Lakafosis (vasileios@gatech.edu)
+#
+
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=lisp
+PKG_RELEASE:=1
+PKG_VERSION:=0.1
+
+PKG_BUILD_DIR:=$(BUILD_DIR)/$(PKG_NAME)
+include $(INCLUDE_DIR)/package.mk
+
+define Package/$(PKG_NAME)/default
+  URL:=http://lisp.cisco.com/
+endef
+
+define Package/$(PKG_NAME)
+  SECTION:=net
+  CATEGORY:=Network
+  TITLE:=LISP - Locator/ID Separation Protocol
+  DEPENDS:=+kmod-lisp_mod +kmod-lisp_int
+  $(call Package/$(PKG_NAME)/default)
+endef
+
+define Package/$(PKG_NAME)/description
+This packet provides support for the Locator-ID support protocol.
+endef
+
+define Build/Prepare
+	mkdir -p $(PKG_BUILD_DIR)
+	$(CP) -r ./src/* $(PKG_BUILD_DIR)/
+endef
+
+define Package/lisp/install
+	mkdir -p $(1)/usr/sbin/lisp
+	$(INSTALL_DIR) $(1)/usr/sbin/lisp
+	$(INSTALL_BIN) $(PKG_BUILD_DIR)/lispd $(1)/usr/sbin/lisp
+	mkdir -p $(1)/lib/network/lisp
+	$(CP) ./files/* $(1)/lib/network/lisp
+endef
+
+$(eval $(call BuildPackage,$(PKG_NAME)))
